1
00:00:27,294 --> 00:00:31,294
Hello. Conference 42, site reliability Engineering

2
00:00:31,374 --> 00:00:35,062
2024 my name is Dave Argent.

3
00:00:35,198 --> 00:00:39,038
I work for Salesforce and I'm going to talk about how to

4
00:00:39,086 --> 00:00:42,234
avoid becoming an agile victim.

5
00:00:46,534 --> 00:00:50,030
Brief agenda introduction a little

6
00:00:50,062 --> 00:00:53,726
bit about what Agile is, how to fail thinking before you

7
00:00:53,750 --> 00:00:57,726
code balancing tactics and strategy. Code isn't your only deliverable

8
00:00:57,830 --> 00:01:01,190
and the big take home lessons. So since we've got about 30 minutes,

9
00:01:01,222 --> 00:01:04,478
let's get moving. By way of introduction,

10
00:01:04,526 --> 00:01:08,014
who am I? I'm a veteran of Microsoft

11
00:01:08,054 --> 00:01:11,646
and Amazon, currently working for Salesforce. I have more than two decades

12
00:01:11,670 --> 00:01:15,006
of experience in online services delivery, primarily as

13
00:01:15,030 --> 00:01:18,382
an SRE and a TPM. I am also

14
00:01:18,438 --> 00:01:22,070
a battle scar veteran of agile gone wrong and I'm eager

15
00:01:22,102 --> 00:01:26,052
to help others like you avoid being victimized in the same

16
00:01:26,108 --> 00:01:29,540
way as I was. I'm currently working as

17
00:01:29,572 --> 00:01:32,932
a senior level SRE at Salesforce

18
00:01:33,068 --> 00:01:36,508
and by way of a brief war story I'm going to talk for a few

19
00:01:36,556 --> 00:01:40,784
moments about the control plane that didn't. So hypothetically,

20
00:01:41,204 --> 00:01:44,564
I worked on a service that depending on who you talk

21
00:01:44,604 --> 00:01:47,544
to, is the largest NoSQL instance in the world.

22
00:01:48,664 --> 00:01:52,444
And it was, and it had a control plane, which was good.

23
00:01:52,824 --> 00:01:56,424
However, the fact that the control plane was only capable of replacing

24
00:01:56,504 --> 00:01:59,704
one host at a time when we were talking about 10,000

25
00:01:59,864 --> 00:02:03,296
node databases, that was a little bit less fine.

26
00:02:03,360 --> 00:02:06,464
So you can see the pitfalls of not

27
00:02:06,544 --> 00:02:10,112
designing things according to how they're actually

28
00:02:10,208 --> 00:02:12,844
going to need to be used over the longer term.

29
00:02:15,044 --> 00:02:18,692
So a very brief review of agile. So what is all the fuss

30
00:02:18,748 --> 00:02:22,532
about anyway? So it's easier to start with what

31
00:02:22,588 --> 00:02:26,624
Agile really isn't. Agile isn't a framework,

32
00:02:27,804 --> 00:02:31,104
it isn't a methodology, it isn't a process,

33
00:02:32,284 --> 00:02:36,504
it isn't a set of rules, and it is certainly not prescriptive.

34
00:02:37,044 --> 00:02:40,948
So what does that mean? So what can agile possibly be if it's

35
00:02:40,996 --> 00:02:42,264
none of those things?

36
00:02:44,564 --> 00:02:48,644
So what Agile is, is really it's a set of principles which can help guide

37
00:02:48,724 --> 00:02:53,104
your software development. And it emphasizes

38
00:02:54,244 --> 00:02:57,972
its principle, it prioritizes its principles,

39
00:02:58,068 --> 00:03:01,540
it prioritizes working software over comprehensive

40
00:03:01,652 --> 00:03:05,092
documentation. The built software stands in

41
00:03:05,108 --> 00:03:08,636
as your spec, rather than trying to document every little nuance.

42
00:03:08,740 --> 00:03:11,424
That means that you should probably comment pretty well,

43
00:03:12,394 --> 00:03:15,634
individuals and interactions over processes and

44
00:03:15,674 --> 00:03:19,266
tools. So it calls for self defined

45
00:03:19,330 --> 00:03:23,210
teams, and it emphasizes frequent face to face communication

46
00:03:23,322 --> 00:03:26,826
as opposed to heavy duty processes and

47
00:03:26,850 --> 00:03:30,514
heavy duty tools. It looks to customer

48
00:03:30,554 --> 00:03:33,994
collaboration over contract negotiation. Customer needs

49
00:03:34,034 --> 00:03:37,490
can change and we need to flexibly adjust to

50
00:03:37,522 --> 00:03:40,584
that reality. We learn things by iterating

51
00:03:41,444 --> 00:03:45,284
and that goes into our last point where we are responding to change instead

52
00:03:45,324 --> 00:03:49,348
of rigidly following a plan. So this is an iterative

53
00:03:49,436 --> 00:03:53,612
approach. You build small chunks of deliverable functionality at a time,

54
00:03:53,788 --> 00:03:57,700
you learn from each iteration and you change courses necessary to

55
00:03:57,732 --> 00:04:01,356
get what you and the customer actually need, as opposed

56
00:04:01,420 --> 00:04:04,464
to what you thought you needed early on.

57
00:04:06,884 --> 00:04:10,972
But I just said that we want to respond to change over following

58
00:04:11,068 --> 00:04:14,628
a plan. And for certain things like architecture, you need

59
00:04:14,676 --> 00:04:18,104
a certain amount of plan because you can't simply build

60
00:04:18,684 --> 00:04:22,004
each iteration with no overarching plan. And, well,

61
00:04:22,084 --> 00:04:25,184
the same thing really holds true with software development.

62
00:04:27,844 --> 00:04:31,220
So that's really our segue into lesson

63
00:04:31,252 --> 00:04:35,042
one, how to fail, which is just because you have priorities in

64
00:04:35,058 --> 00:04:39,106
your principles, it doesn't mean that you can ignore everything

65
00:04:39,290 --> 00:04:42,414
else. So,

66
00:04:42,834 --> 00:04:46,414
failure 101 no definition of success

67
00:04:47,834 --> 00:04:52,018
how do you know if your product is successful? If you can't measure it,

68
00:04:52,146 --> 00:04:56,010
how can you determine that you've been successful in delivering what the

69
00:04:56,042 --> 00:04:57,094
customer needs?

70
00:04:59,194 --> 00:05:02,294
Understand what is going to make people use your product.

71
00:05:03,314 --> 00:05:07,266
It's going to be some, probably for online services, it's going to be some combination

72
00:05:07,370 --> 00:05:10,210
of features, reliability, performance, security,

73
00:05:10,322 --> 00:05:13,574
privacy, and a litany of other things.

74
00:05:15,034 --> 00:05:19,170
But you should also understand why would people not want to

75
00:05:19,202 --> 00:05:22,378
use your product? To some extent it's going to

76
00:05:22,386 --> 00:05:26,774
be a lack of those same items that made people want to use your product.

77
00:05:27,634 --> 00:05:30,946
The very same things which can make people want to use your

78
00:05:30,970 --> 00:05:34,970
product if you do them badly are going to be the most potent

79
00:05:35,042 --> 00:05:38,802
ways to convince them not to use it. And you

80
00:05:38,818 --> 00:05:42,774
should also understand what would cause you to stop developing this product.

81
00:05:43,354 --> 00:05:47,210
Some examples might be it's too costly to deliver the product, it becomes

82
00:05:47,242 --> 00:05:51,026
too difficult to maintain, it's too small a user base,

83
00:05:51,090 --> 00:05:53,574
there's no longer any need for it.

84
00:05:53,754 --> 00:05:58,894
But all of these things together come to a definition help

85
00:05:58,934 --> 00:06:01,874
you define what does success look like.

86
00:06:05,054 --> 00:06:09,074
However, once you understand what success looks like,

87
00:06:09,654 --> 00:06:13,542
the next likely issue in the failure process is you didn't plan

88
00:06:13,638 --> 00:06:17,342
for success. Functionality is really only

89
00:06:17,478 --> 00:06:20,234
one part of your successful product.

90
00:06:21,284 --> 00:06:24,636
There are very few incremental features that exist in a vacuum.

91
00:06:24,740 --> 00:06:28,220
There's complex interplay between features and they need to play nicely

92
00:06:28,252 --> 00:06:32,420
together. There are overarching requirements that are going to be

93
00:06:32,532 --> 00:06:36,372
necessary to meet your definition of success, and there's going to be a

94
00:06:36,388 --> 00:06:39,612
lot of invisible items that are needed to deliver functionality and

95
00:06:39,628 --> 00:06:42,980
delight your users. And while this list isn't exhaustive, you can

96
00:06:43,012 --> 00:06:46,532
see it's already pretty long on the easy to remember stuff

97
00:06:46,708 --> 00:06:50,926
like code testing for unit functional UI,

98
00:06:51,070 --> 00:06:55,094
etcetera. You've got data integrity, availability and

99
00:06:55,134 --> 00:06:58,966
security. You have availability and reliability. You have a downtime

100
00:06:59,030 --> 00:07:02,270
profile that you need to obey for maintenance or deployment of new

101
00:07:02,302 --> 00:07:05,974
code, which is often going to be zero downtime. You're going to have

102
00:07:06,014 --> 00:07:09,174
certain minimum levels of performance and scalability that are going

103
00:07:09,674 --> 00:07:13,974
to be required in order to deliver this functionality. To deliver it reliably,

104
00:07:14,014 --> 00:07:17,022
you're going to need to have monitoring in place so you can understand when it

105
00:07:17,038 --> 00:07:20,152
breaks, because it will. You need to have incident

106
00:07:20,208 --> 00:07:24,844
management and documentation so that you understand what to do when it breaks.

107
00:07:25,544 --> 00:07:29,444
And you need to have something like disaster recovery or georedundancy

108
00:07:30,304 --> 00:07:33,920
because effectively Murphy is the

109
00:07:33,952 --> 00:07:37,976
enemy of all online services. And in

110
00:07:38,000 --> 00:07:41,592
fact, I did a different conference presentation entitled Achieving

111
00:07:41,648 --> 00:07:45,432
Service how to ensure Murphy doesn't always win, where I

112
00:07:45,448 --> 00:07:47,924
go into a lot more of those details.

113
00:07:50,984 --> 00:07:54,520
Speaking of Murphy, in case I didn't already

114
00:07:54,592 --> 00:07:57,804
make it clear, things will go wrong.

115
00:07:58,304 --> 00:08:01,696
You'll note it's in all caps, and if

116
00:08:01,720 --> 00:08:04,324
I believed in the flash tag, it would have that too.

117
00:08:05,624 --> 00:08:08,724
You can't avoid the idea that things will go wrong.

118
00:08:09,064 --> 00:08:12,724
People are imperfect. That's element number one.

119
00:08:13,844 --> 00:08:17,716
So expecting everything to go perfectly when the people running

120
00:08:17,740 --> 00:08:20,824
it aren't themselves perfect is an unrealistic expectation.

121
00:08:22,004 --> 00:08:25,612
The next thing up again in all caps, because I think it's that important.

122
00:08:25,748 --> 00:08:29,184
There is no such thing as a safe change.

123
00:08:31,244 --> 00:08:35,052
I've been beaten down by these before in many

124
00:08:35,108 --> 00:08:38,740
circumstances where a change was supposed to be perfectly

125
00:08:38,772 --> 00:08:43,079
and utterly safe because it was directed against non production

126
00:08:43,191 --> 00:08:47,103
and there was a default configuration value that filtered through to production from

127
00:08:47,143 --> 00:08:50,751
that config file and boom, production went

128
00:08:50,807 --> 00:08:54,375
down when there was no known change

129
00:08:54,439 --> 00:08:58,003
going out to production. So really,

130
00:08:58,463 --> 00:09:01,559
since there's no such thing as a safe change, change is going to cause things

131
00:09:01,591 --> 00:09:04,351
to go wrong. You need to be able to diagnose your failures quickly. You need

132
00:09:04,367 --> 00:09:07,639
to be able to automate responses to bad deployments. You need to be

133
00:09:07,671 --> 00:09:10,863
able to do things like reduce the blast radius.

134
00:09:11,023 --> 00:09:15,040
All of those things that are associated with good practice

135
00:09:15,232 --> 00:09:19,000
in terms of deployment logic, you need to actually plan

136
00:09:19,072 --> 00:09:22,536
for because you're going to need it. Everything in your

137
00:09:22,560 --> 00:09:26,496
service must accommodate failure. A lot of the

138
00:09:26,520 --> 00:09:30,392
things that are going to fail are things that you have absolutely no control over.

139
00:09:30,568 --> 00:09:33,984
Your partners are going to fail you, your network providers are going to fail

140
00:09:34,024 --> 00:09:37,608
you, your hardware is going to fail at some point in time, your data center

141
00:09:37,656 --> 00:09:40,888
infrastructure, you're going to lose power, you're going to lose cooling.

142
00:09:41,056 --> 00:09:44,360
These things are going to go wrong. And that doesn't even include

143
00:09:44,432 --> 00:09:47,920
bad actors who are simply trying to rip your service down because they're

144
00:09:47,952 --> 00:09:52,664
spiteful. So ultimately,

145
00:09:52,744 --> 00:09:56,384
it's not enough to plan for failure. But you also

146
00:09:56,424 --> 00:09:59,800
need to know how to recover from a complete outage. Because coming up

147
00:09:59,832 --> 00:10:03,984
cold is, for many services, not nearly

148
00:10:04,024 --> 00:10:07,124
the same thing as recovering from a partial outage.

149
00:10:07,754 --> 00:10:11,034
And understanding how you respond to these

150
00:10:11,194 --> 00:10:14,506
huge failures is the sort of thing that you need to

151
00:10:14,530 --> 00:10:18,762
do before, not during, the outage. I'll use

152
00:10:18,898 --> 00:10:22,730
as an example. Prime Day 2018 not

153
00:10:22,762 --> 00:10:26,458
that I was the person carrying the pager for a certain database

154
00:10:26,506 --> 00:10:27,094
service.

155
00:10:28,994 --> 00:10:32,470
And it turns out that coming back from

156
00:10:32,642 --> 00:10:35,794
an outage of that nature,

157
00:10:36,614 --> 00:10:40,030
dealing with all the caches and dealing with everything else that needed to

158
00:10:40,062 --> 00:10:43,494
come back up nicely while still trying to serve the existing

159
00:10:43,534 --> 00:10:47,302
traffic is not the same as your typical outage.

160
00:10:47,478 --> 00:10:51,510
So just take it from. Take it from experience. You don't

161
00:10:51,542 --> 00:10:53,914
need to learn it yourself, learn it from me.

162
00:10:56,014 --> 00:10:59,678
And that brings us into our next section, which is really, you should think before

163
00:10:59,766 --> 00:11:03,670
you code. The cheapest place to make changes is

164
00:11:03,702 --> 00:11:07,446
when you're designing and you haven't yet written a line of code. It's like this

165
00:11:07,470 --> 00:11:11,438
for architecture. It's like this for any number of things that aren't

166
00:11:11,486 --> 00:11:12,794
software engineering.

167
00:11:15,774 --> 00:11:19,190
It's kind of the measure twice, cut once philosophy. Understand what you're

168
00:11:19,222 --> 00:11:20,994
doing before doing it.

169
00:11:23,334 --> 00:11:26,912
So in order to make your designs good, here's step

170
00:11:26,968 --> 00:11:30,752
one. Anticipate failures. Again, you're going to hear me say the word

171
00:11:30,808 --> 00:11:34,484
failure over and over in this

172
00:11:35,104 --> 00:11:38,944
presentation. It's because failures are pretty much the enemy

173
00:11:39,024 --> 00:11:42,204
of online services, and they are unavoidable.

174
00:11:43,304 --> 00:11:46,872
It is the only truly reliable thing in online services. They will

175
00:11:46,928 --> 00:11:50,640
fail. It's death, it's taxes only.

176
00:11:50,672 --> 00:11:52,644
It's probably actually worse than that.

177
00:11:53,694 --> 00:11:57,598
So since you're going to have failures, you need to understand and define

178
00:11:57,726 --> 00:12:01,806
what is acceptable. Don't design for greater reliability

179
00:12:01,870 --> 00:12:05,262
than needed. Each nine is somewhere in the

180
00:12:05,278 --> 00:12:08,870
ballpark of an order of magnitude more expensive than the one that came

181
00:12:08,902 --> 00:12:12,502
before it. So if what you need are four

182
00:12:12,558 --> 00:12:16,718
nines, don't design to five. It's only

183
00:12:16,766 --> 00:12:20,570
going to cost you an awful lot of money that you probably don't have.

184
00:12:20,742 --> 00:12:24,014
And similarly, don't design for greater performance than you need.

185
00:12:25,034 --> 00:12:28,338
If, for example, your service needs

186
00:12:28,386 --> 00:12:31,666
to respond in 200 milliseconds,

187
00:12:31,850 --> 00:12:35,706
just as an example, you probably don't need to design

188
00:12:35,770 --> 00:12:40,314
the entire service so that it successfully replies

189
00:12:40,354 --> 00:12:44,098
in 25 milliseconds. So don't design for greater performance

190
00:12:44,186 --> 00:12:46,774
than you need because it's going to be more expensive.

191
00:12:48,394 --> 00:12:51,602
It adds a lot of cost and generally it's of limited benefit to

192
00:12:51,618 --> 00:12:55,614
your customers if you've defined what is acceptable in a reasonable fashion.

193
00:12:56,314 --> 00:12:58,978
So since we've said that things will fail,

194
00:12:59,146 --> 00:13:03,026
design for fast recovery from failures. And I'm going to say monitor and

195
00:13:03,050 --> 00:13:06,458
measure, because if you can't measure it, it's very difficult to tell when it went

196
00:13:06,506 --> 00:13:09,134
wrong. And similarly,

197
00:13:09,874 --> 00:13:14,094
you don't have an ideal baseline for even understanding what wrong looks like.

198
00:13:15,294 --> 00:13:20,718
You want to automate those responses where possible, because automation

199
00:13:20,806 --> 00:13:25,286
is faster than getting a human to answer a page almost

200
00:13:25,350 --> 00:13:28,862
always. Plus, if you get paged often

201
00:13:28,918 --> 00:13:32,766
enough, and heavenly knows I have in various positions for things I've

202
00:13:32,790 --> 00:13:37,110
worked for, my sleep schedule suffers and I get cranky and cranky

203
00:13:37,142 --> 00:13:40,982
sres usually not the best thing for running services. They're just miserable to

204
00:13:40,998 --> 00:13:44,456
be around. So how about we avoid them and don't

205
00:13:44,480 --> 00:13:48,336
wake them up unless you actually have to. You need to include

206
00:13:48,400 --> 00:13:52,328
being hard down 100% in your recovery scenarios. Caches will not always

207
00:13:52,376 --> 00:13:56,024
be warm. You will have to survive a warm up of

208
00:13:56,064 --> 00:13:59,736
your service if that's the nature of your service. Similarly,

209
00:13:59,760 --> 00:14:04,004
this applies to databases and their caching algorithms and everything else.

210
00:14:05,024 --> 00:14:08,448
Know how you have to do a cold start. In addition,

211
00:14:08,536 --> 00:14:11,992
not everything, not every failure is a black and white failure.

212
00:14:12,048 --> 00:14:16,546
Sometimes they're gray. So embrace

213
00:14:16,650 --> 00:14:20,082
that gray. Build degraded modes of operation for when you or your

214
00:14:20,098 --> 00:14:23,666
dependencies fail. Even if you have the absence of

215
00:14:23,690 --> 00:14:27,274
full functionality, you should be able to, in many cases, support some user

216
00:14:27,314 --> 00:14:30,014
scenarios. Don't be afraid to do that.

217
00:14:30,874 --> 00:14:34,514
It is often better to serve some traffic than no

218
00:14:34,554 --> 00:14:38,174
traffic. And again, that's a degraded mode of operation.

219
00:14:39,294 --> 00:14:41,514
And lastly, you want multi layered security.

220
00:14:42,254 --> 00:14:45,434
Anything is a potential single point of failure.

221
00:14:45,774 --> 00:14:49,150
There are bad actors out there. Make it

222
00:14:49,222 --> 00:14:52,470
harder on them. At least don't give them just one

223
00:14:52,502 --> 00:14:56,358
hurdle to run through. Make them jump through all manner of

224
00:14:56,406 --> 00:15:00,166
hoops before they can get to the goodies and before

225
00:15:00,230 --> 00:15:02,958
they can take your services down or steal your data.

226
00:15:03,006 --> 00:15:03,914
Even worse,

227
00:15:06,994 --> 00:15:09,014
you also need to anticipate success.

228
00:15:11,194 --> 00:15:14,802
It is a less understood item

229
00:15:14,938 --> 00:15:18,810
that the most dangerous thing for an online service is

230
00:15:18,842 --> 00:15:23,458
being embarrassingly successful. So you

231
00:15:23,586 --> 00:15:26,946
are probably going to want to hire, you're probably going to want to

232
00:15:26,970 --> 00:15:30,346
architect to be very scalable in the

233
00:15:30,370 --> 00:15:33,562
instance that you might actually need it. Now, this doesn't apply to

234
00:15:33,618 --> 00:15:37,546
every single online service, but if there's the possibility that

235
00:15:37,570 --> 00:15:41,250
your popularity could blow up and you could have to support,

236
00:15:41,322 --> 00:15:46,014
for example, a couple orders of magnitude more traffic than you were initially expecting,

237
00:15:46,554 --> 00:15:49,814
leave the hooks in place so that you know how to do it,

238
00:15:50,474 --> 00:15:54,774
and doing it is frequently more efficient

239
00:15:55,354 --> 00:15:59,762
if you avoid monolithic structures. Monoliths are

240
00:15:59,938 --> 00:16:04,434
fairly well known for not being able to scale important subsystems independently,

241
00:16:04,554 --> 00:16:07,614
so you end up having to over scale to compensate.

242
00:16:09,474 --> 00:16:13,474
Microservices and similar architectural ideas like

243
00:16:13,514 --> 00:16:16,714
those allow you to scale components independently.

244
00:16:16,794 --> 00:16:19,254
That allows them to scale more efficiently.

245
00:16:20,354 --> 00:16:23,506
So in general,

246
00:16:23,690 --> 00:16:27,450
monoliths are less and less considered a

247
00:16:27,482 --> 00:16:31,346
good thing. Moving forward. If you're going to adopt a monolithic structure,

248
00:16:31,530 --> 00:16:35,858
understand that these are weaknesses and know

249
00:16:35,946 --> 00:16:38,734
that you're going to have to be able to work around them.

250
00:16:39,714 --> 00:16:43,134
You really want to avoid processes that scale linearly with people.

251
00:16:43,994 --> 00:16:47,394
For example, if a customer onboarding requires manual steps,

252
00:16:47,514 --> 00:16:51,602
this can become a bottleneck if you're a bottleneck if you're wildly successful,

253
00:16:51,658 --> 00:16:55,414
since while your service may certainly be able to scale, your staff may not.

254
00:16:56,194 --> 00:16:59,634
And at all times you want to know how to protect your service from

255
00:16:59,674 --> 00:17:03,118
excess traffic. As I said before, serving up some of your traffic

256
00:17:03,166 --> 00:17:06,234
is usually better than serving up none of it.

257
00:17:06,734 --> 00:17:08,874
You can't control client behavior.

258
00:17:11,134 --> 00:17:14,614
Despite what may be highly good intentions, clients will occasionally

259
00:17:14,654 --> 00:17:18,214
throw either bad traffic or excessive traffic against you.

260
00:17:18,334 --> 00:17:21,958
And even if you were only talking about clients, there are bad actors

261
00:17:22,006 --> 00:17:25,694
out there who are going to do the exact same thing for less generous

262
00:17:25,734 --> 00:17:26,554
motivations.

263
00:17:28,803 --> 00:17:31,979
Lastly, identifying your high value traffic and

264
00:17:32,011 --> 00:17:36,083
servicing that when resources are strained is a really good degraded mode to anticipate.

265
00:17:36,163 --> 00:17:39,867
Again, not an exhaustive list, mostly just things

266
00:17:39,915 --> 00:17:42,583
to think about overall.

267
00:17:44,963 --> 00:17:48,275
And you're going to need to anticipate change. My crystal

268
00:17:48,299 --> 00:17:51,903
ball doesn't work, and if you have a better one that accurately tells the future,

269
00:17:52,483 --> 00:17:55,684
good, good for you. Hide it or market it or do

270
00:17:55,724 --> 00:17:59,380
something, because I don't have one. But this means

271
00:17:59,452 --> 00:18:02,676
that since I can't accurately tell the future, I try to

272
00:18:02,700 --> 00:18:06,100
leave as many possible futures open as is reasonable.

273
00:18:06,172 --> 00:18:09,612
That doesn't mean I can. That doesn't mean I'm going to redesign

274
00:18:09,668 --> 00:18:13,644
emacs, which is an operating system and an editor. But the

275
00:18:13,684 --> 00:18:17,564
principle is reasonably good to design for flexibility

276
00:18:17,684 --> 00:18:21,624
and future possibilities. You don't always know what the customer will

277
00:18:22,164 --> 00:18:25,820
want or need next year. The customer doesn't always know what they're going to

278
00:18:25,852 --> 00:18:30,364
want or need next year. So design,

279
00:18:30,524 --> 00:18:33,836
especially with APIs rather than direct calls, which enables you to change

280
00:18:33,900 --> 00:18:37,084
underlying business logic without rewriting every component

281
00:18:37,124 --> 00:18:39,264
that calls it or relies on it.

282
00:18:40,324 --> 00:18:44,464
So it's use abstractions. Use abstractions where possible.

283
00:18:45,584 --> 00:18:49,256
In a lot of cases, you're going to want to understand how to

284
00:18:49,280 --> 00:18:52,520
do a zero downtime software upgrade. It's true

285
00:18:52,552 --> 00:18:56,232
that not all services will truly need this, but if you design from

286
00:18:56,248 --> 00:18:59,424
the perspective that it must be possible, it does safeguard

287
00:18:59,464 --> 00:19:03,632
your future. And most large online services are

288
00:19:03,688 --> 00:19:06,984
increasingly less and less tolerant of actual

289
00:19:07,064 --> 00:19:10,592
downtime. In the spirit of anticipating change,

290
00:19:10,688 --> 00:19:13,894
learn from experience and let it inform you you're

291
00:19:13,934 --> 00:19:17,246
going I at least try to think that I'm going to be smarter tomorrow than

292
00:19:17,270 --> 00:19:20,542
I am today, so I need to be able

293
00:19:20,558 --> 00:19:24,182
to listen to tomorrow me that actually has experiences that

294
00:19:24,198 --> 00:19:27,806
I don't have today and leverage them. Change includes changing

295
00:19:27,830 --> 00:19:31,634
in your direction or a plan in response to new information.

296
00:19:32,774 --> 00:19:36,046
So don't be afraid to change tacks when what

297
00:19:36,070 --> 00:19:37,754
you're doing isn't right.

298
00:19:39,074 --> 00:19:42,994
Couple loosely loosely coupled systems are usually easier to change

299
00:19:43,074 --> 00:19:47,218
and generally more resilient. Are they necessarily 100%

300
00:19:47,266 --> 00:19:51,050
as performant? No, they aren't necessarily, because you're frequently dealing with

301
00:19:51,082 --> 00:19:54,094
asynchronous processes instead of synchronous processes.

302
00:19:55,154 --> 00:19:59,170
Understand when you can get away with coupling loosely. Understand where

303
00:19:59,202 --> 00:20:02,506
you have to couple tightly, but the preference is coupling

304
00:20:02,570 --> 00:20:05,986
loosely will usually be a better idea

305
00:20:06,050 --> 00:20:07,814
when you have the luxury to do so.

306
00:20:09,834 --> 00:20:13,214
So now we're coming to balancing tactics and strategy.

307
00:20:13,834 --> 00:20:17,774
One of the big things with agile is agile has a tendency to

308
00:20:18,234 --> 00:20:21,666
concentrate on short term deliverables and

309
00:20:21,850 --> 00:20:25,802
not concentrating nearly so much on the long term vision. That's just

310
00:20:25,858 --> 00:20:29,650
the nature of the way agile works, its iterative processes, the way the sprints

311
00:20:29,682 --> 00:20:33,130
are constructed. All of those things tend to

312
00:20:33,162 --> 00:20:36,266
lead to a concentration and overindexing on short term

313
00:20:36,290 --> 00:20:40,020
deliverables. So in terms of

314
00:20:40,052 --> 00:20:43,540
tactics, you want to delay non critical decisions

315
00:20:43,572 --> 00:20:47,144
as long as possible. In this case, cold feet are an asset.

316
00:20:48,044 --> 00:20:51,284
You don't want to commit to a path and discover that

317
00:20:51,324 --> 00:20:53,704
you're wrong. It's expensive.

318
00:20:54,804 --> 00:20:58,748
You want to allow yourself to learn more about your problem space before making the

319
00:20:58,796 --> 00:21:02,984
non critical decisions, especially those that you can't easily walk back.

320
00:21:03,384 --> 00:21:07,216
And again, you want to leverage the agile principles. You want to embrace

321
00:21:07,280 --> 00:21:10,632
the iterative process and learn from experience and learn how

322
00:21:10,648 --> 00:21:14,536
to do things better, or learn what the right things are to

323
00:21:14,560 --> 00:21:17,968
do. And you want to actually get the right people

324
00:21:18,016 --> 00:21:21,424
in the design process. Coders are very good at writing

325
00:21:21,464 --> 00:21:24,604
code. Architects are very good at designing services.

326
00:21:25,224 --> 00:21:28,936
Sres are usually more familiar with how you actually run online

327
00:21:29,000 --> 00:21:32,246
services in the real world, so they offer a perspective that's often

328
00:21:32,310 --> 00:21:35,622
lost in the design processes. And product

329
00:21:35,678 --> 00:21:38,750
owners are usually the voice of the customer and they

330
00:21:38,782 --> 00:21:42,406
help define the requirements. All too often

331
00:21:42,590 --> 00:21:46,134
it's coders and architects and sometimes only

332
00:21:46,174 --> 00:21:49,806
the coders who are engaged in the design process. So you tend

333
00:21:49,830 --> 00:21:54,554
to lose out on perspectives which are necessary tactically.

334
00:21:57,474 --> 00:22:01,818
And the other thing on tactus is you really want to get the critical architecture

335
00:22:01,866 --> 00:22:05,290
right the first time. Architecture decisions are often

336
00:22:05,362 --> 00:22:09,226
very expensive or nearly impossible to fix later without a complete

337
00:22:09,250 --> 00:22:12,890
and total rewrite. So do your research,

338
00:22:13,082 --> 00:22:16,922
understand the requirements, plan out your overall

339
00:22:16,978 --> 00:22:20,254
very difficult to change elements like architectures.

340
00:22:21,074 --> 00:22:25,210
Everything else will usually, will usually align around

341
00:22:25,322 --> 00:22:28,894
those expensive architectural decisions with much greater flexibility.

342
00:22:29,514 --> 00:22:33,374
So again, take the stuff that you desperately need to get right.

343
00:22:33,954 --> 00:22:37,338
Make sure it's solid. The rest is probably going to iterate around

344
00:22:37,386 --> 00:22:41,058
it. Some of the things that you really need to nail down

345
00:22:41,106 --> 00:22:44,986
are scalability, availability, performance, security and data

346
00:22:45,050 --> 00:22:48,642
integrity. Without at least most of those, you don't actually have

347
00:22:48,658 --> 00:22:52,164
a service. And some of those

348
00:22:52,204 --> 00:22:55,316
things are negotiable, and you can figure out how to do some of them later.

349
00:22:55,500 --> 00:22:59,396
But if you don't actually have those ideas in mind from

350
00:22:59,420 --> 00:23:03,380
the start, it can be difficult to add them later. And security

351
00:23:03,492 --> 00:23:06,828
is the poster child for bolted on at

352
00:23:06,836 --> 00:23:10,796
the last second. And you want to design initially to

353
00:23:10,820 --> 00:23:14,468
your non negotiable requirements. There are going to be some things which are hard

354
00:23:14,516 --> 00:23:18,340
stops, and they're going to be some things which are nice to have designed

355
00:23:18,372 --> 00:23:21,464
to the things that you absolutely have to have first.

356
00:23:22,524 --> 00:23:25,884
And you want to adapt features and customer scenarios to your architecture.

357
00:23:25,924 --> 00:23:29,500
Because if it's obvious that your architecture can't support your features

358
00:23:29,652 --> 00:23:33,244
and your customer scenarios reasonably, it's time to redesign

359
00:23:33,284 --> 00:23:37,244
the architecture until it can. So if you have

360
00:23:37,284 --> 00:23:40,796
customer scenarios and your architecture literally can't support them, you don't

361
00:23:40,820 --> 00:23:44,264
have an architecture yet. And you need to go back to square

362
00:23:44,304 --> 00:23:48,080
one and figure out, okay, are those customer scenarios as

363
00:23:48,112 --> 00:23:51,480
vital as we think? And if the answer is yes, then your

364
00:23:51,512 --> 00:23:55,120
architecture needs to change. Looking at things like strategy

365
00:23:55,152 --> 00:23:58,192
for a longer term vision. Two way doors. So what's a two way

366
00:23:58,208 --> 00:24:02,376
door? Two way doors are decisions which can be easily reverted.

367
00:24:02,480 --> 00:24:05,840
One way doors, they put you on a set path with no easy way to

368
00:24:05,872 --> 00:24:09,224
backtrack. And in the software engineering business, as in

369
00:24:09,264 --> 00:24:12,096
many other things in life, sometimes you need to take a step back to go

370
00:24:12,120 --> 00:24:15,104
take three steps forward, and that's okay.

371
00:24:15,484 --> 00:24:19,172
You're leveraging one of the strengths of agile, where you learn from each iteration

372
00:24:19,228 --> 00:24:22,684
and you apply that learning. But it does mean that

373
00:24:22,724 --> 00:24:26,564
it's worth it to try to make your decisions reversible, so that taking that

374
00:24:26,604 --> 00:24:30,236
step back is easy. You're not blocked from doing so. You don't

375
00:24:30,260 --> 00:24:33,316
have 39 dependencies on the element that you would like to

376
00:24:33,340 --> 00:24:37,380
fix. Now you can't. And as much as you need to design for

377
00:24:37,412 --> 00:24:40,830
flexibility, you also need to be able to plan flexibly.

378
00:24:40,972 --> 00:24:44,282
Because again, the odds are you're going to make up smarter one day than

379
00:24:44,298 --> 00:24:47,762
you are today. At least I try to make that a habit. Sometimes it works,

380
00:24:47,858 --> 00:24:50,734
sometimes it needs coffee, but there you go.

381
00:24:51,674 --> 00:24:54,362
You need to be able to listen to and be able to implement the ideas

382
00:24:54,418 --> 00:24:57,682
of that smarter you. And you need to

383
00:24:57,698 --> 00:25:01,410
be able to scrap and rework as needed without being embarrassed.

384
00:25:01,562 --> 00:25:05,242
What's important is that you get to the right end point, that you

385
00:25:05,258 --> 00:25:08,928
get the desired result. Sometimes the path to get there is going

386
00:25:08,936 --> 00:25:13,044
to be a little bit crooked. And again, that's okay.

387
00:25:13,864 --> 00:25:16,684
Software development in the agile software department.

388
00:25:17,744 --> 00:25:21,496
In agile, good to learn

389
00:25:21,600 --> 00:25:25,424
from experience and to figure out better ways of doing

390
00:25:25,504 --> 00:25:28,992
things. So if the straight line path isn't the one that you

391
00:25:29,008 --> 00:25:32,336
end up taking, as long as you get where you need to go, that's the

392
00:25:32,360 --> 00:25:33,364
important part.

393
00:25:35,554 --> 00:25:38,894
Which brings us to really how much planning is enough.

394
00:25:39,874 --> 00:25:43,634
And the answer is, even in agile, planning is necessary. But this

395
00:25:43,674 --> 00:25:46,930
isn't the same as waterfall. We don't want to

396
00:25:46,962 --> 00:25:50,826
plan every little thing. We want to embrace

397
00:25:51,010 --> 00:25:54,498
the iterative process. We want to allow ourselves to learn from

398
00:25:54,546 --> 00:25:58,226
experience as we go so that we can determine what the right things to

399
00:25:58,250 --> 00:26:01,818
do are and how best to do them. You will probably

400
00:26:01,866 --> 00:26:05,074
change significant elements over time based on what you learn,

401
00:26:05,194 --> 00:26:12,162
and that's a positive good, that's a feature, not a bug for

402
00:26:12,178 --> 00:26:16,174
your planning. You need to understand what you actually need for long term success,

403
00:26:16,594 --> 00:26:19,774
and you can't compromise on being able to deliver it.

404
00:26:20,234 --> 00:26:23,414
You need to know the shape of what it is that you want to deliver,

405
00:26:23,994 --> 00:26:27,094
how you're going to deliver it, and how you're going to support it during

406
00:26:27,134 --> 00:26:31,030
its lifetime. Again, this dovetails back into planning

407
00:26:31,062 --> 00:26:35,046
for success, planning for failure, and understanding

408
00:26:35,230 --> 00:26:38,674
what it is are you trying to build, what are you trying to deliver,

409
00:26:39,014 --> 00:26:42,206
and making sure that you actually have a life cycle which can work

410
00:26:42,230 --> 00:26:46,382
in the real world. And lastly, you're probably

411
00:26:46,438 --> 00:26:49,474
going to be wrong about all of these things at least once.

412
00:26:49,854 --> 00:26:53,110
And if you're me, frequently. So it means

413
00:26:53,142 --> 00:26:56,726
you really need to be prepared to adapt to real world circumstances. And again,

414
00:26:56,790 --> 00:27:00,374
embrace the idea that we're going to learn, we're going to do things better

415
00:27:00,414 --> 00:27:03,806
tomorrow than we did them today. Be ready for

416
00:27:03,830 --> 00:27:07,334
it, don't be embarrassed. Don't feel like you have to fall on your sword for

417
00:27:07,374 --> 00:27:10,422
it. This is part of good,

418
00:27:10,478 --> 00:27:13,274
positive software engineering using agile,

419
00:27:15,374 --> 00:27:19,140
and something that commonly gets overlooked in

420
00:27:19,222 --> 00:27:22,656
most development methodologies, but especially in agile, is the code

421
00:27:22,680 --> 00:27:26,208
is not your only deliverable online

422
00:27:26,256 --> 00:27:29,424
services really are more than just code. They include data monitoring,

423
00:27:29,464 --> 00:27:33,064
testing, documentation, redundancy, availability, disaster recovery,

424
00:27:33,104 --> 00:27:36,496
performance budgeting and more other things than I really want to shake a stick at

425
00:27:36,520 --> 00:27:39,896
in a short presentation. So deliverables 101

426
00:27:39,920 --> 00:27:43,480
the service code is actually the easy part because you understand

427
00:27:43,632 --> 00:27:45,884
there is a concentrated team writing it.

428
00:27:46,944 --> 00:27:50,720
It is the thing that gets most software engineers promoted. So good

429
00:27:50,752 --> 00:27:54,056
software engineers have a tendency to know how to write reasonably good service

430
00:27:54,120 --> 00:27:58,032
code. Look at all the things that

431
00:27:58,088 --> 00:28:01,984
aren't service code monitoring, alerting and incident response

432
00:28:02,144 --> 00:28:05,880
documentation runbooks any external facing documentation for the

433
00:28:05,912 --> 00:28:09,336
customer, your network, your security testing

434
00:28:09,360 --> 00:28:12,146
in your test framework, deployment tools, SLA's,

435
00:28:12,240 --> 00:28:16,514
Ola's and SLOS administrative tools reporting. The list goes on

436
00:28:16,854 --> 00:28:20,990
for things that you need to successfully deliver online services that

437
00:28:21,022 --> 00:28:23,234
aren't actually part of your service code.

438
00:28:24,494 --> 00:28:28,350
So what do we need to do? We need to integrate non code deliverables into

439
00:28:28,382 --> 00:28:31,846
our planning and execution cycles. We need to add non code items into

440
00:28:31,870 --> 00:28:35,470
the backlog. Since the backlog tends to be fairly king

441
00:28:35,662 --> 00:28:39,302
in most agile houses, make sure that your non code items

442
00:28:39,318 --> 00:28:43,014
are there. You need to understand what you need to successfully release.

443
00:28:43,094 --> 00:28:46,510
What's going to block? What is my non code

444
00:28:46,542 --> 00:28:50,070
collateral that's necessary to release? And sometimes the right answer here is to create

445
00:28:50,102 --> 00:28:54,062
a release sprint. Just because you complete a

446
00:28:54,078 --> 00:28:57,614
sprint doesn't mean you're actually releasing the products of that sprint.

447
00:28:57,734 --> 00:29:01,414
Sometimes you are, sometimes you aren't. But frequently,

448
00:29:01,494 --> 00:29:03,754
especially if you're dealing with major changes,

449
00:29:05,414 --> 00:29:08,342
some things you're only going to need to do if you're releasing that's really much

450
00:29:08,358 --> 00:29:11,630
of a non code. Your processes are

451
00:29:11,662 --> 00:29:15,630
often going to need to change around major releases, since a much larger

452
00:29:15,662 --> 00:29:20,334
percentage of time is spent doing bug fix work from

453
00:29:20,374 --> 00:29:23,774
newly discovered bugs that aren't in the backlog. And you're going to need to allocate

454
00:29:23,814 --> 00:29:27,574
your time in a very different way when

455
00:29:27,614 --> 00:29:30,846
you're getting to the heart of a release than you are when

456
00:29:30,870 --> 00:29:34,206
you're just cruising along in a standard sprint. You need to

457
00:29:34,230 --> 00:29:37,470
ignore your non blocking code items for the backlog and you're going to concentrate on

458
00:29:37,502 --> 00:29:41,570
bug fixing fixes in non code deliverables. You are going to test,

459
00:29:41,682 --> 00:29:45,250
you're going to test, and you're going to test some more. This hopefully

460
00:29:45,282 --> 00:29:48,922
is going to include game days and breaking non production to ensure that

461
00:29:48,938 --> 00:29:52,654
your runbooks, your monitoring and your incident response are all solid

462
00:29:53,274 --> 00:29:56,362
and you're going to test some more and you're going to do deployments so

463
00:29:56,378 --> 00:29:59,254
that you know what to expect before, after and during.

464
00:30:00,034 --> 00:30:04,614
And you're going to need to train your operational staff and vet the documentation carefully.

465
00:30:05,484 --> 00:30:09,524
All of these are deliverables that aren't actually your service code.

466
00:30:09,644 --> 00:30:12,364
You need to plan for it and you need to account for it both in

467
00:30:12,404 --> 00:30:16,412
time and effort, and preferably in rewards and acknowledgement

468
00:30:16,468 --> 00:30:19,860
for software engineers who are engaged in

469
00:30:19,892 --> 00:30:22,264
writing non code collateral.

470
00:30:24,204 --> 00:30:27,964
So in summary, even with the principles of agile,

471
00:30:28,084 --> 00:30:31,660
you need to do some planning to ensure the long term success of your

472
00:30:31,692 --> 00:30:35,284
production. Don't compromise on those elements.

473
00:30:35,984 --> 00:30:39,504
Your long term success is crucial in nearly every

474
00:30:39,544 --> 00:30:43,320
product you're going to design. Architectural defect defects

475
00:30:43,352 --> 00:30:46,552
and deficits in the areas of redundancy, availability,

476
00:30:46,688 --> 00:30:49,952
monitoring and performance can absolutely destroy trust in

477
00:30:49,968 --> 00:30:53,496
your product weeks, months or years from now.

478
00:30:53,640 --> 00:30:56,840
And it can be very difficult and expensive to fix.

479
00:30:57,032 --> 00:31:00,804
So this is why having a certain amount of rigor in

480
00:31:00,844 --> 00:31:04,308
planning, understanding what's important to plan,

481
00:31:04,476 --> 00:31:07,628
what's less important to plan, and all of these

482
00:31:07,676 --> 00:31:11,024
sorts of things can come together. So if you learn nothing else,

483
00:31:11,684 --> 00:31:15,148
it's don't over plan. Don't be afraid

484
00:31:15,196 --> 00:31:19,308
to learn from experience as you move forward and

485
00:31:19,356 --> 00:31:22,916
lock in your expensive to change things as early in the

486
00:31:22,940 --> 00:31:27,178
process as possible. Because again, if the cost of change is high,

487
00:31:27,346 --> 00:31:29,894
you really want to make sure you don't have to.

488
00:31:32,034 --> 00:31:35,774
Thank you for listening. Again, my name is Dave Argent.

489
00:31:36,634 --> 00:31:39,054
My email is dargentmail.com.

490
00:31:39,874 --> 00:31:43,154
I work at salesforce. I also have a LinkedIn. I believe

491
00:31:43,194 --> 00:31:46,402
I'm the only David Argent out there, so if you

492
00:31:46,418 --> 00:31:50,730
need to contact me, feel free to contact me that way. And again,

493
00:31:50,922 --> 00:31:53,634
thank you everyone and I hope you have a good rest of the conference.

