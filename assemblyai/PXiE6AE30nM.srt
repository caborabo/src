1
00:00:25,250 --> 00:00:29,814
Event driven architectures orchestrating cloud native workflows so

2
00:00:29,852 --> 00:00:32,502
this is the trending and important topic right now, right?

3
00:00:32,636 --> 00:00:35,560
So I'm super excited to explore it.

4
00:00:36,010 --> 00:00:39,702
And Eds all about using

5
00:00:39,756 --> 00:00:43,586
events signals that something has happened to orchestrate

6
00:00:43,618 --> 00:00:47,830
workflows and create responsive, scalable systems.

7
00:00:48,330 --> 00:00:52,110
So let's embark on journey together and unlock the potential.

8
00:00:53,170 --> 00:00:56,922
This is Mustafal Mahmoud working as a software engineer

9
00:00:56,986 --> 00:01:00,446
at Brain station 23. Also proud to be

10
00:01:00,468 --> 00:01:04,500
an AWS community builder in the serverless category for 2023.

11
00:01:05,030 --> 00:01:08,606
Excited to be here today as we explore the fascinating

12
00:01:08,638 --> 00:01:11,090
the world of event driven architecture.

13
00:01:12,310 --> 00:01:16,182
Throughout my journey as a software engineer, I have had the

14
00:01:16,236 --> 00:01:20,370
privilege of working on projects for leading bands

15
00:01:20,450 --> 00:01:24,658
in the various industries. Welcome to my session on eventdriven

16
00:01:24,674 --> 00:01:28,774
architecture. Today I will cover the basics

17
00:01:28,822 --> 00:01:32,714
of EDs. I mean I will break down what they are and

18
00:01:32,752 --> 00:01:36,634
the key concepts that make them why use

19
00:01:36,672 --> 00:01:40,640
the event event architecture and how to use it?

20
00:01:41,090 --> 00:01:45,070
Orchestration and versus choreography I will compare these

21
00:01:45,140 --> 00:01:49,066
two approaches to coordinating tasks in the eventdriven

22
00:01:49,098 --> 00:01:52,518
architecture. I will discuss some key factors

23
00:01:52,554 --> 00:01:57,246
to keep in mind when designing your own event driven systems.

24
00:01:57,438 --> 00:02:01,186
I'll share some pro tips for building robust and

25
00:02:01,208 --> 00:02:04,980
scalable eventdriven. Yeah, I will

26
00:02:05,430 --> 00:02:09,054
show you the live demo for error handling

27
00:02:09,102 --> 00:02:12,706
workflows following the ads architecture

28
00:02:12,898 --> 00:02:16,902
and I will wrap up at the end of this session with some

29
00:02:16,956 --> 00:02:21,334
helpful resources to keep your EDs journey going. So let's

30
00:02:21,462 --> 00:02:24,886
jump right in. So in today's dynamic

31
00:02:24,918 --> 00:02:28,842
world, applications are constantly responding to user sections and

32
00:02:28,896 --> 00:02:32,506
system changes. So eventdriven architecture place events

33
00:02:32,538 --> 00:02:36,186
at the core of application development. So modern

34
00:02:36,218 --> 00:02:39,790
applications are inherently event driven. I mean

35
00:02:39,860 --> 00:02:43,826
events are everywhere. So for example a

36
00:02:43,848 --> 00:02:47,186
customer placing an order, a social media post being

37
00:02:47,208 --> 00:02:50,590
created, or a sensor reading being uploaded.

38
00:02:50,750 --> 00:02:53,998
So event driven architecture place these events at the core

39
00:02:54,014 --> 00:02:57,238
of application development, transforming them

40
00:02:57,324 --> 00:03:00,646
from a byproduct into a

41
00:03:00,668 --> 00:03:04,706
powerful communication mechanism. So service publish events,

42
00:03:04,738 --> 00:03:08,602
something happened and subscribe to relief and events. I mean

43
00:03:08,656 --> 00:03:12,406
react to what happened, leading to loose coupling and faster development

44
00:03:12,438 --> 00:03:16,102
cycles. So there are some cloud providers like AWs,

45
00:03:16,166 --> 00:03:19,878
Azure, GCP. So they offered

46
00:03:19,974 --> 00:03:23,402
a comprehensive toolkit for building serverless event

47
00:03:23,456 --> 00:03:26,762
event architecture services like AWS Lambda,

48
00:03:26,906 --> 00:03:31,150
AWS, Amazon Kinesis for event streaming,

49
00:03:31,570 --> 00:03:34,990
Amazon SNS, SQS, etc.

50
00:03:35,590 --> 00:03:39,586
And Azure provides azure functions for serverless and azure app

51
00:03:39,608 --> 00:03:43,182
service for managed serverless. Also GCP provides

52
00:03:43,246 --> 00:03:47,046
cloud functions and so on. So there are

53
00:03:47,068 --> 00:03:50,070
some core values of event driven architecture.

54
00:03:51,210 --> 00:03:54,470
These are all about building complex applications.

55
00:03:54,890 --> 00:03:58,914
Unlike traditional architectures that constantly ping

56
00:03:58,962 --> 00:04:02,386
for updates, eventdriven architectures reacts to events

57
00:04:02,418 --> 00:04:05,610
in the real time. This shift unlock some amazing benefits.

58
00:04:05,680 --> 00:04:08,854
I mean independent feature development, effortless feature

59
00:04:08,902 --> 00:04:12,250
integration, loose coupling, and modularity.

60
00:04:12,670 --> 00:04:16,062
So imagine microservices like building blocks with AdA, teams can

61
00:04:16,116 --> 00:04:19,450
work independently on services that publish and subscribe to events.

62
00:04:19,530 --> 00:04:22,766
This reduces dependencies and lets

63
00:04:22,798 --> 00:04:26,738
you roll out new features much faster and

64
00:04:26,824 --> 00:04:30,146
effortless feature integration. I mean, adding new

65
00:04:30,168 --> 00:04:34,734
features becomes a breeze, right? So no need to modify existing applications.

66
00:04:34,862 --> 00:04:38,546
New features can simply subscribe to existing events like plugging

67
00:04:38,578 --> 00:04:41,510
into a real time information string for innovation.

68
00:04:41,930 --> 00:04:45,506
Event Architecture's SnConAs post sync lets your system handle

69
00:04:45,538 --> 00:04:49,474
massive volumes of events without bottlenecks. Plus, if one service fails,

70
00:04:49,522 --> 00:04:52,794
it doesn't bring down the whole system. Increase resilience for

71
00:04:52,832 --> 00:04:56,630
your applications. Services communicate through events,

72
00:04:56,710 --> 00:05:00,690
leading to cleaner, more modular code with less complex

73
00:05:00,790 --> 00:05:04,270
dependencies. This makes your application easier to understand,

74
00:05:04,340 --> 00:05:07,582
maintain and scale as your needs grow. I mean,

75
00:05:07,636 --> 00:05:11,566
it enhances flexibility and maintainability by reducing the impact of

76
00:05:11,588 --> 00:05:13,780
changes to one component or others.

77
00:05:14,390 --> 00:05:18,318
These are the core values. Working together create more flexible

78
00:05:18,414 --> 00:05:20,770
and robust foundation for your applications.

79
00:05:21,270 --> 00:05:24,958
So why the organizations follow the event driven architectures?

80
00:05:25,054 --> 00:05:29,170
So there are some strong points. So real time responsiveness

81
00:05:30,150 --> 00:05:33,474
event driven architecture enables applications to detect

82
00:05:33,522 --> 00:05:37,346
and response instantly to events triggered by users and systems,

83
00:05:37,458 --> 00:05:40,886
providing a seamless integration and

84
00:05:40,908 --> 00:05:45,194
interactive user experience with under low latency. So this

85
00:05:45,312 --> 00:05:49,770
real time responsiveness enhance user engagement and satisfactions.

86
00:05:50,270 --> 00:05:54,138
Eventdriven architecture facilitates seamless integration with external systems

87
00:05:54,154 --> 00:05:57,226
and services. This extensibility allows

88
00:05:57,258 --> 00:06:01,386
for integrating additional features and services to enhance the application's

89
00:06:01,418 --> 00:06:04,786
functionality. Finally, we get the

90
00:06:04,808 --> 00:06:08,206
opportunity to minimize the resource

91
00:06:08,318 --> 00:06:11,934
consumption. Unlike traditional request response model, event driven architectures

92
00:06:11,982 --> 00:06:15,226
minimize resource consumption by responding only to events,

93
00:06:15,278 --> 00:06:19,218
reducing delays, and improving server

94
00:06:19,314 --> 00:06:22,786
efficiency. This optimization enhance overall performance

95
00:06:22,818 --> 00:06:26,454
and resource utilization. Right? There are some

96
00:06:26,572 --> 00:06:29,802
key concepts of event, even architectures. I mean

97
00:06:29,856 --> 00:06:33,530
building blocks that work together to create a powerful communication mechanism.

98
00:06:34,270 --> 00:06:37,594
Let's break them down. So there

99
00:06:37,632 --> 00:06:41,418
are some key points. I mean events, event producers,

100
00:06:41,514 --> 00:06:45,866
event consumers, and event brokers. So let's

101
00:06:45,898 --> 00:06:49,582
say events signals that something has happened, an order

102
00:06:49,636 --> 00:06:53,198
created event, or a payment received event. These events are like

103
00:06:53,364 --> 00:06:57,298
little snapshots on in time describing a specific

104
00:06:57,384 --> 00:07:00,430
change that has occurred. They are also immutable,

105
00:07:00,510 --> 00:07:04,046
meaning once created, their content cannot be altered.

106
00:07:04,158 --> 00:07:07,830
This is especially beneficial in complex systems because it

107
00:07:07,900 --> 00:07:11,910
eliminates the need to constantly synchronize data across different components

108
00:07:12,490 --> 00:07:16,134
and event producers. These are the entities that create

109
00:07:16,252 --> 00:07:19,802
and publish events. Think of them

110
00:07:19,856 --> 00:07:23,926
as announcing something newsworthy. Event producers

111
00:07:23,958 --> 00:07:26,502
can be various components like UI,

112
00:07:26,566 --> 00:07:29,978
microservices, iot devices and other enterprise services.

113
00:07:30,064 --> 00:07:33,894
Or different kind of. It can be SaaS applications

114
00:07:33,942 --> 00:07:37,706
also and even consumers on the receiving

115
00:07:37,738 --> 00:07:41,294
end, we have event consumers that there

116
00:07:41,332 --> 00:07:45,306
are the downstream components that get triggered by events

117
00:07:45,418 --> 00:07:48,930
and event can have multiple consumers, each reacting in

118
00:07:49,000 --> 00:07:52,738
its own specific way. Event consumption can

119
00:07:52,904 --> 00:07:56,162
involve starting offloads, running analysis or updating

120
00:07:56,226 --> 00:08:00,502
database based on the receiving event. And another

121
00:08:00,556 --> 00:08:03,430
thing is point event brokers.

122
00:08:04,330 --> 00:08:07,750
Imagine event brokers as the communication hub.

123
00:08:08,590 --> 00:08:11,814
They act as intermediaries between producer and consumers,

124
00:08:11,862 --> 00:08:15,626
so it manages the publishing and

125
00:08:15,648 --> 00:08:19,606
subscribing of events. They buffer communication, ensuring producer

126
00:08:19,638 --> 00:08:23,586
and consumers don't need to be in sync with each other. Event bookers

127
00:08:23,638 --> 00:08:27,338
come in two forms, I mean event routers and event stores,

128
00:08:27,434 --> 00:08:30,970
event routers that actively push events to their subscribed consumers,

129
00:08:31,050 --> 00:08:34,530
and event stores where consumers can

130
00:08:34,600 --> 00:08:38,210
pull events on demand. So by understanding these key concepts

131
00:08:38,950 --> 00:08:42,242
very well, on your way to leveraging the power of the event,

132
00:08:42,296 --> 00:08:46,054
even architectures in your applications, let's talk

133
00:08:46,092 --> 00:08:49,702
about the coupling, how tightly concerned different parts of your

134
00:08:49,756 --> 00:08:53,186
application are. On one end of the spectrum

135
00:08:53,218 --> 00:08:56,934
we have type coupling. So let's see how this

136
00:08:56,972 --> 00:09:00,758
plays out. Development challenges scalability issues,

137
00:09:00,924 --> 00:09:04,950
reduced fault tolerance. So there are many complexity.

138
00:09:05,470 --> 00:09:09,382
So I mean, look at the image on the slide.

139
00:09:09,446 --> 00:09:12,826
An image in additional ecommerce applications where order processing,

140
00:09:12,858 --> 00:09:16,782
billing, shipping and inventory all rely on

141
00:09:16,836 --> 00:09:20,334
synchronous calls, a single service failure could

142
00:09:20,372 --> 00:09:24,506
disrupt the entire flow. This is where event event architecture

143
00:09:24,538 --> 00:09:27,518
comes in. EDF promotes loose coupling.

144
00:09:27,614 --> 00:09:31,262
Higher components communicate through events instead of direct calls.

145
00:09:31,406 --> 00:09:35,206
So this approach offers a significant advantage which we

146
00:09:35,228 --> 00:09:39,240
will explore in the next slide. I mean,

147
00:09:39,770 --> 00:09:42,946
it is considered the power of events.

148
00:09:43,058 --> 00:09:46,866
So let's see how the event driven architecture

149
00:09:46,898 --> 00:09:51,446
addresses the challenges of type coupling with loose coupling, making components

150
00:09:51,478 --> 00:09:54,922
communicating through independent events. Instead of relying on the direct

151
00:09:54,976 --> 00:09:58,170
calls in loose coupling components,

152
00:09:58,670 --> 00:10:02,794
components publish events about their step changes without requiring

153
00:10:02,842 --> 00:10:06,602
immediate response from others. Think of it as sending out messages,

154
00:10:06,666 --> 00:10:10,798
as announcements, components declare what happened,

155
00:10:10,964 --> 00:10:15,234
and interested parties can react accordingly on

156
00:10:15,272 --> 00:10:18,610
their specific way, own specific way.

157
00:10:18,680 --> 00:10:21,906
So in an event event approach, components only, we need to

158
00:10:21,928 --> 00:10:25,278
be aware of the events they publish and subscribe to,

159
00:10:25,384 --> 00:10:29,462
not the internal working of other components. As long as

160
00:10:29,516 --> 00:10:32,626
the event format remains consistent,

161
00:10:32,738 --> 00:10:36,310
changes in one component won't affect other component.

162
00:10:36,890 --> 00:10:39,980
Idem potency is the crucial part. So,

163
00:10:40,750 --> 00:10:45,018
item potency, imagine pushing a button and action happens exactly

164
00:10:45,104 --> 00:10:48,474
once, even if you pass it multiple times.

165
00:10:48,592 --> 00:10:54,394
There's the essence of item potency, ensuring an operation operation

166
00:10:54,442 --> 00:10:57,678
produces the same outcome after the first successful execution, regardless of

167
00:10:57,684 --> 00:11:01,374
the retries. So why the item potency is

168
00:11:01,412 --> 00:11:04,926
important here? This property becomes

169
00:11:04,958 --> 00:11:08,606
especially important in the event, even architectures.

170
00:11:08,718 --> 00:11:11,902
So when dealing with retries,

171
00:11:12,046 --> 00:11:15,830
a common practice for handling potential failures.

172
00:11:16,410 --> 00:11:19,990
For example, let's say a lambda function triggered by an

173
00:11:20,140 --> 00:11:23,506
order place defend. So if the function encounters

174
00:11:23,538 --> 00:11:27,254
an error during the initial execution because

175
00:11:27,292 --> 00:11:31,002
of server failure, because of Internet issue or anything

176
00:11:31,056 --> 00:11:34,550
else, the lambda service might automatically retry the invocation,

177
00:11:34,630 --> 00:11:38,410
right? So without item potency safeguard, this detriment could lead

178
00:11:38,480 --> 00:11:41,918
to complex, serious issue

179
00:11:42,004 --> 00:11:45,822
and duplicate orders, corrupted data and anything else, you name

180
00:11:45,876 --> 00:11:49,520
it. So how to achieve item potency here

181
00:11:50,050 --> 00:11:53,546
in this scenario? So we can include

182
00:11:53,578 --> 00:11:57,054
a unique identifier within each event as

183
00:11:57,092 --> 00:12:00,306
an eigen potency key. This key allows the system to

184
00:12:00,328 --> 00:12:03,582
recognize if an event has already been possessed,

185
00:12:03,646 --> 00:12:07,538
preventing unintended consequences from retirees. So by incorporating

186
00:12:07,634 --> 00:12:11,746
item potency, you ensure data consistency and reliable

187
00:12:11,778 --> 00:12:13,910
operations in your event even architecture.

188
00:12:16,730 --> 00:12:19,750
So there are some common patterns of event to end architectures.

189
00:12:19,830 --> 00:12:22,950
So first of all, point to point messaging.

190
00:12:23,110 --> 00:12:25,050
Actually, it's a fundamental pattern.

191
00:12:26,990 --> 00:12:30,826
It is like sending

192
00:12:30,858 --> 00:12:33,950
a message with a specific recipient in mind.

193
00:12:34,020 --> 00:12:37,230
So this is the essence of point to point messaging.

194
00:12:37,810 --> 00:12:41,946
In event driven architectures, messages are often delivered asynchronously,

195
00:12:42,058 --> 00:12:49,202
meaning the sender doesn't wait

196
00:12:49,256 --> 00:12:51,934
for a response before continuing messaging.

197
00:12:51,982 --> 00:12:56,454
Queues like this on the slide act

198
00:12:56,492 --> 00:13:00,226
as the middle ground, like mailboxes. So producers,

199
00:13:00,258 --> 00:13:03,490
I mean senders, put messages in the queue,

200
00:13:03,570 --> 00:13:07,590
and consumers, like receivers, retrieve them

201
00:13:07,660 --> 00:13:10,870
when they are ready. So on their own specific

202
00:13:10,940 --> 00:13:14,694
way when they are ready. Right? So this asynchronous

203
00:13:14,742 --> 00:13:17,302
approach ensures smooth communication,

204
00:13:17,366 --> 00:13:20,982
not enforced communication.

205
00:13:21,046 --> 00:13:24,090
So even if the receiver is temporarily unavailable.

206
00:13:24,990 --> 00:13:28,346
Plus, these cues act as buffers,

207
00:13:28,458 --> 00:13:31,626
preventing message loss if the receiver is overloaded,

208
00:13:31,658 --> 00:13:35,266
right? So there are several service that

209
00:13:35,288 --> 00:13:39,294
can be used as message queues. Popular options include Amazon

210
00:13:39,342 --> 00:13:42,574
SQs, I mean simple queue service, and Amazon

211
00:13:42,622 --> 00:13:46,562
MQ, powerful tools for reliable message delivery.

212
00:13:46,706 --> 00:13:50,226
And secondly, publish subscribe messaging.

213
00:13:50,338 --> 00:13:53,814
So published subscribe messaging is unlike point

214
00:13:53,852 --> 00:13:57,550
to point messaging, where messages are targeted to a single consumer. But published

215
00:13:57,570 --> 00:14:01,766
subscribe messaging allows messages to be sent to multiple subscribers,

216
00:14:01,798 --> 00:14:05,878
right? So instead of using queues, this pattern typically employs event routers

217
00:14:05,894 --> 00:14:08,090
such as topics or event buses.

218
00:14:08,750 --> 00:14:12,506
Examples of services supporting this pattern include

219
00:14:12,618 --> 00:14:16,074
SNS, I mean simple notification service. So simple notification

220
00:14:16,122 --> 00:14:20,202
service is used for topics. For the event buses,

221
00:14:20,346 --> 00:14:23,890
the Amazon eventdriven is used so

222
00:14:23,960 --> 00:14:28,210
in details to say, topics function

223
00:14:28,280 --> 00:14:32,142
as simple hubs for distributing message to subscribers.

224
00:14:32,286 --> 00:14:35,810
Event buses can provide more complex routing based on the message

225
00:14:35,880 --> 00:14:39,414
attributes. So here in the slide we see

226
00:14:39,452 --> 00:14:43,010
the blue and green rule with message one and message two accordingly.

227
00:14:43,090 --> 00:14:45,990
So the event bus will check the rules, I mean attributes,

228
00:14:47,470 --> 00:14:51,306
and then send them to the targeted consumers, I mean

229
00:14:51,408 --> 00:14:55,450
subscribers. Now I'll talk about the event

230
00:14:55,520 --> 00:14:59,066
streaming. It involves continuous flows of events or

231
00:14:59,088 --> 00:15:02,778
data providing a way to abstract producers and consumers.

232
00:15:02,874 --> 00:15:06,958
Unlike pubsub messaging, where messages are pushed to customers

233
00:15:07,124 --> 00:15:10,378
in event streaming, consumers usually pull for new events,

234
00:15:10,474 --> 00:15:13,794
so consumers maintain their logic for filtering events and

235
00:15:13,832 --> 00:15:16,770
keep track of their position in the stream.

236
00:15:18,070 --> 00:15:21,666
Event streams can consist of individual events like

237
00:15:21,768 --> 00:15:25,542
location updates in a right share app, or data points collected over time

238
00:15:25,596 --> 00:15:29,398
from iot devices. So data source can be anything like

239
00:15:29,564 --> 00:15:33,240
logs, business metrics, any other AWS services,

240
00:15:34,570 --> 00:15:38,146
and here in the middle point, data streams, actually a subset

241
00:15:38,178 --> 00:15:41,914
of event streams, interpret data over time and are often used

242
00:15:41,952 --> 00:15:45,610
for normally real time data analytics

243
00:15:46,030 --> 00:15:49,450
applications or data persistence use cases.

244
00:15:49,810 --> 00:15:53,818
So there are services supporting event and streaming

245
00:15:53,914 --> 00:15:57,806
performance like Amazon Kinesis data stream and

246
00:15:57,908 --> 00:16:01,610
Amazon MSk. I mean Amazon

247
00:16:01,690 --> 00:16:04,990
managed streaming for Apache Kafka.

248
00:16:05,150 --> 00:16:08,962
This is called the Amazon MSk. Okay,

249
00:16:09,096 --> 00:16:12,158
so this is the choreography

250
00:16:12,174 --> 00:16:14,050
and orchestration. This is the common pattern.

251
00:16:15,350 --> 00:16:18,946
Choreography and orchestrating are the two models for how distributed

252
00:16:18,978 --> 00:16:22,374
system distributed application services communicate with each

253
00:16:22,412 --> 00:16:25,750
other. So in the

254
00:16:25,820 --> 00:16:29,274
choreography pattern, we can

255
00:16:29,312 --> 00:16:32,678
say communication happens without a central controller,

256
00:16:32,774 --> 00:16:36,758
events flow between service and services and eservice reacts

257
00:16:36,774 --> 00:16:41,098
to events independently, not dependable

258
00:16:41,274 --> 00:16:45,754
with others. On the other hand, orchestration involves a central coordinating

259
00:16:45,802 --> 00:16:49,694
service that controls the interaction and

260
00:16:49,732 --> 00:16:54,994
order of service information. So we

261
00:16:55,032 --> 00:16:58,254
can say that while choreography promotes decentralized and flexibility,

262
00:16:58,302 --> 00:17:01,886
orchestration provides centralized control and coordination. So many applications

263
00:17:01,918 --> 00:17:05,150
use a combination of both choreography and orchestration,

264
00:17:05,230 --> 00:17:08,590
selecting the model that best fits

265
00:17:08,670 --> 00:17:12,230
with a specific use case. Actually so there are

266
00:17:12,380 --> 00:17:16,630
different use case vary on different uses pattern.

267
00:17:20,490 --> 00:17:23,190
In this slide I will talk about the bounded context.

268
00:17:23,270 --> 00:17:29,206
Actually. So bounded context is a fundamental concept in the domain

269
00:17:29,238 --> 00:17:33,046
driven design representing a core pattern in its strategies.

270
00:17:33,078 --> 00:17:37,120
Design approach strategic design section is dedicated to

271
00:17:37,570 --> 00:17:40,910
handling complex models and teams efficiently.

272
00:17:42,390 --> 00:17:46,254
In the choreography pattern shines the communication between bounded context.

273
00:17:46,302 --> 00:17:50,420
I mean as the same concept is in the

274
00:17:50,790 --> 00:17:54,286
slide the image, there are two bounded

275
00:17:54,318 --> 00:17:57,670
context, I mean sales context and the support context.

276
00:17:58,090 --> 00:18:02,022
So every

277
00:18:02,076 --> 00:18:05,330
bundle context has the multiple microservice multiple

278
00:18:05,490 --> 00:18:08,840
services. So I mean the

279
00:18:09,770 --> 00:18:13,402
100 context, the one domain and one domain have

280
00:18:13,456 --> 00:18:17,690
the multiple services. So for example, in the ecommerce example,

281
00:18:17,840 --> 00:18:21,834
the order service and the inventory service, the order service focuses on

282
00:18:21,872 --> 00:18:25,054
creating, placing, order emitting and order placed event

283
00:18:25,092 --> 00:18:28,862
with the relevant details. There are many events but one

284
00:18:28,916 --> 00:18:32,058
domain order service. This is the bounded context.

285
00:18:32,154 --> 00:18:35,346
Another bounded context is the inventory service. I mean a

286
00:18:35,368 --> 00:18:39,406
separate boundary context subscribe to the events and manage stock

287
00:18:39,438 --> 00:18:43,026
levels. So importantly, both services can be made out

288
00:18:43,048 --> 00:18:46,126
of others internal topic, but the servicing.

289
00:18:46,158 --> 00:18:49,458
Please send the events and the inventory service reacts

290
00:18:49,474 --> 00:18:52,146
accordingly. This approach fosters loose coupling,

291
00:18:52,178 --> 00:18:55,414
scalability and flexibility as well. So event

292
00:18:55,452 --> 00:18:58,506
buses such as event trees can be used for the

293
00:18:58,528 --> 00:19:01,878
choreography. Okay, and now I'll

294
00:19:01,894 --> 00:19:06,074
talk about the orchestration in details. So, orchestrating is

295
00:19:06,192 --> 00:19:09,958
another key pattern in the event event architectures.

296
00:19:10,134 --> 00:19:14,300
So it's a particularly well suited for scenarios within

297
00:19:15,070 --> 00:19:18,590
bounded contest where you need to control

298
00:19:18,660 --> 00:19:22,966
the order of service calls, manage state, and handle errors or retries

299
00:19:23,018 --> 00:19:26,754
effectively. So to solve this problem here, orchestrating comes

300
00:19:26,792 --> 00:19:30,466
in. So for example, in the slide you

301
00:19:30,488 --> 00:19:33,826
can see the document processing in the insurance claims in

302
00:19:33,848 --> 00:19:38,226
this example. So consider the document processing boundary context with the insurance claims

303
00:19:38,258 --> 00:19:41,746
application. This context receives the document uploaded

304
00:19:41,778 --> 00:19:46,162
event and orchestrator service within the context first classifies

305
00:19:46,226 --> 00:19:50,234
the uploaded document using a document classifier service based

306
00:19:50,272 --> 00:19:53,734
on the classifications, I mean driver license or car image.

307
00:19:53,782 --> 00:19:56,874
So the orchestrator directs the workflows if

308
00:19:56,992 --> 00:20:00,374
it's a driver license, the extract driver license

309
00:20:00,422 --> 00:20:03,918
info, I mean detailed service parts, the information regardless of the

310
00:20:03,924 --> 00:20:07,646
document type, the extracted data is

311
00:20:07,748 --> 00:20:11,418
updated in a database. Finally, the document processing domain image

312
00:20:11,434 --> 00:20:14,670
the document accepted event with all the static details.

313
00:20:14,750 --> 00:20:18,174
So, orchestration provides a central centralized

314
00:20:18,222 --> 00:20:21,458
control mechanism for complex workflows and

315
00:20:21,544 --> 00:20:25,066
it ensures proper service execution, order, state management

316
00:20:25,198 --> 00:20:28,754
and error handling also, so leading to a more reliable

317
00:20:28,802 --> 00:20:32,582
and maintainable applications. So here some

318
00:20:32,636 --> 00:20:36,210
services to execution

319
00:20:36,290 --> 00:20:40,182
to execute these workflows. I mean AWS functions

320
00:20:40,326 --> 00:20:44,198
and Amazon managed

321
00:20:44,214 --> 00:20:48,486
workflows for Apache Kafka. So choreographer

322
00:20:48,518 --> 00:20:52,538
and orchestrating are complementary, I mean not mutually exclusive.

323
00:20:52,634 --> 00:20:55,758
So even many applications benefit from

324
00:20:55,844 --> 00:20:58,714
using both patterns for different scenarios.

325
00:20:58,762 --> 00:21:02,634
There are a few main points when both together come.

326
00:21:02,692 --> 00:21:06,446
I mean producer producer orchestrating consumers consumer

327
00:21:06,478 --> 00:21:10,706
orchestrating. Now here some key

328
00:21:10,728 --> 00:21:14,606
points comes in the producer. In the producer

329
00:21:14,638 --> 00:21:18,514
emits events via event breeze orchestrating

330
00:21:18,562 --> 00:21:22,342
the choreography approach and in the same line,

331
00:21:22,396 --> 00:21:25,942
the producer orchestrating part utilizes step

332
00:21:25,996 --> 00:21:30,010
functions within its bonded context for orchestrating

333
00:21:30,430 --> 00:21:33,610
API calls to Amazon API gateway.

334
00:21:34,110 --> 00:21:37,466
On the receiving end, consumers multiple consumers subscribe to

335
00:21:37,488 --> 00:21:41,054
events via choreography approach. I mean SNS topic app

336
00:21:41,092 --> 00:21:44,858
client, I mean SQS Lambda, Amazon API

337
00:21:44,874 --> 00:21:49,550
Gateway application load balancer and

338
00:21:49,620 --> 00:21:54,366
in the same receiving in one there

339
00:21:54,388 --> 00:21:57,486
is one consumer orchestration, I mean one consumer also leveraging the state

340
00:21:57,508 --> 00:22:00,794
functions for internal orchestrating within its boundary context.

341
00:22:00,842 --> 00:22:04,094
And it comes the

342
00:22:04,132 --> 00:22:07,538
same process. So the previous slides explored

343
00:22:07,554 --> 00:22:11,334
the choreography and organization independently, but however, their true power

344
00:22:11,372 --> 00:22:15,106
lies in their ability to be used together within the same applications.

345
00:22:15,218 --> 00:22:18,966
So as illustrated in the enhanced example, a producer

346
00:22:18,998 --> 00:22:22,646
can emit via event breeze for the choreographing

347
00:22:22,758 --> 00:22:26,010
consumption by various services

348
00:22:26,160 --> 00:22:29,718
simultaneously, the producers can leverage estate

349
00:22:29,734 --> 00:22:33,130
functions within its bounded context to orchestrate ape calls.

350
00:22:33,210 --> 00:22:37,082
So on the receiving end, consumers can subscribe to events choreographically,

351
00:22:37,226 --> 00:22:40,346
while one consumer might also employ functions

352
00:22:40,378 --> 00:22:43,994
for internal orchestration within its own boundary context.

353
00:22:44,122 --> 00:22:47,854
So we have the key integrate that.

354
00:22:47,892 --> 00:22:51,954
I mean, by strategically combining choreography and orchestration, we can

355
00:22:51,992 --> 00:22:54,746
gain a powerful toolkit for building scalable,

356
00:22:54,878 --> 00:22:58,742
loosely coupled and adaptable event, even architectures. So this

357
00:22:58,796 --> 00:23:01,970
approach empowers us to effectively model complex

358
00:23:02,050 --> 00:23:06,470
workflows and the interaction within our applications.

359
00:23:07,470 --> 00:23:10,330
There are few combining patterns.

360
00:23:11,630 --> 00:23:15,274
One of them fan out. I mean, distributing a single event

361
00:23:15,312 --> 00:23:19,018
to multiple subscribers. While individual patterns can address specific needs,

362
00:23:19,104 --> 00:23:22,730
I mean, the true power of event lies

363
00:23:23,250 --> 00:23:27,258
combining them strategically. So fan

364
00:23:27,274 --> 00:23:31,066
out pattern is a fundamental concept and actually it allows

365
00:23:31,098 --> 00:23:34,686
a producer to send a single message to multiple

366
00:23:34,798 --> 00:23:37,090
of subscribed consumers.

367
00:23:38,710 --> 00:23:43,220
This approach is particularly useful when sorry.

368
00:23:47,930 --> 00:23:51,970
So let's say, for example, let's say social media notification

369
00:23:52,050 --> 00:23:55,346
system where a user uses post creation

370
00:23:55,378 --> 00:23:59,338
triggers fan out events. This event might be

371
00:23:59,424 --> 00:24:02,982
of interest to various consumers,

372
00:24:03,126 --> 00:24:06,582
such as a service for generating activity feeds,

373
00:24:06,646 --> 00:24:10,726
another service for sending push notifications to followers,

374
00:24:10,918 --> 00:24:14,602
and a service for timeline updates. So the fan of pattern ensures

375
00:24:14,666 --> 00:24:18,746
all this communication. All these consumers receive

376
00:24:18,778 --> 00:24:22,670
the same event, enabling them to perform their tasks efficiently.

377
00:24:24,310 --> 00:24:28,142
Now I'll talk about the event filtering and routing. So it directs

378
00:24:28,286 --> 00:24:32,046
event to specific targets based on the predefined

379
00:24:32,078 --> 00:24:35,906
criteria. It inputs message relevancy for consumers

380
00:24:35,938 --> 00:24:39,526
and reduces unnecessary processing. I mean, event filtering and

381
00:24:39,548 --> 00:24:42,870
routing is a cornerstone of the flexible and

382
00:24:42,940 --> 00:24:46,534
targeted communication in the event even architecture. It enables us

383
00:24:46,572 --> 00:24:50,540
to define criteria that determine which events get delivered to specific

384
00:24:51,070 --> 00:24:54,998
consumers. This ensures that consumers only receive relevant

385
00:24:55,014 --> 00:24:59,414
to their dominant functionality to escape

386
00:24:59,542 --> 00:25:03,214
to remove the unnecessary to remove the getting

387
00:25:03,252 --> 00:25:07,114
the unnecessary messages. So Eventdriven can filter

388
00:25:07,162 --> 00:25:10,266
and route events based on predefined

389
00:25:10,298 --> 00:25:14,686
criteria. In shading, only ten events reach specific consumers.

390
00:25:14,878 --> 00:25:18,846
And now I'll talk about the event and message buffering.

391
00:25:18,958 --> 00:25:22,050
So it utilizes queues as a buffer to manage the message

392
00:25:22,200 --> 00:25:26,422
volume for downstream consumers. It ensures messages are

393
00:25:26,476 --> 00:25:30,146
delivered reliably, even if consumers are temporarily unavailable

394
00:25:30,178 --> 00:25:34,050
or overload. So here the event and message buffering

395
00:25:34,210 --> 00:25:37,406
pattern comes in. It promotes asynchronous

396
00:25:37,458 --> 00:25:40,730
communication and improves overall system resiliency.

397
00:25:42,270 --> 00:25:46,106
So now I'll talk about the workflow orchestrating and it is

398
00:25:46,128 --> 00:25:49,770
the more important on this session.

399
00:25:50,450 --> 00:25:53,786
This slide demonstrates how step functions

400
00:25:53,818 --> 00:25:56,986
can be used to model a KYC workflow,

401
00:25:57,098 --> 00:26:01,098
promoting an event driven approach with loose coupling and low code integration

402
00:26:01,194 --> 00:26:05,586
via event in

403
00:26:05,608 --> 00:26:10,962
the step number one, so we can say new

404
00:26:11,096 --> 00:26:14,226
account request event, right? So the process begins with the

405
00:26:14,248 --> 00:26:17,654
account system publishing and event signing a new

406
00:26:17,692 --> 00:26:21,826
account request. This event triggers the KYC workflows execution within a dedicated KYC

407
00:26:21,938 --> 00:26:24,866
service and the second step QIC verification.

408
00:26:25,058 --> 00:26:28,314
So this might involve tasks like

409
00:26:28,432 --> 00:26:30,970
identity verification and risk profile assessment.

410
00:26:31,470 --> 00:26:36,314
And then step three, identity check completion and

411
00:26:36,432 --> 00:26:39,738
step four, conditional events based on the risk assessment. I mean

412
00:26:39,824 --> 00:26:43,198
after risk profile assessment, the workflow publishes one of

413
00:26:43,204 --> 00:26:46,110
the two events depending on the outcome,

414
00:26:46,770 --> 00:26:51,918
I mean whether account approved or account and

415
00:26:52,004 --> 00:26:56,242
step five, given consumption by downstream services like both account

416
00:26:56,376 --> 00:27:00,034
and consumer service domain. There are two domains actually.

417
00:27:00,152 --> 00:27:03,762
So I have defined roles on the event prepas to process

418
00:27:03,816 --> 00:27:07,186
this KYC workflow, KYC outcome events. I mean,

419
00:27:07,288 --> 00:27:10,870
the account domain likely handles the account

420
00:27:10,940 --> 00:27:14,642
creation or further processing based on the account approved

421
00:27:14,706 --> 00:27:19,210
event, and the customer service domain might be notified for

422
00:27:19,360 --> 00:27:23,500
potential outage to the customer based on the account rejected event.

423
00:27:25,310 --> 00:27:28,586
From this example we have the summary. We have the

424
00:27:28,608 --> 00:27:32,506
benefits of this functional workflows in the event even architecture.

425
00:27:32,618 --> 00:27:36,378
So this approach promotes loose coupling as services don't

426
00:27:36,394 --> 00:27:40,682
rely on direct communication, they simply publish

427
00:27:40,746 --> 00:27:44,530
or subscribe to relevant events on the event principles. And another

428
00:27:44,600 --> 00:27:48,526
thing we can see in this example, the modular workflow

429
00:27:48,558 --> 00:27:51,854
is the function orchestrating the KYC process in a defined sequence,

430
00:27:51,902 --> 00:27:54,782
ensuring a clear and maintainable workflows,

431
00:27:54,926 --> 00:27:57,998
and also low code integration. Utilizing eventdriven

432
00:27:58,014 --> 00:28:01,778
simplifies integration between the KYC service and other domains requiring

433
00:28:01,874 --> 00:28:05,414
minimal custom code. So this is the

434
00:28:05,452 --> 00:28:09,174
low code integration actually. And by leveraging step functional eventdriven.

435
00:28:09,302 --> 00:28:13,126
So here we can see the financial institutions

436
00:28:13,158 --> 00:28:16,790
can establish the robust and scalable device workflow and ensuring

437
00:28:16,870 --> 00:28:20,250
regulatory compliance and efficient customer onboarding.

438
00:28:22,270 --> 00:28:25,446
So far we have explored the various aspects of event driven

439
00:28:25,478 --> 00:28:29,002
architectures. Now let's introduce AWS state functions.

440
00:28:29,146 --> 00:28:32,826
Actually, it's a serverless orchestrating service that can seamlessly integrate

441
00:28:32,858 --> 00:28:36,994
with eventdriven architecture. So there are some key

442
00:28:37,032 --> 00:28:40,590
components for step functions, workflow.

443
00:28:40,750 --> 00:28:44,190
I mean state machine steps and task steps.

444
00:28:44,270 --> 00:28:47,910
So state machine represent your

445
00:28:48,060 --> 00:28:51,826
entire workflow. There are few types

446
00:28:51,858 --> 00:28:55,286
of state machines, I mean twice state,

447
00:28:55,388 --> 00:28:59,098
parallel state and so on, especially a series of event

448
00:28:59,184 --> 00:29:03,914
driven steps. Here comes in another

449
00:29:04,032 --> 00:29:07,738
component is step within the workflow is

450
00:29:07,744 --> 00:29:11,638
called a step. Another component is task step. This step

451
00:29:11,664 --> 00:29:14,750
represent units of work executed by other AWS services,

452
00:29:14,820 --> 00:29:18,346
such as invoking the lambda and task that can interact

453
00:29:18,378 --> 00:29:21,834
with any other AWS service like SQs,

454
00:29:21,882 --> 00:29:24,558
SNS, SES, API,

455
00:29:24,574 --> 00:29:27,618
gateway and anything else.

456
00:29:27,784 --> 00:29:31,554
So the core benefit of the step function is the visual workflows design.

457
00:29:31,752 --> 00:29:35,382
And the graphical console provides a more

458
00:29:35,436 --> 00:29:39,334
clear view of the applications workflow, making it more

459
00:29:39,372 --> 00:29:42,806
easier, making it easier to understand and

460
00:29:42,988 --> 00:29:45,560
manage complex event event process.

461
00:29:46,570 --> 00:29:50,570
So use cases for the state functions could be maybe

462
00:29:50,640 --> 00:29:54,474
machine machine learning model of flow ETL workflows, long running

463
00:29:54,592 --> 00:29:58,682
workflows and so on. So state functions provide

464
00:29:58,736 --> 00:30:01,998
two main ways to interact with other services within

465
00:30:02,084 --> 00:30:05,514
our workflows. I mean SDK integration

466
00:30:05,562 --> 00:30:09,086
and optimized integration. And there are two

467
00:30:09,108 --> 00:30:12,618
types of workflows in the functions, I mean

468
00:30:12,724 --> 00:30:16,398
standard and express. So standard execution

469
00:30:16,574 --> 00:30:20,194
execution is the time to up to one year

470
00:30:20,312 --> 00:30:24,926
and exactly once workflows execution for this type

471
00:30:25,048 --> 00:30:28,146
and the pricing is also part transition.

472
00:30:28,338 --> 00:30:32,200
And to say use cases for this

473
00:30:32,570 --> 00:30:36,834
standard is ideal for long running auditable

474
00:30:36,882 --> 00:30:40,854
workflows where execution history and visual

475
00:30:40,902 --> 00:30:44,838
debugging are crucial. Express workflows

476
00:30:45,014 --> 00:30:48,506
at least once workflow execution and

477
00:30:48,528 --> 00:30:51,934
the execution time is up to five minutes. And to

478
00:30:51,972 --> 00:30:55,920
say pricing the part number and duration of execution and

479
00:30:56,370 --> 00:30:59,918
use cases of this exprs workflows is the

480
00:30:59,924 --> 00:31:03,774
perfect for high event rate workflows such as streaming

481
00:31:03,822 --> 00:31:07,010
data processing and iot data ingestion, et cetera.

482
00:31:07,590 --> 00:31:11,762
So to choose the right workflow type between

483
00:31:11,816 --> 00:31:16,114
the standard and express workflows, actually it depends on

484
00:31:16,312 --> 00:31:19,606
the specific needs. So eastern workflows are ideal for

485
00:31:19,628 --> 00:31:23,234
scenarios requiring strict execution

486
00:31:23,282 --> 00:31:26,680
order auditability and long running process. On the other hand,

487
00:31:28,190 --> 00:31:32,298
express workflows except in the hydro throughput scenarios where

488
00:31:32,384 --> 00:31:35,542
rapid event processing, event processing,

489
00:31:35,606 --> 00:31:40,220
streaming data processing, IIT data injection is essential here.

490
00:31:40,750 --> 00:31:44,862
All right, so let's dive into some practical applications for

491
00:31:44,996 --> 00:31:47,674
the step functions.

492
00:31:47,802 --> 00:31:51,690
So first of all, function orchestration.

493
00:31:51,850 --> 00:31:55,394
So imagine a complex of flow like processing a customer order

494
00:31:55,592 --> 00:31:58,994
step function access at orchestrating these

495
00:31:59,032 --> 00:32:02,626
tasks. So you can define a sequence of lambda functions where each

496
00:32:02,648 --> 00:32:07,774
function performs a specific steps. So I mean calculate

497
00:32:07,822 --> 00:32:11,346
total update, inventory, trigger shipment, et cetera. Systems visuals,

498
00:32:11,378 --> 00:32:14,502
these interactions ensuring everything happens in the correct

499
00:32:14,556 --> 00:32:18,262
order, and you can easily verify the flow and

500
00:32:18,316 --> 00:32:22,006
on the branching with choice state. So state functions

501
00:32:22,118 --> 00:32:25,210
allows you to incorporate decision making into your workflows. For instance,

502
00:32:25,550 --> 00:32:29,174
in a credit card application process, a choice state can evaluate the request

503
00:32:29,222 --> 00:32:32,186
credit limit. If it's below a threshold,

504
00:32:32,298 --> 00:32:35,722
the application can be automatically approved.

505
00:32:35,866 --> 00:32:39,294
However, exiting the threshold can route the application for manual review

506
00:32:39,332 --> 00:32:43,700
by a manager. So here's the branching example

507
00:32:44,790 --> 00:32:49,410
and for the error handling. So state functions offers mechanism

508
00:32:50,630 --> 00:32:53,986
to handle errors smoothly. I mean for

509
00:32:54,008 --> 00:32:58,050
example a customer registration where the chosen username is unavailable,

510
00:32:58,130 --> 00:33:02,322
a retry state could automatically attempt registration

511
00:33:02,386 --> 00:33:05,766
with a slightly modified username a couple of times.

512
00:33:05,868 --> 00:33:09,670
Alternatively, a cat state could intercept

513
00:33:09,750 --> 00:33:13,820
the error and suggest alternative usernames for the customer to choose from.

514
00:33:15,870 --> 00:33:19,434
In the human integration can even integrate human

515
00:33:19,472 --> 00:33:23,258
integration. Suppose you have a process requiring

516
00:33:23,354 --> 00:33:27,198
manager approval. So here functions can

517
00:33:27,364 --> 00:33:30,814
utilize callbacks and task tokens to send

518
00:33:30,852 --> 00:33:34,434
the task to lambda function that might notify the manager and

519
00:33:34,472 --> 00:33:38,142
wait for the addition before continue the workflow.

520
00:33:38,206 --> 00:33:41,454
So this is useful for scenarios when human intervention is necessary.

521
00:33:41,582 --> 00:33:45,454
So there are other use cases. Parallel processing dynamic parallel parallelism

522
00:33:45,502 --> 00:33:49,494
with map step parallel in the parallel processing the

523
00:33:49,532 --> 00:33:52,934
imaging converting a video file into different resolution for

524
00:33:53,052 --> 00:33:56,994
various devices. The parallel listed allows you to distribute this workflows

525
00:33:57,122 --> 00:33:59,926
amongst multiple lambda functions simultaneously.

526
00:34:00,038 --> 00:34:04,022
Significantly, it is speeding up the transcoding process compared

527
00:34:04,086 --> 00:34:07,898
to doing it one resolution at a time and

528
00:34:08,064 --> 00:34:11,402
dynamic realism. It works

529
00:34:11,456 --> 00:34:14,958
with Mapistet. Mappyset empowers us to

530
00:34:15,044 --> 00:34:18,426
process collections of items in the parallel using lambda

531
00:34:18,458 --> 00:34:22,454
functions. A good example is an order fulfillment scenario,

532
00:34:22,602 --> 00:34:26,558
so where you might have multiple items that need to be prepared

533
00:34:26,574 --> 00:34:30,414
for shipping. I mean the map state can trigger lambda

534
00:34:30,462 --> 00:34:34,110
functions to process each item

535
00:34:34,190 --> 00:34:38,246
concurrently. I mean checking availability, gathering the item, packaging it for

536
00:34:38,268 --> 00:34:41,782
shipment, et cetera. So now let's see the demo

537
00:34:41,836 --> 00:34:45,270
on error handling of course, and then I'll get to the slide.

538
00:34:47,450 --> 00:34:51,394
So error handling custom error functions as the throw

539
00:34:51,442 --> 00:34:55,690
new error this is a custom error state we have completed

540
00:34:56,190 --> 00:34:59,510
in the state functions we have two state machines,

541
00:34:59,590 --> 00:35:03,006
I mean error handling state machine with

542
00:35:03,028 --> 00:35:07,134
retry in the resource sections the

543
00:35:07,172 --> 00:35:11,630
copy I have to copy the ARN and paste.

544
00:35:12,470 --> 00:35:16,674
If the ARN is mismatched, the error comes in the

545
00:35:16,712 --> 00:35:20,274
error handling parameters. We can check the

546
00:35:20,392 --> 00:35:24,306
execution input and output and

547
00:35:24,328 --> 00:35:27,690
the state functions workflow. So this is a custom error.

548
00:35:27,790 --> 00:35:31,062
And here the output comes

549
00:35:31,116 --> 00:35:35,862
from the lambda functions and start

550
00:35:35,916 --> 00:35:39,318
execution. So to view the customer message the

551
00:35:39,484 --> 00:35:43,002
start execution in the graph inspector panel and review

552
00:35:43,056 --> 00:35:44,090
the input tape.

553
00:35:47,310 --> 00:35:51,130
So now handle the failure using catch.

554
00:35:51,550 --> 00:35:54,830
So your task, map and parallel strategies may contain a field

555
00:35:54,900 --> 00:35:58,990
name catch start execution task and error.

556
00:35:59,490 --> 00:36:03,746
So copy and paste the lambda ern of

557
00:36:03,768 --> 00:36:07,090
the error handling state machine with catch lambda.

558
00:36:07,510 --> 00:36:10,866
Now custom error and next workflows step in the

559
00:36:10,888 --> 00:36:15,554
custom error fallback. So when

560
00:36:15,592 --> 00:36:18,974
it catches this error it passes flow control to the fallback

561
00:36:19,022 --> 00:36:24,022
step. Custom error fallback so select

562
00:36:24,076 --> 00:36:28,342
the custom error fallback stating the graph inspector pan and building the

563
00:36:28,476 --> 00:36:30,470
input and output.

564
00:36:31,050 --> 00:36:35,386
So custom error fallback message

565
00:36:35,488 --> 00:36:38,970
this is a fallback from a custom lambda function exception.

566
00:36:39,710 --> 00:36:43,422
So this workflow exactly

567
00:36:43,556 --> 00:36:46,830
as expected. I mean it should

568
00:36:46,900 --> 00:36:50,062
show this is a fallback from a custom lambda function

569
00:36:50,116 --> 00:36:53,386
exception. And it does use the catch

570
00:36:53,418 --> 00:36:56,794
a timer error and error held

571
00:36:56,922 --> 00:37:00,594
ten function lambda to copy rn of this

572
00:37:00,632 --> 00:37:03,986
lambda. Put the ErN in the

573
00:37:04,168 --> 00:37:08,002
state machine where I want to execute the error.

574
00:37:08,146 --> 00:37:12,034
I mean sleep set timeout function error

575
00:37:12,082 --> 00:37:15,782
equals estate timeout and next timeout fallback next

576
00:37:15,836 --> 00:37:18,360
event Timeout fallback so let's see what happened.

577
00:37:18,910 --> 00:37:22,154
Click Save and execute. Accept the default input and

578
00:37:22,192 --> 00:37:25,418
click start execution. To view the

579
00:37:25,424 --> 00:37:29,206
input of the fallback state, select timeout fallback

580
00:37:29,238 --> 00:37:32,860
state Timeout Faultback Step time out Faultback Step

581
00:37:33,310 --> 00:37:37,230
input output this is fallback format timeout error.

582
00:37:37,650 --> 00:37:48,230
It works perfectly as respectively.

583
00:37:50,110 --> 00:37:53,580
Okay, and after finishing this demo,

584
00:37:54,270 --> 00:37:58,334
I'm deleting this spec. All right, let's talk

585
00:37:58,372 --> 00:38:02,282
about the best practices and while considering

586
00:38:02,346 --> 00:38:06,970
building EDA applications. So firstly, event storming. It's a collaborative

587
00:38:07,050 --> 00:38:10,366
technique that helps us visually map out a

588
00:38:10,388 --> 00:38:14,086
system behavior and identify those critical

589
00:38:14,138 --> 00:38:17,250
events in the event, even architectures. The idea is to bring together

590
00:38:17,320 --> 00:38:21,198
stakeholders from different areas of the system. We then facilitate

591
00:38:21,214 --> 00:38:25,042
a workshop where we can all together to visualize

592
00:38:25,106 --> 00:38:28,470
and discuss the systems, events and actions.

593
00:38:29,210 --> 00:38:32,710
The main goal here is to get everyone on the same page,

594
00:38:32,860 --> 00:38:35,926
everyone under the same umbrella,

595
00:38:36,038 --> 00:38:40,170
about how the system works and pinpoint those critical business events.

596
00:38:40,670 --> 00:38:44,042
ECST events I mean ECST event

597
00:38:44,176 --> 00:38:47,530
carried state transfer events, notification events

598
00:38:49,650 --> 00:38:54,000
like concise messaging informing consumers that something

599
00:38:54,610 --> 00:38:57,710
ECST events like a different approach.

600
00:38:58,370 --> 00:39:01,010
They act more like data carriers,

601
00:39:01,350 --> 00:39:04,590
more data carriers containing a richer payload,

602
00:39:04,670 --> 00:39:07,662
with more information relevant to downstream consumers.

603
00:39:07,806 --> 00:39:11,474
So imagine a user placing an order in

604
00:39:11,512 --> 00:39:14,982
an event, even architecture we can create an order placed event

605
00:39:15,036 --> 00:39:18,754
to notify downstream systems like inventory management or payment processing

606
00:39:18,802 --> 00:39:23,010
that a new order exists. So notification events essentially

607
00:39:23,090 --> 00:39:24,470
act a messenger,

608
00:39:26,670 --> 00:39:30,234
informing interesting consumers that something has happened.

609
00:39:30,352 --> 00:39:34,410
But on the contrary, Es ECST events

610
00:39:36,030 --> 00:39:39,646
have the more information, more metadata in

611
00:39:39,668 --> 00:39:43,054
the full details data. And another best

612
00:39:43,092 --> 00:39:46,574
practice is the confirmation pattern, is the straightforward approach for

613
00:39:46,772 --> 00:39:50,078
consuming events in the event. Even architectures in this pattern,

614
00:39:50,094 --> 00:39:53,886
downstream consumers directly utilize the events published

615
00:39:53,918 --> 00:39:55,490
by producers,

616
00:39:57,830 --> 00:40:01,890
senders without any modifications or transformations.

617
00:40:02,390 --> 00:40:06,194
And another point, Sel, I mean protecting

618
00:40:06,242 --> 00:40:10,418
domain boundaries, let's say two bounded contexts with distinct

619
00:40:10,434 --> 00:40:14,466
data models, business logic, and potentially even language. And SEl

620
00:40:14,498 --> 00:40:18,122
acts as a mediator between these contexts. So it provides a

621
00:40:18,256 --> 00:40:22,170
translation layer that safeguards data from one domain

622
00:40:22,510 --> 00:40:25,754
from corruption or misuse when consumed by

623
00:40:25,872 --> 00:40:30,090
another domain and another. Best practice is the OHS,

624
00:40:30,170 --> 00:40:32,510
I mean shared language for communication.

625
00:40:34,850 --> 00:40:37,870
OSA is open host services patterns.

626
00:40:38,370 --> 00:40:43,106
It promotes communication between bounded contests by

627
00:40:43,208 --> 00:40:47,294
establishing a shared public language. I mean, this language acts as a common ground

628
00:40:47,342 --> 00:40:50,450
for the data exchange, defined pro,

629
00:40:50,520 --> 00:40:54,678
accurate upon interfaces, contracts or schema or

630
00:40:54,764 --> 00:40:58,594
anything like this. And another perspective

631
00:40:58,642 --> 00:41:00,680
is the event fast thinking. Remember,

632
00:41:01,850 --> 00:41:04,954
event identification, event identification and

633
00:41:04,992 --> 00:41:08,246
design are the ongoing process, right? So regularly

634
00:41:08,278 --> 00:41:12,790
revisiting your events, ensuring that for ensuring

635
00:41:12,950 --> 00:41:16,986
they remain relevant to involve business events and business as well as

636
00:41:17,008 --> 00:41:20,906
business needs final best practice

637
00:41:20,938 --> 00:41:23,994
of the ordering and order and unordered events.

638
00:41:24,122 --> 00:41:27,950
Not all events need to arrive in the specific sequence, but however

639
00:41:28,020 --> 00:41:31,474
some scenarios require a guaranteed order for

640
00:41:31,512 --> 00:41:34,894
events to be processed correctly and understanding

641
00:41:34,942 --> 00:41:38,270
this distinction is vital for designing your ETF effectively

642
00:41:38,430 --> 00:41:41,854
and for example a scenario where an order updated

643
00:41:41,902 --> 00:41:45,346
event must be processed only after the corresponding order created

644
00:41:45,378 --> 00:41:48,406
event arrives. So to achieve this

645
00:41:48,428 --> 00:41:52,006
you can leverage service that guarantee event order. Here are a couple

646
00:41:52,028 --> 00:41:55,574
of options on AWS I mean Kinesis data stream order

647
00:41:55,612 --> 00:41:59,874
is preserved within the message in a shard and Amazon

648
00:41:59,922 --> 00:42:03,826
SQs FIFO I mean first in first out. So events are delivered

649
00:42:03,858 --> 00:42:07,806
within a message group ID in the order and

650
00:42:07,988 --> 00:42:11,662
here are some helpful resources to keep your planning journey on event event

651
00:42:11,716 --> 00:42:15,434
architectures going. I hope you found it informative

652
00:42:15,562 --> 00:42:18,686
and feel free to reach out if you have any

653
00:42:18,708 --> 00:42:21,500
questions. So yeah, have a good day.

