1
00:00:24,650 --> 00:00:28,646
Thank you you to conference 42 for inviting us along today

2
00:00:28,828 --> 00:00:32,466
for our session. Monolith to microservices accelerate

3
00:00:32,498 --> 00:00:36,342
your modernization with AWS app to container and Amazon Q

4
00:00:36,476 --> 00:00:39,926
my name is Richard Lees and I lead our application modernization go to

5
00:00:39,948 --> 00:00:43,286
market strategy in Emir and I'm delighted to be here today.

6
00:00:43,388 --> 00:00:46,210
I'm also joined by my colleague Jorge Alvarez.

7
00:00:46,290 --> 00:00:48,440
Jorge, would you like to introduce yourself please?

8
00:00:49,530 --> 00:00:53,520
Yes, thanks so much Richard. I am delighted to be here today

9
00:00:53,890 --> 00:00:57,866
and my name is Jorge Alvarez. I am a senior solution architect specialist

10
00:00:57,898 --> 00:01:01,802
in migration and modernization. Yeah, Richard,

11
00:01:01,866 --> 00:01:05,586
go ahead. Thanks Jorge. So our

12
00:01:05,608 --> 00:01:08,962
agenda for today. So firstly, I'm going to quickly touch on

13
00:01:09,016 --> 00:01:12,530
why customers modernize and why do they modernize on AWS.

14
00:01:13,270 --> 00:01:16,566
We'll then talk about monoliths and microservices and the

15
00:01:16,588 --> 00:01:20,386
benefits and concerns of both. And then I'll

16
00:01:20,418 --> 00:01:24,338
pass over to Jorge and we'll dive into Dave's scenario. And that's

17
00:01:24,354 --> 00:01:27,786
split into two parts. The first is around accelerating your

18
00:01:27,808 --> 00:01:31,398
modernization journey with AWS apt to container.

19
00:01:31,574 --> 00:01:35,862
And then the second eagerly anticipated part is refactoring

20
00:01:35,926 --> 00:01:39,834
using Gen AI with Amazon Q so

21
00:01:39,872 --> 00:01:43,614
Genai, the buzzwords on everyone's lips at the moment. And I know we're all super

22
00:01:43,652 --> 00:01:47,246
keen to understand how we can use Genai to accelerate our

23
00:01:47,268 --> 00:01:50,926
application modernization efforts. And then finally

24
00:01:51,028 --> 00:01:54,880
at the end, we'll wrap up with some next steps and provide you

25
00:01:55,810 --> 00:01:59,330
with some follow ups, places you can go to kind of learn more

26
00:01:59,400 --> 00:02:02,100
about the topics we've touched on and discussed today.

27
00:02:04,630 --> 00:02:07,940
So why do customers modernize? So,

28
00:02:08,710 --> 00:02:11,894
across the customers we work with in Amir, we find

29
00:02:11,932 --> 00:02:15,222
that customers typically modernize their applications for three

30
00:02:15,276 --> 00:02:18,486
reasons. The first is speed and agility.

31
00:02:18,598 --> 00:02:21,834
So speed matters in business, and in

32
00:02:21,872 --> 00:02:25,258
the majority of cases I get involved in customers

33
00:02:25,344 --> 00:02:29,034
are focused on modernizing their strategically important

34
00:02:29,152 --> 00:02:32,814
apps to improve their customer experience and get

35
00:02:32,852 --> 00:02:36,734
to market faster. The second is security and

36
00:02:36,772 --> 00:02:38,510
operational resilience.

37
00:02:39,090 --> 00:02:42,926
Customers are particularly keen to embrace AWS

38
00:02:42,958 --> 00:02:46,302
managed services, improve their risk posture

39
00:02:46,366 --> 00:02:50,222
as a result, and ensure they are building and deploying

40
00:02:50,286 --> 00:02:53,522
secure and resilient applications from the get

41
00:02:53,576 --> 00:02:56,998
go AWS standard. And then finally,

42
00:02:57,164 --> 00:03:00,902
cost and modern applications typically are more

43
00:03:00,956 --> 00:03:04,470
elastic and actually take advantage the full benefits

44
00:03:04,540 --> 00:03:08,082
of the take advantage of the full benefits of cloud and can scale

45
00:03:08,146 --> 00:03:11,914
up and down, therefore providing a more optimal cost base for your

46
00:03:11,952 --> 00:03:15,594
applications. And when customers have got really clear

47
00:03:15,712 --> 00:03:18,954
about why they want to modernize, they typically then

48
00:03:18,992 --> 00:03:23,002
think about how they can scale their modernization across their organization.

49
00:03:23,146 --> 00:03:27,374
And that's when we find customers leaning into the

50
00:03:27,412 --> 00:03:31,390
modernization pathways that we've developed here at AWS

51
00:03:31,730 --> 00:03:35,474
so the modernization pathways are designed to

52
00:03:35,672 --> 00:03:39,054
give organizations a set of guardrails,

53
00:03:39,102 --> 00:03:43,246
patterns and tools that they can use to go and scale modernization

54
00:03:43,358 --> 00:03:47,190
across their organization. Now, we typically see

55
00:03:47,340 --> 00:03:50,646
customers lean into four modernization pathways in particular.

56
00:03:50,748 --> 00:03:54,230
Time and time again. Those are move to cloud native,

57
00:03:54,570 --> 00:03:58,374
move to managed, move to managed data, and move

58
00:03:58,412 --> 00:04:01,674
to open source. So what are those? So move

59
00:04:01,712 --> 00:04:05,066
to cloud native. This requires the

60
00:04:05,088 --> 00:04:08,074
highest level of time investment from you as a customer,

61
00:04:08,272 --> 00:04:12,218
and often the highest level of investment to achieve. And it's

62
00:04:12,234 --> 00:04:16,074
typically reserved for apps that are linked to large business goals

63
00:04:16,122 --> 00:04:20,510
or challenges you're looking to overcome as an organization, and will involve

64
00:04:20,850 --> 00:04:24,402
refactoring a significant amount of code to take

65
00:04:24,456 --> 00:04:27,620
the most advantage of AWS native products and services.

66
00:04:29,350 --> 00:04:32,562
Move to managed so many

67
00:04:32,616 --> 00:04:35,654
customers in their modernization journey will stop that move

68
00:04:35,692 --> 00:04:39,266
to manage the large proportion of their it estate.

69
00:04:39,458 --> 00:04:43,458
Move to appcontainer in particular is a very popular modernization

70
00:04:43,554 --> 00:04:46,818
pathway, and AWS offers the most secure,

71
00:04:46,914 --> 00:04:49,782
reliable and scalable containers environments.

72
00:04:49,926 --> 00:04:53,754
With nearly 80% of appcontainer in the cloud today running on

73
00:04:53,792 --> 00:04:58,010
AWS, we then have move to manage databases.

74
00:04:59,470 --> 00:05:03,034
So on AWS, we have eleven plus fully managed

75
00:05:03,082 --> 00:05:06,494
purpose built databases, including Amazon, RDS and

76
00:05:06,532 --> 00:05:09,902
DynamoDB, which means customers can choose

77
00:05:09,956 --> 00:05:13,042
the best database for the job and then

78
00:05:13,096 --> 00:05:17,214
finally move to open source. So a particularly

79
00:05:17,262 --> 00:05:20,446
common modernization pathway tying

80
00:05:20,478 --> 00:05:24,382
into the overall trend of customers looking to adopt open source

81
00:05:24,526 --> 00:05:28,678
technologies, be that modernizing from

82
00:05:28,844 --> 00:05:32,630
net frameworks, net core and from Windows to Linux. Okay,

83
00:05:32,700 --> 00:05:35,938
and today we will be focusing on two modernization

84
00:05:36,034 --> 00:05:39,354
pathways. So as part of this

85
00:05:39,392 --> 00:05:42,614
exercise, we will be moving to a cloud native

86
00:05:42,662 --> 00:05:46,090
architecture and we'll be leveraging containers,

87
00:05:46,590 --> 00:05:48,650
monoliths and microservices.

88
00:05:53,410 --> 00:05:57,242
So the monolith so a quick recap of what a monolith

89
00:05:57,306 --> 00:06:00,782
is. So a monolithic application can be thought

90
00:06:00,836 --> 00:06:04,674
of as a single block whereby all components and

91
00:06:04,712 --> 00:06:08,146
functionality are inside that single block, inside a

92
00:06:08,168 --> 00:06:11,806
single code base. Those components are typically

93
00:06:11,918 --> 00:06:15,714
coupled together and reliant upon one another, and changing

94
00:06:15,762 --> 00:06:18,120
one typically has an impact on another.

95
00:06:18,970 --> 00:06:22,886
Finally, this is the traditional way that applications were built

96
00:06:22,988 --> 00:06:26,806
and written, and the monolith has

97
00:06:26,828 --> 00:06:30,774
its advantages. So monolithic

98
00:06:30,822 --> 00:06:34,250
approaches to application developments are well understood by developers,

99
00:06:34,590 --> 00:06:37,980
and often when customers are starting to develop a new application,

100
00:06:38,590 --> 00:06:42,014
it's often just simpler and faster to get started with

101
00:06:42,052 --> 00:06:46,110
a monolithic architecture whilst you're testing new ideas

102
00:06:46,450 --> 00:06:50,542
and seeking product market fit. The second

103
00:06:50,596 --> 00:06:53,730
advantage is that you have a single executable code base,

104
00:06:53,800 --> 00:06:58,158
and that generally makes the deployment process quite straightforward,

105
00:06:58,254 --> 00:07:01,620
especially if you only have a small engineering team focused on it.

106
00:07:01,990 --> 00:07:05,334
And then finally testing is easier, so all

107
00:07:05,372 --> 00:07:08,790
functionality is coupled together in a centralized unit,

108
00:07:09,610 --> 00:07:13,014
and testing is typically faster than it would be in

109
00:07:13,052 --> 00:07:15,270
a distributed application architecture.

110
00:07:16,570 --> 00:07:20,106
But despite all of the benefits and the quick start that can

111
00:07:20,128 --> 00:07:23,530
come from monolith, the monolith has its limitations.

112
00:07:23,950 --> 00:07:27,402
And when we start to think about your strategically important business

113
00:07:27,456 --> 00:07:31,246
applications that change frequently and differentiate you in the

114
00:07:31,268 --> 00:07:35,114
market, and you're

115
00:07:35,162 --> 00:07:38,766
growing those applications and you're growing the team supporting them,

116
00:07:38,948 --> 00:07:42,974
the monolith presents some inherent challenges that become more prevalent

117
00:07:43,022 --> 00:07:46,846
as you scale. So firstly, those components

118
00:07:46,878 --> 00:07:50,942
that are tightly coupled together are often interconnected

119
00:07:51,006 --> 00:07:54,718
and reliant on one another inside the code base. So lots

120
00:07:54,734 --> 00:07:58,546
of hard dependencies. As a result, when you're

121
00:07:58,578 --> 00:08:01,826
updating a small piece of the monolithic architecture,

122
00:08:01,938 --> 00:08:06,162
often the entire application has to be tested and redeployed,

123
00:08:06,306 --> 00:08:10,034
and this can often result in a high level of change effort.

124
00:08:10,162 --> 00:08:13,526
And for what could be a relatively straightforward

125
00:08:13,718 --> 00:08:15,370
small functional update,

126
00:08:17,310 --> 00:08:20,640
redeploying the entire app each time,

127
00:08:22,690 --> 00:08:26,158
each time you go through a development lifecycle can also

128
00:08:26,244 --> 00:08:29,994
slow you down and start to reduce your release

129
00:08:30,042 --> 00:08:34,578
frequency cycle and really make it difficult to ship changes

130
00:08:34,744 --> 00:08:38,834
to market faster reliability can

131
00:08:38,872 --> 00:08:42,622
also become a concern. So a bargain. A particular module

132
00:08:42,686 --> 00:08:46,450
of the application, a memory leak, for example, can potentially

133
00:08:46,530 --> 00:08:48,360
bring down the entire application.

134
00:08:50,170 --> 00:08:55,094
Scalability can

135
00:08:55,132 --> 00:08:58,266
inherent limitation of monolith is the fact that

136
00:08:58,368 --> 00:09:02,170
individual components cannot scale independently,

137
00:09:02,670 --> 00:09:05,914
thus inhibiting many of the kind of

138
00:09:05,952 --> 00:09:09,610
innate elastic benefits of running workloads on AWS.

139
00:09:09,970 --> 00:09:13,886
And then finally, often adopting new technologies can

140
00:09:13,908 --> 00:09:17,694
be difficult in a more distributed architecture. There's no reason that

141
00:09:17,732 --> 00:09:21,422
each part of that architecture can't if it needs to

142
00:09:21,556 --> 00:09:25,090
adopt a different technology, stack microservices,

143
00:09:25,670 --> 00:09:30,050
and this is the scenario we're going through today. So, from monolith to microservices.

144
00:09:30,390 --> 00:09:34,034
So microservices architectures can

145
00:09:34,072 --> 00:09:37,186
solve a lot of the problems that we've just discussed.

146
00:09:37,378 --> 00:09:41,106
So, in terms of what a microservices architecture is. So whereas

147
00:09:41,138 --> 00:09:44,626
a monolith is a large unit that does everything and contains

148
00:09:44,658 --> 00:09:48,342
all functionality for the application, a monolith

149
00:09:48,406 --> 00:09:52,618
is split into smaller services, and each service

150
00:09:52,704 --> 00:09:55,946
does one specific thing and delivers one piece of

151
00:09:55,968 --> 00:09:59,274
business functionality. And those smaller services

152
00:09:59,392 --> 00:10:01,390
communicate via APIs.

153
00:10:02,930 --> 00:10:06,570
And this can result in a number of benefits. Firstly,

154
00:10:06,650 --> 00:10:09,774
your less tightly coupled architecture means that each

155
00:10:09,812 --> 00:10:13,554
service can be developed and deployed independently without having

156
00:10:13,592 --> 00:10:16,562
to deploy the entire app each time.

157
00:10:16,696 --> 00:10:20,194
This can increase deployment velocity and also

158
00:10:20,232 --> 00:10:24,370
give your engineering teams more autonomy within their particular swim lane.

159
00:10:25,130 --> 00:10:28,774
Reliability can improve, services can be made

160
00:10:28,812 --> 00:10:33,010
independent, and failures inside one service won't necessarily

161
00:10:33,090 --> 00:10:37,058
propagate out into other areas of the application, assuming it's

162
00:10:37,074 --> 00:10:38,310
well architected,

163
00:10:39,550 --> 00:10:42,570
scalability is more efficient.

164
00:10:42,990 --> 00:10:46,378
You're only going to have to scale the particular services that

165
00:10:46,384 --> 00:10:49,846
your users are calling, rather than scaling the entire

166
00:10:49,968 --> 00:10:53,770
monolithic application. Adopting new technologies

167
00:10:53,850 --> 00:10:57,806
is easier. You are not bound by the choices made

168
00:10:57,988 --> 00:11:00,720
of previous engineers and the wider application.

169
00:11:01,490 --> 00:11:04,754
For example, being forced to use an existing data

170
00:11:04,792 --> 00:11:09,198
structure inside the monolith and then finally smaller

171
00:11:09,214 --> 00:11:12,834
services with smaller code bases means that it's easier for new

172
00:11:12,872 --> 00:11:16,498
developers to get on board and ramp up to speed.

173
00:11:16,594 --> 00:11:20,242
Okay, so with that, we're now going to head into today's

174
00:11:20,306 --> 00:11:24,680
scenario. So our scenario today.

175
00:11:25,210 --> 00:11:28,700
So today we'll be modernizing from a

176
00:11:29,070 --> 00:11:32,970
monolithic architecture to a microservices architecture

177
00:11:33,870 --> 00:11:37,430
in an effort to get more business agility,

178
00:11:37,590 --> 00:11:41,262
be more cost efficient, and create a more portable code

179
00:11:41,316 --> 00:11:44,718
base. So our scenario in detail.

180
00:11:44,884 --> 00:11:48,202
So today we're looking at an application that was developed

181
00:11:48,346 --> 00:11:51,866
years ago with zero proper documentation.

182
00:11:51,978 --> 00:11:55,474
So a common problem we find in many

183
00:11:55,512 --> 00:11:59,426
of our customers, the team on the ground are

184
00:11:59,448 --> 00:12:02,814
not comfortable with containerization and AWS

185
00:12:02,862 --> 00:12:04,290
deployment best practices.

186
00:12:06,150 --> 00:12:09,414
You want to kickstart your modernization journey as soon as

187
00:12:09,452 --> 00:12:13,142
possible, but in addition to

188
00:12:13,196 --> 00:12:17,126
solving for these challenges, there's also some

189
00:12:17,148 --> 00:12:21,174
new business requirements and you need to make incremental functionality

190
00:12:21,222 --> 00:12:24,250
changes following the containerization.

191
00:12:27,310 --> 00:12:30,734
So today we will be applying a two

192
00:12:30,772 --> 00:12:34,430
pronged approach. So step one will be containerization.

193
00:12:35,170 --> 00:12:39,294
So we're going to quickly take this monolithic application and

194
00:12:39,332 --> 00:12:42,958
get it into a container on AWS. And the reason we're

195
00:12:42,974 --> 00:12:47,570
doing this is fourfold. First, to achieve some cost savings.

196
00:12:47,910 --> 00:12:52,194
Second, to achieve some initial productivity benefits of

197
00:12:52,312 --> 00:12:56,470
removing the need to manage and scale our own underlying infrastructure.

198
00:12:56,970 --> 00:13:01,174
Thirdly, to improve resilience by running it on AWS cloud.

199
00:13:01,372 --> 00:13:04,982
And then finally some agility benefits through moving

200
00:13:05,036 --> 00:13:07,400
towards a more standardized deployment process.

201
00:13:08,590 --> 00:13:11,910
Once we have the workload containerized and running on AWS,

202
00:13:12,070 --> 00:13:14,540
we are then going to refactor it.

203
00:13:15,230 --> 00:13:19,162
Ultimately, applications are easier to refactor once they're already

204
00:13:19,216 --> 00:13:22,922
on AWS. But crucially, this is where we'll be diving

205
00:13:22,986 --> 00:13:26,462
into Amazon Q so Amazon's Genai

206
00:13:26,596 --> 00:13:30,202
tooling to see how we can use Genai to accelerate

207
00:13:30,266 --> 00:13:32,510
our application modernization efforts.

208
00:13:35,030 --> 00:13:38,462
Okay. With that, I will now hand you over to my colleague

209
00:13:38,606 --> 00:13:42,702
Jorge Alvarez, who will take us through our modernization

210
00:13:42,766 --> 00:13:45,842
approach. Jorge, over to you. Ok,

211
00:13:45,896 --> 00:13:49,830
thank you Richard. Thanks for the explanation. So as Richard mentioned

212
00:13:49,900 --> 00:13:53,766
beforehand, there are different steps that you have to follow in

213
00:13:53,788 --> 00:13:57,766
terms of modernizing your application and AWS. He mentioned we are going

214
00:13:57,788 --> 00:14:01,466
to start for something related to how to move your application

215
00:14:01,568 --> 00:14:05,318
or modernize your application in containers to AWS.

216
00:14:05,414 --> 00:14:09,334
And later on we will use Amazon queue to help in the refactoring

217
00:14:09,382 --> 00:14:13,306
and how your application can be converted. But I don't want to jump the gun

218
00:14:13,338 --> 00:14:17,114
a little bit. So let's start for how we can use an AWS

219
00:14:17,162 --> 00:14:21,454
product called AWS Appt container to

220
00:14:21,572 --> 00:14:24,974
help us to move towards the modernization and

221
00:14:25,012 --> 00:14:28,670
to move things from our easy to instances

222
00:14:29,090 --> 00:14:32,626
or from our on prem solutions to the cloud.

223
00:14:32,808 --> 00:14:36,494
But if we think about how we developers,

224
00:14:36,542 --> 00:14:40,326
because I include myself, I was developer back on the day, how we

225
00:14:40,348 --> 00:14:44,134
do things is a very manual task. And when someone comes

226
00:14:44,172 --> 00:14:48,166
to us and say hey, I need to do a containerization of my application,

227
00:14:48,348 --> 00:14:51,470
we always think on four different steps.

228
00:14:51,570 --> 00:14:54,906
The first one is the discover. So when we are going

229
00:14:54,928 --> 00:14:58,186
to move an application from on Prem, we need to know what

230
00:14:58,208 --> 00:15:01,834
the impacts are. We need to know exactly where are the third party

231
00:15:01,882 --> 00:15:06,218
libraries, where are the dependencies, even the network dependencies,

232
00:15:06,314 --> 00:15:09,806
or if there is other applications that are interacting to

233
00:15:09,828 --> 00:15:13,186
that application. You will never want to move an

234
00:15:13,208 --> 00:15:17,278
application that has a downstream dependency or upstream dependency

235
00:15:17,454 --> 00:15:20,610
and that application stop working,

236
00:15:20,680 --> 00:15:24,340
right? So the first part it would be to understand

237
00:15:24,790 --> 00:15:27,746
where are that boundaries of the application.

238
00:15:27,928 --> 00:15:31,414
The second part that you would have to do is to get ready to

239
00:15:31,452 --> 00:15:34,950
prepare what you are going to do. So you are start thinking, okay,

240
00:15:35,020 --> 00:15:38,650
I need to see where my source code is. I need to manage different

241
00:15:38,720 --> 00:15:42,666
aspects. Like for example, my source code doesn't have any security

242
00:15:42,768 --> 00:15:46,102
constraints or it doesn't have any connection

243
00:15:46,166 --> 00:15:49,322
streams. And if I am going to package my

244
00:15:49,376 --> 00:15:52,814
solution, if I'm going to containerize my solution, it has to

245
00:15:52,852 --> 00:15:56,558
be secure enough, at least the last part

246
00:15:56,644 --> 00:16:00,170
or before the launch is going to be building the solution.

247
00:16:00,250 --> 00:16:03,930
So you create your docker file because you are going to the container,

248
00:16:04,010 --> 00:16:07,746
you put all the information that you need there and then you

249
00:16:07,768 --> 00:16:11,074
are going to take all that information and going to

250
00:16:11,112 --> 00:16:14,802
deploy in an infrastructure. So in this case we are talking, for example

251
00:16:14,936 --> 00:16:18,070
in our new cloud provider, like could be AWS,

252
00:16:18,650 --> 00:16:22,758
still a monolithic application, but you move to containers to get some benefits,

253
00:16:22,844 --> 00:16:26,742
right? If you think about that, if you think all

254
00:16:26,796 --> 00:16:30,346
the steps that I mentioned is a lot of work and I

255
00:16:30,368 --> 00:16:33,754
remember doing this in my previous life and it

256
00:16:33,792 --> 00:16:37,574
takes so long, but what are the challenges that we normally

257
00:16:37,622 --> 00:16:41,514
facing? So the first challenge is we are speaking about

258
00:16:41,552 --> 00:16:45,018
technology, we are speaking about tech stack challenges.

259
00:16:45,194 --> 00:16:48,366
And your application might be running in a legacy platform.

260
00:16:48,468 --> 00:16:52,110
Your application is in a server that people don't even remember

261
00:16:52,180 --> 00:16:55,474
what is inside or that server that is

262
00:16:55,512 --> 00:16:59,134
in one corner in the data center that you don't even patch

263
00:16:59,182 --> 00:17:02,578
the operating system anymore is something that is there.

264
00:17:02,664 --> 00:17:06,162
It's crucial for the company, but there is no

265
00:17:06,216 --> 00:17:09,846
time to get it in the next level. And there is

266
00:17:09,868 --> 00:17:13,750
no time to of course do all the steps that I mentioned beforehand.

267
00:17:14,330 --> 00:17:17,734
Also, if you are part of a team, you have to

268
00:17:17,772 --> 00:17:21,098
think on, well, I have to deliver what my business is telling to

269
00:17:21,104 --> 00:17:24,698
me to deliver, but at the same time I have to see

270
00:17:24,784 --> 00:17:28,326
what do I do with this application. But somehow

271
00:17:28,438 --> 00:17:31,430
you always go in the direction of the new features.

272
00:17:31,510 --> 00:17:34,798
Somehow you want to help your company to move to market.

273
00:17:34,964 --> 00:17:38,254
So you don't have essentially time or you don't have,

274
00:17:38,292 --> 00:17:42,106
if you are the manager of the team or the lead architect, a staff

275
00:17:42,218 --> 00:17:46,002
that can help you in modernizing that application,

276
00:17:46,136 --> 00:17:49,406
in moving that application to containers. Because all the steps

277
00:17:49,438 --> 00:17:53,246
that needs to be done. But what is the impact? Well, the impact

278
00:17:53,278 --> 00:17:57,026
is your operations. So if you have an application that nobody's

279
00:17:57,058 --> 00:18:01,734
taking care in terms of modernizing or moving it forward or

280
00:18:01,772 --> 00:18:05,318
doing something with it, your team has to keep it in the, keeps the

281
00:18:05,324 --> 00:18:09,158
light on needs to keep it in Ktlo alive.

282
00:18:09,334 --> 00:18:12,826
And that is going to impact in

283
00:18:12,848 --> 00:18:16,506
your operations. That is the step or

284
00:18:16,528 --> 00:18:20,494
these steps are the challenges that appcontainer can help

285
00:18:20,532 --> 00:18:24,090
you with. But what is exactly up to container?

286
00:18:24,170 --> 00:18:27,882
Well, app to container is a command line tool that supports

287
00:18:27,946 --> 00:18:32,126
Java and net applications. So basically it

288
00:18:32,148 --> 00:18:35,714
will work deployed in an EC two instance or in

289
00:18:35,752 --> 00:18:39,806
on prem in your server. And it's going to do all the steps

290
00:18:39,998 --> 00:18:43,614
that we explained beforehand. It's going to do the discovery

291
00:18:43,662 --> 00:18:47,006
for you, but also it's going to do the containerization

292
00:18:47,118 --> 00:18:50,614
with minimal efforts. So after container is going to

293
00:18:50,652 --> 00:18:54,098
remove that burden specifically from the developers

294
00:18:54,194 --> 00:18:58,360
and it's going to create all the appcontainer needs

295
00:18:58,750 --> 00:19:02,090
from what is the docker file to the image and

296
00:19:02,160 --> 00:19:05,420
all the different artifacts to containerize your application.

297
00:19:05,950 --> 00:19:09,366
One important caveat is Appto container doesn't need the source

298
00:19:09,398 --> 00:19:12,874
code. If you think yourself doing manually the

299
00:19:12,912 --> 00:19:16,222
job that we saw beforehand, you probably need

300
00:19:16,276 --> 00:19:20,654
access to your source code because you probably need to know exactly where

301
00:19:20,692 --> 00:19:24,190
the data is or what is going. You need to understand the application itself.

302
00:19:24,340 --> 00:19:27,994
What appcontainer does is going to scan

303
00:19:28,042 --> 00:19:32,030
inside of your server. It's going to capture where are the dependencies,

304
00:19:32,190 --> 00:19:35,662
where are the running applications and it's going to capture

305
00:19:35,726 --> 00:19:38,370
what is needed to containerize the solution.

306
00:19:38,710 --> 00:19:41,926
Thanks to that, AppContainer will help you to have a

307
00:19:41,948 --> 00:19:46,200
portable solution because it doesn't matter that you are deploying things

308
00:19:47,450 --> 00:19:50,934
on prem or if they are in c, two instance in

309
00:19:50,972 --> 00:19:54,746
AWS after container can be installed there and there

310
00:19:54,768 --> 00:19:58,454
is not an issue with that. But also it can help you to containerize

311
00:19:58,502 --> 00:20:02,554
at scale. Because if you think about doing this for multiple

312
00:20:02,602 --> 00:20:06,762
applications, the last thing that you want to do is to repeat

313
00:20:06,826 --> 00:20:10,894
all the steps that we saw beforehand in particular manner for

314
00:20:10,932 --> 00:20:14,922
every application with appcontainer. The CLI

315
00:20:14,986 --> 00:20:18,802
is going to guide you through all the process and step by step

316
00:20:18,936 --> 00:20:22,178
you as a developer or your developers, if you are a manager of a

317
00:20:22,184 --> 00:20:25,538
team will know how to do it. They will get used to

318
00:20:25,624 --> 00:20:29,254
and is going to help you to scale. Last but

319
00:20:29,292 --> 00:20:32,854
not least, up to container is going to help you to create the

320
00:20:32,892 --> 00:20:36,274
CLI, the CI CD pipelines,

321
00:20:36,402 --> 00:20:40,330
and it's going to help you to move to the AWS

322
00:20:40,750 --> 00:20:44,090
best practices. So it will allow you for example

323
00:20:44,160 --> 00:20:47,834
to deploy the solution. If you are comfortable with

324
00:20:47,872 --> 00:20:51,166
Kubernetes, with AWS EKS, or if you want

325
00:20:51,188 --> 00:20:54,826
to use more managed services or serverless solutions

326
00:20:54,938 --> 00:20:59,194
like AWS Fargate, that is your decision.

327
00:20:59,322 --> 00:21:02,894
The tool is there to help you. How does it work and

328
00:21:02,932 --> 00:21:06,434
what are the different steps? So after container will

329
00:21:06,472 --> 00:21:10,350
start with the discovery phase. So it will go and discover

330
00:21:10,430 --> 00:21:14,178
and analyze the solution and the dependencies around it. And it's something that

331
00:21:14,184 --> 00:21:17,790
we will see in the demo later on how it does later on.

332
00:21:17,880 --> 00:21:21,654
It will guide you through all the steps and it will help you to

333
00:21:21,692 --> 00:21:25,586
extract all the information for creating your docker container.

334
00:21:25,698 --> 00:21:29,874
It will extract what are the dependencies. It will create a file

335
00:21:30,002 --> 00:21:33,674
that you will be able to modify and you will be able to

336
00:21:33,712 --> 00:21:37,958
tweak. Depends on for example if you want to use different container image

337
00:21:38,054 --> 00:21:42,622
or if you want to be in another new version of

338
00:21:42,676 --> 00:21:45,710
operating system inside of the container image.

339
00:21:46,050 --> 00:21:49,726
Then during the creation of the deployment artifacts is when

340
00:21:49,748 --> 00:21:53,098
I said you can select exactly what is going to be the outcome.

341
00:21:53,194 --> 00:21:56,674
You can go and select apart from EKS or ECS, you can

342
00:21:56,712 --> 00:22:00,546
use for example a runner and it's going to help you to

343
00:22:00,568 --> 00:22:03,730
deploy in AWS, it's going to help you to create

344
00:22:03,800 --> 00:22:07,954
the CI CD pipeline, to create entire infrastructure

345
00:22:08,082 --> 00:22:11,602
that is needed to have a resilience and a new modern

346
00:22:11,666 --> 00:22:14,962
application. So if we see the typical

347
00:22:15,026 --> 00:22:19,014
application that we have in our data center or NEC two

348
00:22:19,132 --> 00:22:21,878
is running everything in one server.

349
00:22:22,054 --> 00:22:25,546
And in this case let's imagine it's a Java application that

350
00:22:25,568 --> 00:22:28,954
is running in an Apache Tomcat. I am giving you some

351
00:22:28,992 --> 00:22:32,518
hints on what we are going to see it's connected to a database

352
00:22:32,614 --> 00:22:36,014
and using up to appcontainer, we can end up in a solution like this

353
00:22:36,052 --> 00:22:40,174
one. So we will go to have a solution that is deployed in

354
00:22:40,212 --> 00:22:43,466
ECS. It's going to be connected with the internal

355
00:22:43,498 --> 00:22:46,866
network created in our VPC and it's going

356
00:22:46,888 --> 00:22:50,798
to have all the benefits to have ecs running in AWS Fargate.

357
00:22:50,894 --> 00:22:54,594
So it's going to have the serverless, it's going to have the

358
00:22:54,712 --> 00:22:57,320
less operations impact, for example.

359
00:22:57,930 --> 00:23:01,926
And that is going to provide you the option of

360
00:23:01,948 --> 00:23:06,338
your developers to be more focused on later on refactoring

361
00:23:06,354 --> 00:23:09,574
the application using for example Amazon Q and Genai

362
00:23:09,702 --> 00:23:13,274
rather than focusing the operations with that.

363
00:23:13,392 --> 00:23:17,194
Let's go and see the demo. Okay, so now

364
00:23:17,232 --> 00:23:21,290
we are going to see how up to container can help us in this journey.

365
00:23:21,370 --> 00:23:24,906
So for the demo perspective, I have here my EC

366
00:23:24,938 --> 00:23:28,494
two instances and inside of one of the easy

367
00:23:28,532 --> 00:23:32,110
two instances I have an application and Java application

368
00:23:32,180 --> 00:23:35,082
that is running in Tomcat.

369
00:23:35,226 --> 00:23:38,706
And you will see how up to container can help me in all

370
00:23:38,728 --> 00:23:42,594
the steps to go into a point that I have my application deployed in

371
00:23:42,632 --> 00:23:46,418
AWS. There is going to be certain things that I'm going to show in

372
00:23:46,424 --> 00:23:50,250
this demo that is provided in the documentation of appcontainer.

373
00:23:50,350 --> 00:23:54,322
Because in the terms of time, you know that containerizing an image

374
00:23:54,386 --> 00:23:57,718
is going to take some time. But I think it's important you understand

375
00:23:57,804 --> 00:24:01,450
how it works and how much bartering is going to remove from

376
00:24:01,520 --> 00:24:04,860
your site. So the first thing that I'm going to do is to connect

377
00:24:07,070 --> 00:24:09,930
to the server using session manager.

378
00:24:10,510 --> 00:24:13,950
So session manager is logging

379
00:24:14,450 --> 00:24:18,170
and now we are going to do and start doing the different steps

380
00:24:18,250 --> 00:24:21,882
in this server which is working like it could be your on premise server

381
00:24:21,946 --> 00:24:25,326
or it could be your easy to instance in AWS because you

382
00:24:25,348 --> 00:24:28,990
did a lift and shift. I have installed already up to container,

383
00:24:29,070 --> 00:24:33,026
but before to do that I am going to grant permissions to myself. So I

384
00:24:33,048 --> 00:24:37,202
am going to use pseudo to get the higher permissions

385
00:24:37,266 --> 00:24:40,742
or elevated permissions. And the first thing that I'm going to do is

386
00:24:40,796 --> 00:24:44,134
I am going to show what are the

387
00:24:44,172 --> 00:24:48,034
different options that up to appcontainer CLI

388
00:24:48,082 --> 00:24:51,434
has. If you remember the steps that we did beforehand and

389
00:24:51,472 --> 00:24:54,810
we were reviewing inside of the slides, we were thinking

390
00:24:54,880 --> 00:24:58,646
about discovery, we were thinking about analyze containerizing.

391
00:24:58,758 --> 00:25:02,182
As you can see here at glance, up to container is providing

392
00:25:02,246 --> 00:25:05,662
you all the different steps and is explaining you

393
00:25:05,716 --> 00:25:09,326
exactly when to use each of those. So the first thing that we

394
00:25:09,348 --> 00:25:13,650
are going to do is to init the solution

395
00:25:14,230 --> 00:25:17,646
and that is because I have installed

396
00:25:17,758 --> 00:25:21,106
and is the first steps that we are going to do. So I'm going to

397
00:25:21,128 --> 00:25:24,500
say up to appcontainer agent

398
00:25:25,190 --> 00:25:29,014
automatically the solution or the CLI is going

399
00:25:29,052 --> 00:25:32,662
to start showing me values that I

400
00:25:32,716 --> 00:25:36,434
have already, which is my case. In your case, some of these values

401
00:25:36,482 --> 00:25:40,182
might not be there present and you need to create them. So for example,

402
00:25:40,236 --> 00:25:44,314
what is the workshop directory is related to the installation or

403
00:25:44,352 --> 00:25:48,374
what is the easy to instance profile? The easy to instance profile

404
00:25:48,502 --> 00:25:52,234
is the IAM role that is going to be used to

405
00:25:52,272 --> 00:25:55,546
connect to s three. Because yes, up to container

406
00:25:55,578 --> 00:25:58,574
is a CLI but need an s three bucket and I'm going to show you

407
00:25:58,612 --> 00:26:01,070
for a second which one I created.

408
00:26:02,770 --> 00:26:06,146
So here you can see that I have an s three bucket which

409
00:26:06,168 --> 00:26:09,794
is called app to container for the conference 42. And here

410
00:26:09,832 --> 00:26:14,526
is where app to container is going to deploy artifacts

411
00:26:14,558 --> 00:26:18,006
and needs for containerization, artifacts that need for deploying in

412
00:26:18,028 --> 00:26:21,974
AWS. But even if you have an error, it's going to provide information

413
00:26:22,092 --> 00:26:25,654
inside about logs and things that you can see

414
00:26:25,692 --> 00:26:29,434
later on. So I am going to say yes, I am going to use

415
00:26:29,552 --> 00:26:33,210
this profile and I am going to use the exact same

416
00:26:33,280 --> 00:26:37,094
region where I have my easy to instance.

417
00:26:37,142 --> 00:26:40,540
In my case, which is going to be us west two,

418
00:26:41,170 --> 00:26:45,754
the name of the s three bucket is coming by default because I have configured

419
00:26:45,882 --> 00:26:49,502
beforehand. And yes I want to send to

420
00:26:49,556 --> 00:26:52,986
AWS the user's metrics to know more

421
00:26:53,028 --> 00:26:56,690
and get more insights from my side in terms of

422
00:26:56,840 --> 00:27:01,106
how the solution is working. I am going to tell

423
00:27:01,288 --> 00:27:04,754
up to container to send all the errors and

424
00:27:04,792 --> 00:27:08,774
all the possible problems to my s three bucket. And the

425
00:27:08,812 --> 00:27:12,098
last one is up to you if you want that your Docker

426
00:27:12,274 --> 00:27:15,734
solution is going to be created using unsigned by

427
00:27:15,772 --> 00:27:19,126
Docker content trust or not. In my case I am going

428
00:27:19,148 --> 00:27:23,446
to say yes. Okay, so everything has been configured in the CLI.

429
00:27:23,558 --> 00:27:26,906
So now let's start thinking on, okay, what is the

430
00:27:26,928 --> 00:27:30,066
first step that I need to do? Well, I need to discover,

431
00:27:30,198 --> 00:27:34,026
I need to get an inventory on what is happening in my server.

432
00:27:34,138 --> 00:27:37,758
So I'm going to type up the container and I'm going

433
00:27:37,764 --> 00:27:41,994
to say inventory automatically.

434
00:27:42,042 --> 00:27:45,874
The CLI has detected that there is a Java application which

435
00:27:45,992 --> 00:27:49,234
by the way is providing a name to it. And this

436
00:27:49,272 --> 00:27:52,706
Java application, it has a process id, it has

437
00:27:52,888 --> 00:27:55,934
a web route and then it has other

438
00:27:55,992 --> 00:27:58,902
information around Apache tone card,

439
00:27:59,036 --> 00:28:02,326
there is some identification and remember

440
00:28:02,428 --> 00:28:06,182
I did not have to use any source code for that. So that id

441
00:28:06,236 --> 00:28:10,050
is important that you save it for later on.

442
00:28:10,140 --> 00:28:13,818
Because this information is going to be the one that we need for the rest

443
00:28:13,904 --> 00:28:18,410
of the commands. So let's say that we want to know something

444
00:28:18,560 --> 00:28:21,854
about the application itself. So we want to start

445
00:28:21,972 --> 00:28:25,854
the process of analyzing the application. So we will go

446
00:28:25,892 --> 00:28:29,534
and we say up to container and we

447
00:28:29,572 --> 00:28:33,086
have to put what is going to be the action that we want to

448
00:28:33,108 --> 00:28:36,994
do, analyze. And then we

449
00:28:37,032 --> 00:28:40,306
are going to include where is the application id that we are going to

450
00:28:40,328 --> 00:28:45,300
analyze. So we say application id

451
00:28:45,770 --> 00:28:49,094
and we are going to copy paste exactly the

452
00:28:49,132 --> 00:28:51,430
id that we have from the inventory.

453
00:28:54,010 --> 00:28:54,760
Okay.

454
00:28:56,810 --> 00:28:59,526
And what is happening is up to container.

455
00:28:59,638 --> 00:29:03,546
Went to get the information about the application, scan the

456
00:29:03,568 --> 00:29:07,242
dependencies and providing all that data. If you see

457
00:29:07,296 --> 00:29:11,706
on the outcome, it says it created artifacts in

458
00:29:11,728 --> 00:29:14,942
a specific folder. But what is important for us now

459
00:29:15,076 --> 00:29:18,606
is that generated an analysis JSon. So what

460
00:29:18,628 --> 00:29:21,710
I'm going to do now is to open that analysis Json and

461
00:29:21,860 --> 00:29:25,620
guide you through it. Okay. I'm going to use Nano in this case

462
00:29:26,870 --> 00:29:31,330
and I'm going to copy exactly this path.

463
00:29:33,030 --> 00:29:36,818
Okay. So now we are going to see what is the information inside of analysis

464
00:29:36,914 --> 00:29:39,974
Json. So here is the information that has

465
00:29:40,012 --> 00:29:43,234
been created by app to container

466
00:29:43,362 --> 00:29:46,758
when it did the analysis of the application. The first part

467
00:29:46,844 --> 00:29:50,086
is going to be the container parameters. The first part is the part

468
00:29:50,188 --> 00:29:54,394
that I would recommend you to change is the part that is

469
00:29:54,432 --> 00:29:57,994
going to be used when you create your appcontainer. In this

470
00:29:58,032 --> 00:30:01,614
scenario, you can see that we have here a container based image in

471
00:30:01,652 --> 00:30:05,614
Ubuntu 18. So what I'm going to do is I'm going to modify this

472
00:30:05,732 --> 00:30:09,280
and I'm going to say to use the version 20 because

473
00:30:12,850 --> 00:30:16,718
it's more updated, it has more features

474
00:30:16,814 --> 00:30:20,322
and I don't want to have the 18 version. But if I keep going down,

475
00:30:20,456 --> 00:30:24,030
I can see other information about the analysis results.

476
00:30:24,110 --> 00:30:27,682
I can see for example, that it's a Java tone cap solution.

477
00:30:27,826 --> 00:30:31,762
And I can go to the properties

478
00:30:31,906 --> 00:30:35,960
to see that it's a Tomcat eight. Or that is

479
00:30:36,810 --> 00:30:40,006
for example using the configuration and login properties

480
00:30:40,118 --> 00:30:43,574
inside of the web apps or even the environment

481
00:30:43,622 --> 00:30:46,700
variables associated to the operating system.

482
00:30:47,390 --> 00:30:50,826
So all of that is an important information that

483
00:30:50,848 --> 00:30:54,574
we can have before we do the container. And we

484
00:30:54,612 --> 00:30:58,186
can have that information to understand where are we heading

485
00:30:58,218 --> 00:31:01,534
towards. So after I did the change, I am going

486
00:31:01,572 --> 00:31:06,114
to exit and I'm going to say, yes, I want to change the

487
00:31:06,152 --> 00:31:10,878
file and going back to our terminal.

488
00:31:11,054 --> 00:31:15,022
So okay, I modify, where is the information about

489
00:31:15,176 --> 00:31:19,030
the container? I saw the analysis and now

490
00:31:19,100 --> 00:31:23,126
the next step is going to be to containerize the application.

491
00:31:23,308 --> 00:31:28,106
So I'm going to say after container and

492
00:31:28,128 --> 00:31:31,210
then it's going to be contain.

493
00:31:34,510 --> 00:31:37,994
And if you see here, it can tell you what is

494
00:31:38,032 --> 00:31:41,690
the next step. If you see the next steps, you see edit and then

495
00:31:41,760 --> 00:31:45,774
start the process using after container containerized application

496
00:31:45,892 --> 00:31:49,386
Id. Java Tonka Id. So you don't

497
00:31:49,418 --> 00:31:53,194
have even to know this by heart. The solution is giving

498
00:31:53,252 --> 00:31:56,626
you all the steps. So I'm going to copy paste this and

499
00:31:56,648 --> 00:31:59,730
I'm going to start the containerization.

500
00:32:01,350 --> 00:32:04,862
So what it's doing up to container is getting all the

501
00:32:04,936 --> 00:32:08,198
information around the changes that I did.

502
00:32:08,284 --> 00:32:11,894
The analysis of the application, the analysis JSON and

503
00:32:11,932 --> 00:32:16,310
it's creating the Docker file. It's creating the docker and is validating

504
00:32:17,050 --> 00:32:20,842
everything around it. One thing that you might spot on after

505
00:32:20,896 --> 00:32:24,422
container is sending me a warning because I modify

506
00:32:24,486 --> 00:32:28,874
the container based image. I got it moving

507
00:32:29,072 --> 00:32:33,114
from 18 to 20. Cool. So after container

508
00:32:33,162 --> 00:32:36,318
did all the steps. Docker file. The Docker file id

509
00:32:36,404 --> 00:32:40,362
degenerated the deployment data and doing the prevalidation.

510
00:32:40,426 --> 00:32:44,034
But what is exactly this deployment information? Let's see for

511
00:32:44,072 --> 00:32:48,706
a second. I go here and I copy the

512
00:32:48,808 --> 00:32:52,690
entire path and I go and say nano.

513
00:32:56,810 --> 00:32:59,942
So the deployment JSON is the

514
00:32:59,996 --> 00:33:03,650
file that is going to be used to deploy to AWS.

515
00:33:03,810 --> 00:33:07,446
So we have our image created, we have the

516
00:33:07,468 --> 00:33:11,258
deployment JSON. And in deployment JSON we can configure exactly

517
00:33:11,344 --> 00:33:15,206
how we want to do this. If you see here, you might spot

518
00:33:15,238 --> 00:33:19,382
on that there is an ECS parameters and it says create ECS artifact

519
00:33:19,446 --> 00:33:22,986
true. That is because in this solution of up to container

520
00:33:23,018 --> 00:33:26,766
on this demo we are going to show you how to do

521
00:33:26,788 --> 00:33:30,560
it with ecs. But if for example you are a specific

522
00:33:31,410 --> 00:33:35,362
passion about kubernetes, you can come to this section and see

523
00:33:35,416 --> 00:33:39,362
at the end how you can create eks artifacts to true

524
00:33:39,496 --> 00:33:42,350
and moving towards to the Kubernetes solution.

525
00:33:42,510 --> 00:33:45,854
But for the demo perspective, we are going to use ecs

526
00:33:45,902 --> 00:33:49,826
and we are going to use in deploy target. As you can see here fargate.

527
00:33:50,018 --> 00:33:53,682
So one thing that is important is app to container

528
00:33:53,746 --> 00:33:57,046
knows about your source code, but it doesn't know

529
00:33:57,148 --> 00:34:01,098
about where you are going towards. And if we see here,

530
00:34:01,184 --> 00:34:04,746
I need to provide to appcontainer my VPC id. I need

531
00:34:04,768 --> 00:34:07,946
to provide to the CLI where are we

532
00:34:07,968 --> 00:34:11,630
going to deploy the solution. So I go back to my console

533
00:34:12,370 --> 00:34:14,270
and I go back to VPC.

534
00:34:17,010 --> 00:34:20,922
And then I'm going to select my target

535
00:34:20,986 --> 00:34:21,870
VPC.

536
00:34:25,740 --> 00:34:31,020
And then I am going to copy my VPC id and

537
00:34:31,090 --> 00:34:34,844
paste here. That's important because as

538
00:34:34,882 --> 00:34:38,640
I mentioned, after container needs to know exactly where we are going to deploy

539
00:34:38,980 --> 00:34:42,428
our solution. So with this I'm

540
00:34:42,444 --> 00:34:45,890
going to say yes and then save the data.

541
00:34:47,140 --> 00:34:51,216
So I have my deployment solution created,

542
00:34:51,328 --> 00:34:55,072
I have my appcontainer created. It has been containerized,

543
00:34:55,136 --> 00:34:58,070
it has been validated. In fact,

544
00:34:59,480 --> 00:35:02,704
I want to show you that the images exist.

545
00:35:02,832 --> 00:35:06,600
It's not that I am doing this like they don't exist. They are there,

546
00:35:06,670 --> 00:35:09,704
they have been created. And I have everything to

547
00:35:09,742 --> 00:35:13,080
start the deployment, literally to AWS.

548
00:35:13,420 --> 00:35:16,856
As I mentioned beforehand, I might remember that I have to

549
00:35:16,878 --> 00:35:20,124
use or what is know the next

550
00:35:20,162 --> 00:35:23,724
step, or maybe not. But if you follow the next steps you have

551
00:35:23,762 --> 00:35:28,348
here, what is the next step for you after container generate

552
00:35:28,444 --> 00:35:31,440
app deployment Java application.

553
00:35:31,590 --> 00:35:39,584
So I'm going to copy that and

554
00:35:39,622 --> 00:35:42,916
then letting up to container going. This is going to

555
00:35:42,938 --> 00:35:46,164
take a specific time in your case.

556
00:35:46,202 --> 00:35:50,150
In my case it's going much faster because I have the things already

557
00:35:50,920 --> 00:35:54,344
created. But what basically did is if I go here

558
00:35:54,382 --> 00:35:57,130
to s three bucket, I'm going to show you the information.

559
00:35:58,620 --> 00:36:04,184
And what it basically did for ECs is to create the

560
00:36:04,222 --> 00:36:07,656
specific cloud formation that is going to be

561
00:36:07,678 --> 00:36:11,160
deployed afterwards to create your ECS cluster.

562
00:36:11,240 --> 00:36:13,900
So if I go here and I go to ECS,

563
00:36:19,570 --> 00:36:23,822
you can see that up to container created the cluster, it created

564
00:36:23,966 --> 00:36:27,378
the solution and we can see how it's working

565
00:36:27,464 --> 00:36:30,290
up and running. So if I go to the tasks,

566
00:36:33,790 --> 00:36:37,082
I can see that there is a specific public IP

567
00:36:37,226 --> 00:36:40,990
and I can see also how the cluster is

568
00:36:41,140 --> 00:36:45,054
working with the pod. And then I am

569
00:36:45,092 --> 00:36:49,086
going to go to the load balancers

570
00:36:49,278 --> 00:36:56,416
sec and

571
00:36:56,438 --> 00:36:59,836
I have here my load balancer created for the cluster.

572
00:36:59,948 --> 00:37:03,680
And if I open the public DNS,

573
00:37:06,200 --> 00:37:09,844
the application is up and running. So in

574
00:37:09,962 --> 00:37:13,424
all the different steps that we did after container

575
00:37:13,552 --> 00:37:16,736
containerized the application, it moved

576
00:37:16,768 --> 00:37:20,596
forward the application to AWS. And it helped

577
00:37:20,628 --> 00:37:24,072
me to get step by step what I needed to do.

578
00:37:24,206 --> 00:37:27,896
And there are other steps that you can keep going with

579
00:37:27,918 --> 00:37:31,710
have to container. You can create your pipeline, you can create

580
00:37:32,080 --> 00:37:36,076
the different deployments that for demo perspective we

581
00:37:36,098 --> 00:37:39,132
are going to arrive to this point. But if you can keep going,

582
00:37:39,266 --> 00:37:42,488
following exactly the steps that the solution gives you,

583
00:37:42,594 --> 00:37:46,060
and repeat, and repeat again and again and go on a scale.

584
00:37:46,140 --> 00:37:49,660
Thanks Jorge. And welcome back to the presentation

585
00:37:49,740 --> 00:37:54,240
part of the video. Absolutely phenomenal to see you containerize

586
00:37:54,900 --> 00:37:58,476
something and deploy an ECs in what must be kind of

587
00:37:58,518 --> 00:38:02,244
less than 45 minutes even when you're doing that for the first time. Back over

588
00:38:02,282 --> 00:38:06,390
to you. Thank you so much, Richard. And as we mentioned at the start,

589
00:38:06,780 --> 00:38:11,076
containerizing and moving your application to AWS

590
00:38:11,188 --> 00:38:14,984
in modern infrastructure is the first step.

591
00:38:15,102 --> 00:38:18,628
But then we can use our Genai solution,

592
00:38:18,724 --> 00:38:22,284
Amazon Q, to help us on refactoring and that

593
00:38:22,322 --> 00:38:25,884
would be your stage two. But what do I mean by

594
00:38:25,922 --> 00:38:29,052
that? Well, Amazon Q is a new

595
00:38:29,106 --> 00:38:33,004
generative AI assistant that is designated to

596
00:38:33,042 --> 00:38:36,924
help you in your day to day journey. So basically Amazon

597
00:38:36,972 --> 00:38:40,160
Q will help you to answer quickly on

598
00:38:40,230 --> 00:38:44,524
natural interactions and natural language interactions and informing

599
00:38:44,572 --> 00:38:47,076
about your system, your data.

600
00:38:47,258 --> 00:38:50,916
And of course it's going to provide you solutions that they are

601
00:38:51,098 --> 00:38:54,928
full, secure and that can help you in terms of privacy,

602
00:38:55,024 --> 00:38:58,376
even with your business. So Amazon Q is not going

603
00:38:58,398 --> 00:39:02,312
to access on anything that is

604
00:39:02,366 --> 00:39:05,096
not allowed by yourself.

605
00:39:05,278 --> 00:39:09,540
Also, we have the Amazon queue

606
00:39:09,620 --> 00:39:13,452
as an enterprise customer solution, which basically

607
00:39:13,586 --> 00:39:17,128
is going to rely on customers requirements

608
00:39:17,304 --> 00:39:20,908
from day one. But what are the different aspects of Amazon Q? And I

609
00:39:20,914 --> 00:39:23,720
would like to give a brief overview.

610
00:39:23,800 --> 00:39:27,696
Nevertheless, today we are going to focus only on the Amazon queue as

611
00:39:27,718 --> 00:39:31,056
your expert. So which is basically the first one

612
00:39:31,078 --> 00:39:34,396
that I'm going to talk about. And Amazon Q as an

613
00:39:34,438 --> 00:39:38,000
expert, it can help you with the well architected framework.

614
00:39:38,080 --> 00:39:41,636
It can give you answers to your questions

615
00:39:41,738 --> 00:39:45,510
inside of your AWS console or even in your

616
00:39:45,960 --> 00:39:49,876
more preference ide. In this case, we are

617
00:39:49,898 --> 00:39:53,272
going to use vs. Code,

618
00:39:53,406 --> 00:39:56,888
which basically Amazon Q is going to help us there.

619
00:39:56,974 --> 00:40:01,196
So also Amazon Q can work in

620
00:40:01,218 --> 00:40:04,812
quicksight for enhancing your business analyst and your business

621
00:40:04,866 --> 00:40:09,416
users productivity using generative AI capabilities.

622
00:40:09,608 --> 00:40:13,344
Also, Amazon Q can work in connect, so it can help

623
00:40:13,382 --> 00:40:17,584
you to leverage real time conversations with the customers and

624
00:40:17,782 --> 00:40:21,712
to the relevant company content to automatically provide that

625
00:40:21,766 --> 00:40:25,436
information to your support agents.

626
00:40:25,558 --> 00:40:29,504
So it's going to be the accelerator, all that journey

627
00:40:29,552 --> 00:40:32,260
between your customers and your staff.

628
00:40:32,600 --> 00:40:36,084
Last but not least is coming soon. Amazon Q can help

629
00:40:36,122 --> 00:40:40,360
you in what is going to be your AWS supply chain service,

630
00:40:40,510 --> 00:40:43,864
where it can help you to understand where is their

631
00:40:43,902 --> 00:40:47,544
supply and demand planners and how

632
00:40:47,662 --> 00:40:51,992
it can provide their answers about what is happening and

633
00:40:52,046 --> 00:40:55,292
what is happening and what actions they need to take.

634
00:40:55,426 --> 00:40:58,956
As I mentioned, we need to focus today in what is

635
00:40:58,978 --> 00:41:02,204
going to be the Amazon queue, your AWS expert, because that part

636
00:41:02,242 --> 00:41:06,188
is the one that is going to help you to move forward in your modernization

637
00:41:06,284 --> 00:41:10,096
journey. And Amazon Q can

638
00:41:10,198 --> 00:41:14,508
help you. For example, if you are using it inside of your AWS console.

639
00:41:14,604 --> 00:41:18,356
It helps you when you are processing inside of

640
00:41:18,378 --> 00:41:21,904
the console, but also it can help you to fix in bugs

641
00:41:21,952 --> 00:41:25,540
if you're using it, for example with lambda or it can help you to research

642
00:41:25,610 --> 00:41:29,384
inside documentation or knowing exactly what is your

643
00:41:29,422 --> 00:41:33,256
right instance, or if you have to run or

644
00:41:33,278 --> 00:41:36,968
upgrade a specific runtimes versions. One of

645
00:41:36,974 --> 00:41:40,984
the examples that we are going to see today is Amazon Q code transformation,

646
00:41:41,112 --> 00:41:44,652
which helps you to move this Java application, for example

647
00:41:44,786 --> 00:41:48,940
from Java eight or eleven to Java 17.

648
00:41:49,920 --> 00:41:54,156
Also, Amazon Q can provide you to help to troubleshoot

649
00:41:54,188 --> 00:41:57,632
your own code. Or if someone left the company and

650
00:41:57,686 --> 00:42:01,200
you don't know what that code does, Amazon Q can give you

651
00:42:01,350 --> 00:42:05,890
in the IDE via Amazon code whisperer information

652
00:42:06,340 --> 00:42:09,776
about how looks like the code or what

653
00:42:09,798 --> 00:42:13,716
it's doing. Or even you can ramp up new base code

654
00:42:13,818 --> 00:42:17,604
in no time because it can support you understanding

655
00:42:17,652 --> 00:42:21,412
what is the context of the application and doing things that normally

656
00:42:21,476 --> 00:42:24,170
take days in a matter of minutes.

657
00:42:25,100 --> 00:42:28,152
But where is the best approach in terms

658
00:42:28,206 --> 00:42:32,136
of the refactoring stuff, where can help our developers?

659
00:42:32,248 --> 00:42:36,124
Well, 73% of the

660
00:42:36,162 --> 00:42:39,960
time our developers are running and maintaining

661
00:42:40,040 --> 00:42:43,288
applications. So if you remember all the challenges that we had

662
00:42:43,314 --> 00:42:46,624
at the start with the monolithic application, when we are speaking about

663
00:42:46,662 --> 00:42:50,304
operations and we are speaking about time that people take

664
00:42:50,502 --> 00:42:53,520
to get that application, which is critical,

665
00:42:54,260 --> 00:42:58,208
up and running is where developers can put the effort

666
00:42:58,304 --> 00:43:01,924
there. So basically when you move for your

667
00:43:01,962 --> 00:43:05,236
transition to something and much more managed services, when you

668
00:43:05,258 --> 00:43:09,316
move and transition to something more modern solutions, that helps

669
00:43:09,348 --> 00:43:12,712
you to move the needle more to the size

670
00:43:12,766 --> 00:43:16,440
of the developers doing what they want, which nowadays is around

671
00:43:16,510 --> 00:43:19,916
27%. But how Amazon Q in that

672
00:43:19,938 --> 00:43:24,584
journey can help? Well, developers will face multiple

673
00:43:24,632 --> 00:43:28,156
challenges. For example, they will face how to

674
00:43:28,178 --> 00:43:31,660
manage the resources, they will face issues about how to

675
00:43:31,730 --> 00:43:35,004
write the code or understand that all code or even

676
00:43:35,042 --> 00:43:39,024
upgrade it. All of these is like brick walls that developers have

677
00:43:39,062 --> 00:43:42,972
to pass every day. And thanks to Amazon

678
00:43:43,036 --> 00:43:46,752
Q, dark walls are starting to get

679
00:43:46,806 --> 00:43:50,220
removed because the solution, it solves

680
00:43:50,300 --> 00:43:53,436
the problems in one location. It's one genai

681
00:43:53,468 --> 00:43:57,064
powered assistance. It's going to help you with code. Scanning four

682
00:43:57,102 --> 00:44:01,188
security threads is going to help you in the iDE and it's

683
00:44:01,204 --> 00:44:04,472
going to help you in the console, but also it's going to help you with

684
00:44:04,526 --> 00:44:07,864
upgrades as we are going to see in the next demo

685
00:44:08,062 --> 00:44:12,220
from Java, in this case eleven to Java 17.

686
00:44:13,440 --> 00:44:16,696
Okay, here we have a solution that is Java

687
00:44:16,728 --> 00:44:20,812
eleven solution. As you can see, I have the palm file open and

688
00:44:20,866 --> 00:44:24,716
here is the version of the Java and I have

689
00:44:24,898 --> 00:44:28,652
the solution open in Ambs code in my configuration

690
00:44:28,716 --> 00:44:32,432
I have here my AWs toolkit where I have my

691
00:44:32,486 --> 00:44:35,868
Amazon queue and I have configured the professional edition.

692
00:44:36,044 --> 00:44:39,428
So what we are going to do today is I am going to

693
00:44:39,514 --> 00:44:42,836
show you that this application is in Java eleven and I'm going to

694
00:44:42,858 --> 00:44:46,324
ask Amazon Q to do a transformation to move into

695
00:44:46,362 --> 00:44:49,824
Java 17. So I go to my AWs

696
00:44:49,872 --> 00:44:53,448
toolkit and I go into Amazon Q and I say I want to

697
00:44:53,534 --> 00:44:57,032
transform. So first of all, it's asking

698
00:44:57,086 --> 00:45:01,016
me on well, what is the project? And it detected my poem file at the

699
00:45:01,038 --> 00:45:05,592
moment Amazon queue at the time of recording it works only with maven.

700
00:45:05,736 --> 00:45:09,512
So I click on it and I am going to tell what is the version

701
00:45:09,576 --> 00:45:13,140
that is the current version. So it's

702
00:45:13,160 --> 00:45:16,512
eleven. Yes. And now it's asking

703
00:45:16,566 --> 00:45:20,400
me where is my GDK? I have here the path

704
00:45:20,900 --> 00:45:25,380
where is exactly in my machine copy

705
00:45:26,280 --> 00:45:28,630
paste. Okay,

706
00:45:29,720 --> 00:45:33,552
so now what Amazon Q is going to do is starting the transformation

707
00:45:33,616 --> 00:45:36,468
hub. It's taking all the information,

708
00:45:36,634 --> 00:45:40,520
understanding the code and then starting to work on it

709
00:45:40,590 --> 00:45:43,816
to get it transformed from the version eleven to the

710
00:45:43,838 --> 00:45:47,076
version 17. But meanwhile Amazon queue

711
00:45:47,108 --> 00:45:50,700
is working. I am going to show you other

712
00:45:50,770 --> 00:45:54,700
benefits that it has. So for example, if I go here and

713
00:45:54,850 --> 00:45:58,316
I open order manager and I

714
00:45:58,338 --> 00:46:01,804
open here my Amazon queue chat, I can start

715
00:46:01,842 --> 00:46:05,890
seeing that I have multiple code here that I'm not really sure what it does.

716
00:46:06,580 --> 00:46:10,124
I don't know exactly what are the different pieces.

717
00:46:10,172 --> 00:46:13,632
So I can start having a conversation with Amazon queue and I can

718
00:46:13,686 --> 00:46:18,836
say, can you explain me the

719
00:46:18,938 --> 00:46:22,580
order manager

720
00:46:23,560 --> 00:46:27,044
Java class and

721
00:46:27,082 --> 00:46:30,440
what Amazon Q is doing is basically going

722
00:46:30,590 --> 00:46:34,344
to the project, going to the class and it's going to start

723
00:46:34,462 --> 00:46:36,792
telling to me what exactly does.

724
00:46:36,926 --> 00:46:40,636
So it tells me, okay, the order manager class is responsible for

725
00:46:40,658 --> 00:46:43,948
managing orders placed by the customers and key things

726
00:46:44,034 --> 00:46:48,364
are and it's giving to me information

727
00:46:48,562 --> 00:46:53,484
inside. For example, the method get order that is visible here

728
00:46:53,602 --> 00:46:57,132
or the method lease orders.

729
00:46:57,196 --> 00:47:00,512
So it's giving me context exactly on what is

730
00:47:00,566 --> 00:47:04,616
this code doing, which is something that I might not know beforehand

731
00:47:04,668 --> 00:47:08,756
because maybe the person left or maybe because it's a

732
00:47:08,778 --> 00:47:12,660
source code that I downloaded from a public code repository.

733
00:47:13,000 --> 00:47:15,668
I don't know, it might give me some idea.

734
00:47:15,834 --> 00:47:19,880
But I can go and I can go to a specific. So Amazon Cube

735
00:47:20,380 --> 00:47:24,804
come with solutions that we can send prompt

736
00:47:24,932 --> 00:47:28,410
code to it that is going to provide information

737
00:47:28,780 --> 00:47:32,430
we saw, for example explain, but I can send for example

738
00:47:32,800 --> 00:47:37,804
if it can refactor it. So it

739
00:47:37,842 --> 00:47:41,572
gets information and automatically

740
00:47:41,736 --> 00:47:45,056
is catching up. Where are the different

741
00:47:45,158 --> 00:47:49,056
steps inside of that method that can be refactored and

742
00:47:49,078 --> 00:47:53,040
that can follow best practices on that journey?

743
00:47:53,380 --> 00:47:57,124
Even I can go and I say, okay, that is for my get

744
00:47:57,162 --> 00:48:00,804
order. But what about all these lease order

745
00:48:00,922 --> 00:48:05,572
API gateway answer sorry,

746
00:48:05,626 --> 00:48:09,076
that was the Amazon queue was creating the transformation plan for

747
00:48:09,098 --> 00:48:12,996
the transformation. As you can see we are doing concurrent

748
00:48:13,108 --> 00:48:16,744
work. I don't have to be waiting for it. Okay, I am going

749
00:48:16,782 --> 00:48:20,524
to select all of this and I'm going to say cool

750
00:48:20,562 --> 00:48:23,916
queue. Can you optimize all of

751
00:48:23,938 --> 00:48:27,324
this big method and tell me how can I

752
00:48:27,362 --> 00:48:28,140
optimize?

753
00:48:32,950 --> 00:48:36,146
So if I go here, it tells me, well, one of the

754
00:48:36,168 --> 00:48:39,846
things that you can do for example is to take the authorization logic and

755
00:48:39,868 --> 00:48:43,142
put it in synod method and then that will

756
00:48:43,196 --> 00:48:46,326
consider parallel streams. You can consider for

757
00:48:46,348 --> 00:48:50,250
example validations and how to handle different errors.

758
00:48:50,590 --> 00:48:54,762
So thanks to the solution I can go and I can understand

759
00:48:54,896 --> 00:48:58,074
about the context but not only the information that

760
00:48:58,112 --> 00:49:02,254
is here. I can go and ask how

761
00:49:02,292 --> 00:49:06,046
can I add Cognito to

762
00:49:06,068 --> 00:49:14,834
the project and

763
00:49:14,872 --> 00:49:19,480
asking questions that they are not literally related to.

764
00:49:19,850 --> 00:49:23,506
This project is going to give me the information that I need related

765
00:49:23,538 --> 00:49:27,094
to our documentation, related with the different

766
00:49:27,212 --> 00:49:30,374
steps and related to what

767
00:49:30,412 --> 00:49:34,234
is really needed for me in that moment. So I

768
00:49:34,272 --> 00:49:37,978
don't have to go outside of my ide

769
00:49:38,144 --> 00:49:41,386
and I don't have to be worried about understand if

770
00:49:41,408 --> 00:49:45,630
there is anything there that I need to figure

771
00:49:45,700 --> 00:49:49,754
out. But Amazon Q comes with multiple

772
00:49:49,882 --> 00:49:53,166
options. So this is the chat option, but there is another one which is

773
00:49:53,188 --> 00:49:57,234
the depth option. And when we are going to work with

774
00:49:57,272 --> 00:50:00,914
the entire project and we are going to can for

775
00:50:00,952 --> 00:50:04,546
example for security concerns or we are going to

776
00:50:04,568 --> 00:50:08,226
get information about it, it's better to

777
00:50:08,248 --> 00:50:11,766
go to the depth tab. So I type and I

778
00:50:11,788 --> 00:50:14,070
just click entry.

779
00:50:14,650 --> 00:50:17,302
And then the first thing that I'm going to do is I'm going to open

780
00:50:17,356 --> 00:50:21,110
my palm file. I know my palm file has a security concern.

781
00:50:21,530 --> 00:50:25,466
It's on purpose for the demo perspective. And what I'm going

782
00:50:25,488 --> 00:50:30,218
to do is can you list the

783
00:50:30,304 --> 00:50:35,514
security issues in

784
00:50:35,712 --> 00:50:39,102
smell? And what it's doing

785
00:50:39,156 --> 00:50:43,230
now is getting the information and

786
00:50:43,380 --> 00:50:47,258
it's taking the information from the palm file. It notes

787
00:50:47,274 --> 00:50:51,154
exactly that I am speaking about this project that we are having here and

788
00:50:51,192 --> 00:50:55,394
it's going to provide me back what are the different security concerns that

789
00:50:55,432 --> 00:50:58,050
exist inside of the palm file.

790
00:50:58,890 --> 00:51:02,454
Okay, so now Amazon Q has finished the

791
00:51:02,492 --> 00:51:05,910
functionality here it downloaded

792
00:51:07,610 --> 00:51:10,946
what is going to be the transformation from Java eleven

793
00:51:10,978 --> 00:51:14,262
to Java 17. And I can click here what are the proposed

794
00:51:14,326 --> 00:51:17,626
changes? So it's giving me what

795
00:51:17,648 --> 00:51:21,354
is the different changes that I need to do. It's giving me for example,

796
00:51:21,472 --> 00:51:24,714
a log that I can consume and I can see,

797
00:51:24,832 --> 00:51:28,666
so I can open the log and see what are the different steps

798
00:51:28,698 --> 00:51:31,966
that it was following and what are the different considerations that

799
00:51:31,988 --> 00:51:35,214
it was taking and if there are any worries that I have

800
00:51:35,252 --> 00:51:39,540
to be worried or pay attention about it. And what is saying

801
00:51:40,230 --> 00:51:44,706
for this case is that they have to take care about the

802
00:51:44,728 --> 00:51:48,214
new version of the maven changing the

803
00:51:48,252 --> 00:51:51,446
solution. And that will help me

804
00:51:51,468 --> 00:51:55,158
to start taking care on what is the different

805
00:51:55,244 --> 00:51:58,950
aspects that are happening here in this building solution.

806
00:51:59,690 --> 00:52:03,142
And after I have that converted to Java 17

807
00:52:03,206 --> 00:52:07,018
and I follow the steps, I even can go to the

808
00:52:07,104 --> 00:52:10,682
dev tab which basically is going to help

809
00:52:10,736 --> 00:52:13,658
me to work in other different aspects.

810
00:52:13,754 --> 00:52:17,070
So for example, if I say to QA,

811
00:52:20,130 --> 00:52:25,550
can you list security concerns

812
00:52:26,150 --> 00:52:31,582
in ordermanager

813
00:52:31,726 --> 00:52:34,946
Java? What it's going

814
00:52:34,968 --> 00:52:38,350
to do is it's going to go to the ordermanager

815
00:52:38,430 --> 00:52:42,102
Java and it's going to see what the code is,

816
00:52:42,156 --> 00:52:46,390
it's going to review if there is any security concerns and how

817
00:52:46,460 --> 00:52:49,814
looks like the changes that we should do

818
00:52:49,932 --> 00:52:53,834
and we should provide back and scan across

819
00:52:53,952 --> 00:52:57,658
all our application. So it's taking

820
00:52:57,744 --> 00:53:01,674
some time to get the answer and upload it and

821
00:53:01,712 --> 00:53:04,942
it's going to create a plan also for me. So you can see

822
00:53:04,996 --> 00:53:08,894
here, it detected that okay, in the review order

823
00:53:09,012 --> 00:53:13,198
Java manager Java, sorry, you have to look for places untrusted data,

824
00:53:13,364 --> 00:53:17,806
add validation to path parameters, add authorization to get ordered,

825
00:53:17,918 --> 00:53:22,274
remove sensitive data. But if I want to know exactly how

826
00:53:22,312 --> 00:53:25,780
it works, I say okay, create a code for me.

827
00:53:27,110 --> 00:53:30,630
So it's not only that the solution has been

828
00:53:30,700 --> 00:53:34,674
transformed the application from Java eleven to Java 17,

829
00:53:34,802 --> 00:53:38,502
it's also that they can move more towards to have

830
00:53:38,556 --> 00:53:42,346
something like I saw before, to have something connected to

831
00:53:42,368 --> 00:53:46,362
cognito or to enhance the solution in

832
00:53:46,416 --> 00:53:50,250
security aspects, or to

833
00:53:50,320 --> 00:53:53,686
understand from the different new components

834
00:53:53,718 --> 00:53:57,610
that I want to go in the direction of my refactoring journey.

835
00:53:57,770 --> 00:54:01,374
And also it provide us generation of the code

836
00:54:01,492 --> 00:54:04,814
on how to get these things sorted. Apart from

837
00:54:04,852 --> 00:54:08,642
the explanations and apart from the optimization and apart from

838
00:54:08,696 --> 00:54:11,550
the different steps from one location,

839
00:54:11,710 --> 00:54:15,662
I did not leave my ide at all and I did not move anywhere

840
00:54:15,726 --> 00:54:19,000
else to get information that I needed.

841
00:54:19,930 --> 00:54:25,030
So it's creating the code basically

842
00:54:25,100 --> 00:54:28,534
what it's doing is taking all the steps that they

843
00:54:28,572 --> 00:54:31,914
were listed above and

844
00:54:31,952 --> 00:54:36,282
it's going to create a specific diff file to compare my

845
00:54:36,336 --> 00:54:40,074
old code with my new code and see how we can

846
00:54:40,112 --> 00:54:43,834
change it. Okay, so you can see here

847
00:54:43,952 --> 00:54:47,134
that I have a test, it created a test and then he

848
00:54:47,172 --> 00:54:51,054
created the new solution. So I am going to

849
00:54:51,252 --> 00:54:55,582
click on it and then I can see here where are the difference between

850
00:54:55,636 --> 00:54:59,550
one or another and see where are the different steps

851
00:54:59,630 --> 00:55:02,866
that are going to be provided by the solution. So I'm going

852
00:55:02,888 --> 00:55:06,834
to say okay here also to

853
00:55:06,872 --> 00:55:09,798
start a unit test and I can say fine,

854
00:55:09,884 --> 00:55:13,942
insert code and it says that the code

855
00:55:13,996 --> 00:55:18,002
has been updated. So thanks to this solution

856
00:55:18,146 --> 00:55:21,420
I can be in one place and I can keep going

857
00:55:22,270 --> 00:55:25,626
with the refactoring since we started in an on

858
00:55:25,648 --> 00:55:29,206
prem solution and now I have new code selected.

859
00:55:29,398 --> 00:55:32,746
Going back to you Richard. Thanks Jorge. That was

860
00:55:32,768 --> 00:55:36,762
a really fantastic demo and it's amazing to see us take that workload

861
00:55:36,826 --> 00:55:40,554
from on premise, move it onto AWS

862
00:55:40,682 --> 00:55:45,434
with appcontainer to get it on a modern compute platform and

863
00:55:45,492 --> 00:55:48,926
then use Amazon queue to update

864
00:55:48,958 --> 00:55:52,994
the Java framework from version eleven to

865
00:55:53,032 --> 00:55:56,562
17. And now that application team can really

866
00:55:56,616 --> 00:55:59,862
go on that modernization journey and use Amazon Q

867
00:55:59,916 --> 00:56:03,446
to start refactoring code and delivering more business value

868
00:56:03,628 --> 00:56:07,606
for their customers. So thank

869
00:56:07,628 --> 00:56:11,142
you to you Jorge, and thank you to all of our listeners for joining

870
00:56:11,206 --> 00:56:12,620
this webinar today.

871
00:56:14,990 --> 00:56:18,522
If app to container is something that you think can benefit your business

872
00:56:18,576 --> 00:56:22,534
and your customers and Amazon Q is something you're

873
00:56:22,582 --> 00:56:23,870
looking to explore,

874
00:56:26,930 --> 00:56:30,734
be that in the confines of application modernization or more

875
00:56:30,772 --> 00:56:34,094
broadly, then we have a couple of recommended next steps for you.

876
00:56:34,212 --> 00:56:37,914
So the first is check out our modernize with AWS

877
00:56:37,962 --> 00:56:42,514
apps container workshop. So that will allow you to work through

878
00:56:42,712 --> 00:56:46,594
can example like the one we took you through today, but at your own

879
00:56:46,632 --> 00:56:49,666
pace and get hands on experience as you go.

880
00:56:49,848 --> 00:56:53,822
And then secondly, check out our use Amazon Q

881
00:56:53,896 --> 00:56:57,254
code transformation to upgrade the

882
00:56:57,292 --> 00:57:00,998
code language version workshop too. So similar to the app to container

883
00:57:01,014 --> 00:57:05,894
workshop allow you to go at your own pace and update

884
00:57:05,942 --> 00:57:09,446
that Java or in the example today that Java

885
00:57:09,478 --> 00:57:11,820
framework and modernize that code base.

886
00:57:13,070 --> 00:57:16,694
Jorge, any final comments from you before we wrap up the webinar?

887
00:57:16,822 --> 00:57:19,900
No Richard, it has been a pleasure to be here.

888
00:57:21,710 --> 00:57:25,020
Just keep going and keep trying

889
00:57:26,230 --> 00:57:29,502
these different solutions that help you to modernize.

890
00:57:29,566 --> 00:57:33,118
Of course. Thanks Jorge, and thanks to all of our listeners.

891
00:57:33,214 --> 00:57:37,262
If any of you want to get in contact with us, our contact details

892
00:57:37,326 --> 00:57:40,660
are on the screen. It's been an absolute pleasure. Thank you very much.

893
00:57:41,030 --> 00:57:42,370
Bye. Thank you,

