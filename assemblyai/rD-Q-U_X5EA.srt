1
00:00:24,810 --> 00:00:28,706
In his bestselling 2014 book, Homo Sapiens

2
00:00:28,738 --> 00:00:32,406
Yuval Noir, Harare discusses a brief history of

3
00:00:32,428 --> 00:00:35,686
humankind and one of the most important points in this book is

4
00:00:35,708 --> 00:00:38,966
that of stories. Stories and words are

5
00:00:38,988 --> 00:00:42,034
the master key that unlock human potential,

6
00:00:42,162 --> 00:00:45,734
whether that be your religion, your nationality, or even the company you

7
00:00:45,772 --> 00:00:50,106
work for and the values that that company has. Our ability to communicate

8
00:00:50,178 --> 00:00:53,422
an idea, to get people behind it, is something that really

9
00:00:53,476 --> 00:00:57,194
differentiates us from the animals. Now, if you've just joined

10
00:00:57,242 --> 00:01:00,366
this late or you're kind of confused right now because you thought

11
00:01:00,388 --> 00:01:03,310
this was a talk on event driven architecture, that's okay,

12
00:01:03,460 --> 00:01:07,134
because this is related to event driven architecture. And that's because Eda

13
00:01:07,182 --> 00:01:11,154
is fundamentally a communication pattern, a way of modelling the

14
00:01:11,192 --> 00:01:15,470
communication between your systems, whether that be the technical communication

15
00:01:15,550 --> 00:01:18,674
between two services or the human communication.

16
00:01:18,802 --> 00:01:21,960
As you talk to each other about what it is that your system does,

17
00:01:22,730 --> 00:01:25,478
the language, the story of your business,

18
00:01:25,644 --> 00:01:28,466
drives its technical implementation.

19
00:01:28,658 --> 00:01:31,194
And that's what you're going to learn about in this talk. You're going to learn

20
00:01:31,232 --> 00:01:34,634
the secrets of event driven architecture. How you can build event

21
00:01:34,672 --> 00:01:38,566
driven systems from the basic concepts through to some more intermediate

22
00:01:38,598 --> 00:01:42,538
patterns. I'm James Eastham. I'm a senior cloud architect at AWS

23
00:01:42,634 --> 00:01:45,374
and I want to set the expectation really early on.

24
00:01:45,412 --> 00:01:49,486
Now, this is not a talk about AWS, about services.

25
00:01:49,668 --> 00:01:53,434
This is a simple talk that's simply about boxes

26
00:01:53,482 --> 00:01:57,378
and lines. Yeah, it's one of those kind of talks. And I want to

27
00:01:57,384 --> 00:02:00,718
start by being really honest with you all. I've built event driven systems

28
00:02:00,734 --> 00:02:04,994
in the past and I've got them horribly, horribly wrong.

29
00:02:05,192 --> 00:02:08,774
Which might make you all think, why would you want to learn from me,

30
00:02:08,812 --> 00:02:11,880
someone who's got it wrong so many times?

31
00:02:12,490 --> 00:02:15,794
One of my old mentors always said to me, it's failure

32
00:02:15,842 --> 00:02:19,218
that builds experience. You learn so much more in failure

33
00:02:19,314 --> 00:02:22,938
than you do in success. So that's why I'm here to walk you through today

34
00:02:23,024 --> 00:02:26,330
some practical tips and advice from things I've learned from

35
00:02:26,400 --> 00:02:28,940
building event driven systems in the real world.

36
00:02:29,550 --> 00:02:32,826
Now, if any of you have seen me talk before,

37
00:02:33,008 --> 00:02:36,954
you'll know that there's one thing I love talking about almost as much as serverless

38
00:02:37,002 --> 00:02:39,534
and event driven architecture. And that is, of course,

39
00:02:39,652 --> 00:02:43,198
pizza. And for the rest of this talk, you all have a

40
00:02:43,204 --> 00:02:47,550
task. You all need to put on your imagination hats, because you're now developers

41
00:02:47,630 --> 00:02:51,326
working for a completely fictional pizza delivery company called Plant

42
00:02:51,358 --> 00:02:54,754
based Pizza. And you're going to introduce an event

43
00:02:54,792 --> 00:02:58,866
driven architecture to the plant based pizza system you've already adopted

44
00:02:58,898 --> 00:03:02,982
microservices, and all your interservice communication right now happens

45
00:03:03,036 --> 00:03:06,546
using HTTP APIs. And this is your architecture

46
00:03:06,578 --> 00:03:09,878
today. As you can see, all of the services need to

47
00:03:09,884 --> 00:03:13,526
know where all of the other services are. The order processing

48
00:03:13,558 --> 00:03:17,082
service is at the core of your system. This is your core domain. If people

49
00:03:17,136 --> 00:03:20,586
can't order pizzas, then you don't really have a business as

50
00:03:20,608 --> 00:03:24,474
a pizza delivery company. It has really explicit dependencies

51
00:03:24,522 --> 00:03:27,486
to the kitchen, the pickup and the delivery service.

52
00:03:27,668 --> 00:03:31,886
And now you also need to add a new service, a loyalty point service.

53
00:03:32,068 --> 00:03:35,486
And the order service needs to know where all of

54
00:03:35,508 --> 00:03:37,730
these services are at runtime.

55
00:03:38,390 --> 00:03:41,954
And this is of course a form of coupling. And I'm sure you've all heard

56
00:03:41,992 --> 00:03:45,954
the general rule of thumb in software design to aim for low coupling and

57
00:03:45,992 --> 00:03:49,302
high cohesion. And cohesion is a relatively straightforward one.

58
00:03:49,356 --> 00:03:52,614
Things that change together should live together, and you've already got

59
00:03:52,652 --> 00:03:55,862
that in your microservices architecture. You've broken your system

60
00:03:55,916 --> 00:03:59,386
down into these small, independently deployable units that are all

61
00:03:59,408 --> 00:04:02,860
focused on one job and doing that one job really, really well.

62
00:04:03,390 --> 00:04:07,318
Coupling is a little bit more nuanced, however, and that's

63
00:04:07,334 --> 00:04:10,854
because there's many different types of coupling. You've got technology coupling.

64
00:04:10,902 --> 00:04:14,814
Are you using Java net C plus plus rust? You've got

65
00:04:14,852 --> 00:04:17,898
temporal location coupling, runtime coupling.

66
00:04:17,994 --> 00:04:21,114
What's the IP address of the service I need to talk to? What's its DNS

67
00:04:21,162 --> 00:04:24,862
name? You've got data format, semantic and data type

68
00:04:24,916 --> 00:04:28,990
coupling. Are you using binary JSOn protobuff, Ints strings?

69
00:04:29,070 --> 00:04:32,338
How do you handle null values? What casing are you using on

70
00:04:32,344 --> 00:04:36,520
your json payloads? And some of these are a lot more tricky than others.

71
00:04:37,050 --> 00:04:40,694
Primarily HTTP communication is dealing with

72
00:04:40,732 --> 00:04:44,434
runtime and location coupling. At runtime,

73
00:04:44,562 --> 00:04:48,086
your services need to know the location of all the other services that

74
00:04:48,108 --> 00:04:51,714
they need to communicate with. And coupling isn't necessarily

75
00:04:51,762 --> 00:04:55,222
a bad thing, it's just something that you need to deal with. Without coupling,

76
00:04:55,286 --> 00:04:58,586
it would be really hard to get things done. And I really like this

77
00:04:58,608 --> 00:05:02,698
quote from Gregor Hopi. The appropriate level of coupling depends

78
00:05:02,714 --> 00:05:05,790
on the level of control you have over the endpoints.

79
00:05:06,210 --> 00:05:09,694
And what I think Gregor means there is that if you're a team

80
00:05:09,812 --> 00:05:13,854
building three or four different microservices, coupling them

81
00:05:13,892 --> 00:05:17,842
services together more tightly isn't necessarily a bad idea because you control

82
00:05:17,896 --> 00:05:21,326
the release cycles, the SLAs, the schemas, the deployments.

83
00:05:21,518 --> 00:05:24,914
But once you start integrating with something outside of your control,

84
00:05:25,032 --> 00:05:28,566
that might be a third party API, that might be another team inside your

85
00:05:28,588 --> 00:05:32,470
organization, you want to reduce that coupling as much

86
00:05:32,540 --> 00:05:36,214
AWS possible. So if it's coupling that we're working with

87
00:05:36,252 --> 00:05:39,894
here, why does it help to be event driven? What does that actually give you?

88
00:05:39,932 --> 00:05:43,174
What benefits does that have? Because let's

89
00:05:43,222 --> 00:05:46,582
have a look at the challenges you face with your current microservices architecture.

90
00:05:46,646 --> 00:05:50,220
As of right now, you need to create your new loyalty point service.

91
00:05:50,590 --> 00:05:53,606
But then to do that, you also need to make changes to your order processing

92
00:05:53,638 --> 00:05:57,726
service. And it's becoming really frustrating because every time you need to make a change,

93
00:05:57,908 --> 00:06:00,746
you need to then go back and also make a change to the order processing

94
00:06:00,778 --> 00:06:04,218
service. And actually, when you think about this, should the

95
00:06:04,244 --> 00:06:07,906
order processing service even care about the fact that people are

96
00:06:07,928 --> 00:06:11,940
collecting loyalty points? Is it the job of the order processing service?

97
00:06:12,390 --> 00:06:16,478
The answer to that is probably not because of this coupling.

98
00:06:16,574 --> 00:06:19,986
A failure in your loyalty point service, something that isn't on the critical

99
00:06:20,018 --> 00:06:23,638
path of your system functionality can also cause the knock on effect

100
00:06:23,804 --> 00:06:27,346
of taking other services offline. So now if your loyalty

101
00:06:27,378 --> 00:06:30,774
service fails, you could also then lose the ability to collect orders.

102
00:06:30,902 --> 00:06:34,074
Probably not something you want to do now.

103
00:06:34,112 --> 00:06:37,274
Of course, I realize I'm oversimplifying this massively. There are ways

104
00:06:37,312 --> 00:06:40,378
you can build microservices that handle all of these problems.

105
00:06:40,544 --> 00:06:43,762
Circuit breakers, backoffs, proper error handling.

106
00:06:43,926 --> 00:06:47,326
Just because you are building microservices in this way doesn't mean

107
00:06:47,348 --> 00:06:51,214
that your system is immediately going to be unstable. So if that is

108
00:06:51,252 --> 00:06:54,766
why you might want to be event driven, what does it actually mean to

109
00:06:54,788 --> 00:06:58,146
be event driven? The most succinct way I've seen of

110
00:06:58,168 --> 00:07:01,634
putting this is from one of Martin Fowler's talks on this topic about

111
00:07:01,672 --> 00:07:05,486
event driven architecture. At its core, event driven architecture

112
00:07:05,518 --> 00:07:08,886
is about reversing dependencies, about reversing all of

113
00:07:08,908 --> 00:07:12,246
these lines of integration. Now, your order service doesn't need to

114
00:07:12,268 --> 00:07:15,894
know anything about any other service consuming from it.

115
00:07:16,012 --> 00:07:19,074
And by the end of this talk, you're going to have made this entire flow

116
00:07:19,122 --> 00:07:22,666
event driven. But first, let's get a little bit theoretical for

117
00:07:22,688 --> 00:07:25,786
a moment. And I promise this theoretical bit won't take long

118
00:07:25,968 --> 00:07:29,158
and just level set on some of the key ideas in event driven

119
00:07:29,174 --> 00:07:32,430
architecture, the most fundamental, of course, what is

120
00:07:32,500 --> 00:07:36,954
an event? In my mind, an event is an immutable

121
00:07:37,082 --> 00:07:40,794
fact. It's something that's happened in the past. It cannot be changed.

122
00:07:40,842 --> 00:07:43,934
It has happened. The example I like to use here is that of a

123
00:07:43,972 --> 00:07:46,766
light switch. If you walk into a room in the middle of the night and

124
00:07:46,788 --> 00:07:49,806
you want to avoid all the Lego blicks that your kids have left all over

125
00:07:49,828 --> 00:07:52,686
the floor so you don't hurt your feet. So you want to turn on the

126
00:07:52,708 --> 00:07:54,638
light, you want to be able to see where you're going. So you hit the

127
00:07:54,644 --> 00:07:57,670
lights switch and that's going to raise a light switched on

128
00:07:57,740 --> 00:08:01,602
event. And at that moment in time it is impossible to unswitch

129
00:08:01,666 --> 00:08:05,366
on the light. You can't unswitched it on. The only

130
00:08:05,388 --> 00:08:09,026
way to remove the light from the room and run the gauntlet of Lego

131
00:08:09,058 --> 00:08:12,614
bricks on the floor is to hit the light switch again, which will then raise

132
00:08:12,662 --> 00:08:16,506
a light switched off. Light switched on, light switched off.

133
00:08:16,528 --> 00:08:19,210
Then things happen. They can't be changed. It's immutable.

134
00:08:19,710 --> 00:08:22,670
So if that's the definition of an event, what does it mean to be event

135
00:08:22,740 --> 00:08:26,174
driven? And I actually think there's some confusion here sometimes between

136
00:08:26,212 --> 00:08:29,678
event driven systems and what I'm starting to call event based

137
00:08:29,764 --> 00:08:33,554
systems. And there's an important distinction here. Both types of

138
00:08:33,592 --> 00:08:37,026
systems trigger functionality using events, but in

139
00:08:37,048 --> 00:08:41,234
an event driven system, events are business

140
00:08:41,352 --> 00:08:45,250
events. An event driven system triggers your business

141
00:08:45,320 --> 00:08:47,878
functionality from events that are related to your business.

142
00:08:48,044 --> 00:08:51,494
Triggering functionality in software with events is not

143
00:08:51,532 --> 00:08:55,042
a new thing. I'm a. Net developer. I started building with windows

144
00:08:55,106 --> 00:08:58,914
forms and in windows forms and net you can actually trigger

145
00:08:58,962 --> 00:09:02,438
functionality on button clicked events, mouse hovered,

146
00:09:02,534 --> 00:09:06,262
window resized. All of these things are events.

147
00:09:06,406 --> 00:09:09,866
That doesn't mean you're building an event driven system. And you can even apply this

148
00:09:09,888 --> 00:09:14,126
to cloud native ways of building things. If you're using Amazon s three, for example,

149
00:09:14,308 --> 00:09:17,514
that when you drop a file into an S three bucket, that will raise

150
00:09:17,562 --> 00:09:20,986
an S three object created event. But that's

151
00:09:21,018 --> 00:09:25,134
a technical event, not a business event. Business events are things

152
00:09:25,172 --> 00:09:29,426
like pizza boxed or replaced. Staff member clocked in.

153
00:09:29,608 --> 00:09:32,734
You could look at two businesses in the exact same domain,

154
00:09:32,782 --> 00:09:36,566
two different pizza restaurants, both building event driven systems. And they will have

155
00:09:36,588 --> 00:09:39,766
a completely different set of events because they have

156
00:09:39,788 --> 00:09:42,854
different terminology, a different language. Now,

157
00:09:42,892 --> 00:09:46,438
they might have similarities in the things that are event based.

158
00:09:46,524 --> 00:09:49,894
Button clicked s three object created. And this

159
00:09:49,932 --> 00:09:53,210
comes back to the idea of stories of the words you use in your business.

160
00:09:53,280 --> 00:09:56,346
An event driven architecture lets you tell the story of

161
00:09:56,368 --> 00:09:59,770
your business through its technical implementation.

162
00:10:00,670 --> 00:10:04,186
So another thing you'll commonly hear when you start learning about event driven architecture

163
00:10:04,218 --> 00:10:07,838
is that events are first class citizens. And that might make you

164
00:10:08,004 --> 00:10:11,774
huh, what does that mean? Well,

165
00:10:11,812 --> 00:10:15,774
as well as these events being based on your business events, you should

166
00:10:15,812 --> 00:10:19,486
also treat your events like an API. I'm sure many of you listening

167
00:10:19,518 --> 00:10:23,202
are familiar with the idea of API first design, the idea

168
00:10:23,256 --> 00:10:26,434
of API first design, if you're not, is that the first thing you do when

169
00:10:26,472 --> 00:10:30,054
building a system is to design its API. And then when it comes

170
00:10:30,092 --> 00:10:33,218
to integrating things together, you have an agreed contract that everyone's

171
00:10:33,234 --> 00:10:37,062
aware of. So making events first class citizens means

172
00:10:37,116 --> 00:10:41,174
focusing on event first design. Your event schema

173
00:10:41,302 --> 00:10:44,934
is your API in event driven systems. It's the language

174
00:10:44,982 --> 00:10:48,602
your services use to talk to each other. So when you're thinking

175
00:10:48,656 --> 00:10:52,074
about events and the schema of them events, it's not as simple as just

176
00:10:52,112 --> 00:10:56,346
starting to fling JSon round all over the place. There are different types

177
00:10:56,378 --> 00:10:59,966
of events that you might see, and it's important to

178
00:11:00,068 --> 00:11:03,854
really think this through carefully, because how you structure your

179
00:11:03,892 --> 00:11:07,234
events can be a deal breaker for the success of your system

180
00:11:07,272 --> 00:11:09,838
over time. Remember, the events are your API.

181
00:11:10,014 --> 00:11:13,854
The first type of event you'll commonly encounter are notification events

182
00:11:13,902 --> 00:11:17,986
or sparse events. These are really simple, small packages of

183
00:11:18,008 --> 00:11:21,334
data that simply notify another system that something has

184
00:11:21,372 --> 00:11:24,722
happened. And this is where you start with your first implementation

185
00:11:24,786 --> 00:11:28,166
of event driven architecture at plant based pizza. Let's zoom in

186
00:11:28,188 --> 00:11:31,270
on that implementation. The integration between the order processing service

187
00:11:31,340 --> 00:11:35,114
and the kitchen service. So now your order service is just publishing an

188
00:11:35,152 --> 00:11:38,554
order confirmed event and the kitchen service is listening for that event. And it says,

189
00:11:38,592 --> 00:11:42,858
thank you very much. I know that this order has been confirmed, order 1234.

190
00:11:43,024 --> 00:11:46,686
And then it thinks, I don't actually know what I

191
00:11:46,708 --> 00:11:50,334
need to create. I don't actually know what pizzas people have ordered. All I

192
00:11:50,372 --> 00:11:53,406
have is this order confirmed event with an order ID. So what I'm going to

193
00:11:53,428 --> 00:11:56,194
do is I'm going to call back, I'm going to reach back to the order

194
00:11:56,232 --> 00:11:59,666
processing service, to the API. It's exposed and I'm going to

195
00:11:59,688 --> 00:12:03,054
grab the order details. And at this point you might celebrate,

196
00:12:03,102 --> 00:12:06,322
because now you're event driven, right? But ask yourself,

197
00:12:06,376 --> 00:12:10,402
is this actually any better? You're still coupled, you're still dependent.

198
00:12:10,546 --> 00:12:14,118
And now actually your order service needs to handle all this, Lord, from all

199
00:12:14,124 --> 00:12:17,746
these different places. This is a pattern I've built before and I've

200
00:12:17,778 --> 00:12:20,982
done exactly this. And it was wonderful to begin with.

201
00:12:21,116 --> 00:12:24,986
And then there was another subscriber to the order service, to the order confirmed event,

202
00:12:25,088 --> 00:12:28,266
and then three more, and then another one, and then a few more, and then

203
00:12:28,288 --> 00:12:31,722
maybe just some more. And then eventually what happens is that your order processing service

204
00:12:31,776 --> 00:12:35,274
sets on fire because it can't deal with all this, Lord,

205
00:12:35,402 --> 00:12:39,306
coming from all these other places. A core principle of event driven architecture

206
00:12:39,418 --> 00:12:43,018
is that services are unaware of the downstream consumers

207
00:12:43,034 --> 00:12:47,070
of their events. So whilst this pattern works from a functional perspective,

208
00:12:47,230 --> 00:12:50,830
you open your producer up to receiving potentially infinite

209
00:12:50,910 --> 00:12:54,498
numbers of events from other systems. So is there a

210
00:12:54,504 --> 00:12:58,098
better way? Is there another option? And this leads us nicely onto the

211
00:12:58,104 --> 00:13:01,846
second type of event, and that is event carriage state transfer, or also what

212
00:13:01,868 --> 00:13:05,094
is known as a more fat event. And let's actually

213
00:13:05,132 --> 00:13:09,094
take an example here. This is the net representation of the

214
00:13:09,132 --> 00:13:12,170
notification event. And for any of you non net developers out there,

215
00:13:12,240 --> 00:13:16,326
I've also got a json version. So imagine this as your notification

216
00:13:16,438 --> 00:13:20,154
event. It's an order confirmed event that simply includes the order ID.

217
00:13:20,352 --> 00:13:23,902
And this is what that same event might look like as event carried state

218
00:13:23,956 --> 00:13:27,326
transfer or as a more fat event. And what you see is

219
00:13:27,348 --> 00:13:30,622
that the state of the order is carried as part

220
00:13:30,676 --> 00:13:34,766
of the event payload. This means that any consuming service has

221
00:13:34,788 --> 00:13:38,334
all the data it needs to actually create the order. The kitchen

222
00:13:38,382 --> 00:13:42,130
service in this case knows that it needs to create lots of margarita pizzas.

223
00:13:42,550 --> 00:13:45,294
Now that you understand these different types of events,

224
00:13:45,422 --> 00:13:48,520
you might be wondering which is the right one to pick.

225
00:13:49,050 --> 00:13:52,630
Hold that thought, we're going to stay theoretical just for a few minutes longer.

226
00:13:52,780 --> 00:13:56,438
This is the simplest structure of an event driven system,

227
00:13:56,604 --> 00:14:00,838
primarily made up of three different parts. An event producer,

228
00:14:00,934 --> 00:14:04,790
a central broker of some kind, and then some kind of event consumer.

229
00:14:04,950 --> 00:14:08,106
And these events are typically passed around

230
00:14:08,288 --> 00:14:12,074
using an event broker, but also queues and topics and

231
00:14:12,112 --> 00:14:15,214
streams. And what you're immediately going to notice with this is that

232
00:14:15,252 --> 00:14:19,162
the producer and consumer have no idea that each other exists.

233
00:14:19,306 --> 00:14:21,802
They aren't communicating with each other directly,

234
00:14:21,946 --> 00:14:25,602
which almost immediately reduces your runtime coupling and

235
00:14:25,656 --> 00:14:28,686
completely removes your location coupling.

236
00:14:28,878 --> 00:14:33,102
Communication is asynchronous. First, and the primary integration

237
00:14:33,166 --> 00:14:36,550
pattern at play here is the publish subscribe pattern.

238
00:14:36,890 --> 00:14:40,166
Of course, not all coupling is removed. As you've just

239
00:14:40,188 --> 00:14:43,910
learned, your event schema is the contract you agree on.

240
00:14:43,980 --> 00:14:47,526
So you've got semantic coupling at the level of

241
00:14:47,548 --> 00:14:50,758
the event schema. And this is the largest amount of coupling you're typically going

242
00:14:50,764 --> 00:14:53,386
to see in an event driven architecture. Which is why you need to be so

243
00:14:53,408 --> 00:14:55,930
careful with how you design your schemas.

244
00:14:56,590 --> 00:15:00,134
As a producer or a publisher, you have some responsibilities,

245
00:15:00,182 --> 00:15:03,822
and the biggest responsibility you have is to agree and stay

246
00:15:03,876 --> 00:15:07,374
consistent to that agreed event schema. Don't just be changing things

247
00:15:07,412 --> 00:15:11,114
willy nilly and you want to ensure that you keep backwards

248
00:15:11,162 --> 00:15:15,114
compatibility wherever possible. What you're not responsible

249
00:15:15,162 --> 00:15:19,074
for is how your events are used. You don't care, you're just publishing this

250
00:15:19,112 --> 00:15:22,174
event out to the world. And the other thing you're

251
00:15:22,222 --> 00:15:25,874
not responsible for, which is particularly interesting when compared with

252
00:15:25,912 --> 00:15:28,934
HTTP communication, is that you don't now

253
00:15:28,972 --> 00:15:32,742
need to care about the constraints of the system you're integrating with.

254
00:15:32,876 --> 00:15:35,874
If you think about building things with HTTP APIs,

255
00:15:36,002 --> 00:15:39,686
you need to care about the authentication for that

256
00:15:39,708 --> 00:15:43,094
API, you need to care about the rate limits, its throughput, how much load

257
00:15:43,142 --> 00:15:47,050
can it deal with over time, what the requests per second. Whereas now

258
00:15:47,120 --> 00:15:50,054
when you're building an event driven system, you don't need to worry about that.

259
00:15:50,112 --> 00:15:54,810
That responsibility shifts to the responsibility of the subscriber.

260
00:15:54,970 --> 00:15:59,066
As a subscriber, you're now in charge of controlling

261
00:15:59,098 --> 00:16:02,430
the load on your own system, and it's a much more logical

262
00:16:02,770 --> 00:16:06,678
way of things being controlled. You control the Lord

263
00:16:06,714 --> 00:16:10,754
on your own system. One of the challenges with this though, is that you can

264
00:16:10,792 --> 00:16:14,062
still overload your system as a consumer. If one of the upstream

265
00:16:14,126 --> 00:16:17,262
producers suddenly starts publishing 100 times,

266
00:16:17,336 --> 00:16:20,486
200 times more events, that's still

267
00:16:20,508 --> 00:16:24,518
going to overload your system. And a pattern that can help here is

268
00:16:24,604 --> 00:16:28,054
using some kind of queue, some kind of durable storage at the

269
00:16:28,092 --> 00:16:32,314
boundary of your system. So instead of subscribing your

270
00:16:32,352 --> 00:16:35,610
subscriber directly to the event bus, you might instead

271
00:16:35,680 --> 00:16:39,050
subscribe a queue to the event bus. And that means when that 100 times,

272
00:16:39,120 --> 00:16:42,618
200 times Lord comes through the system, it's all going to build up in

273
00:16:42,624 --> 00:16:46,202
the queue. And that protects your system. It acts as a buffer

274
00:16:46,346 --> 00:16:49,566
against your system and you can then work off that queue as and when you

275
00:16:49,588 --> 00:16:53,038
need to. This functions much like an anticorruption layer. It allows you

276
00:16:53,044 --> 00:16:56,814
to validate the schema of the events coming in and generally just be more defensive

277
00:16:56,942 --> 00:17:00,420
with your programming without risking losing or dropping data.

278
00:17:01,350 --> 00:17:05,150
There's another really interesting and slightly more subtle benefit with event driven architecture,

279
00:17:05,230 --> 00:17:08,966
and that's based on the fact that EDAs are built using business

280
00:17:09,068 --> 00:17:12,326
events. Now I'm sure any of you who've worked in software for

281
00:17:12,348 --> 00:17:15,538
any amount of time have had problems with communication.

282
00:17:15,714 --> 00:17:19,498
You've been talking to a business expert in your organization, and as

283
00:17:19,504 --> 00:17:22,634
soon as you mention the word HTTP, microservice or

284
00:17:22,672 --> 00:17:26,570
service, they instantly shut down. But when system

285
00:17:26,640 --> 00:17:29,962
functionality is driven by events, you're now using

286
00:17:30,016 --> 00:17:33,374
a language that's familiar to business people. I could go and have a

287
00:17:33,412 --> 00:17:37,246
conversation with a business expert and ask them what should happen after an

288
00:17:37,268 --> 00:17:41,114
order gets canceled, and then you can map that exact language

289
00:17:41,242 --> 00:17:45,186
into your actual system. In much the same way, domain driven design gave

290
00:17:45,208 --> 00:17:49,074
us a ubiquitous language. We're now taking this one step further and having

291
00:17:49,112 --> 00:17:52,642
that language drive business functionality. Because remember,

292
00:17:52,696 --> 00:17:56,626
event driven architecture is fundamentally a communication pattern, a way of modeling

293
00:17:56,658 --> 00:17:59,846
the integration between your systems. Now,

294
00:17:59,868 --> 00:18:03,254
one of the commonly touted benefits of event driven architecture is

295
00:18:03,292 --> 00:18:07,078
evolvability. Having this central stream of events that

296
00:18:07,164 --> 00:18:10,954
any consumer can hook into and that allows you to add and remove services

297
00:18:11,072 --> 00:18:14,442
without affecting other parts of your architecture is wonderful. It sounds

298
00:18:14,496 --> 00:18:17,100
great, sounds like a nirvana of software design,

299
00:18:17,550 --> 00:18:21,146
but you can get yourself in some trouble here. And this comes back to

300
00:18:21,168 --> 00:18:24,782
this problem with schema design. Here's a very similar

301
00:18:24,836 --> 00:18:28,334
problem to something that I've encountered in my career. Here's an event that I was

302
00:18:28,372 --> 00:18:31,982
publishing and what happens now? If you need to change

303
00:18:32,036 --> 00:18:35,198
the schema of this event, and this is what you need to do in

304
00:18:35,204 --> 00:18:38,514
plant based pizza, you've gone multi currency, it's blowing up,

305
00:18:38,552 --> 00:18:41,998
people love your pizzas and you've gone global. So you now need to start including

306
00:18:42,014 --> 00:18:46,146
the currency as part of the order value in your order confirmed event.

307
00:18:46,248 --> 00:18:49,990
So what you do is you just update the event. You change the value property

308
00:18:50,060 --> 00:18:53,846
to be a value. And the currency, it's now an object, because it's only

309
00:18:53,868 --> 00:18:56,934
the kitchen service that cares about this event.

310
00:18:57,052 --> 00:19:00,154
Nobody else really cares about that. And then

311
00:19:00,192 --> 00:19:03,834
you realize that somebody had added an analytics service,

312
00:19:03,952 --> 00:19:07,786
and that analytics service is very, very interested in

313
00:19:07,808 --> 00:19:11,162
that order value property. And now by making this breaking change,

314
00:19:11,216 --> 00:19:14,718
you've just broken a system that you didn't even know

315
00:19:14,804 --> 00:19:18,880
existed, which doesn't sound particularly evolvable to me.

316
00:19:19,410 --> 00:19:23,022
And this is one of the challenges you'll face. With these fatter, more event

317
00:19:23,076 --> 00:19:26,398
carried state transfer type events. You reduce the need for

318
00:19:26,404 --> 00:19:29,714
a consumer to call back, fantastic. But now

319
00:19:29,752 --> 00:19:32,946
you're coupled at a schema level, and this will definitely lead you to be

320
00:19:32,968 --> 00:19:36,386
asking the question, what the heck do I do now? And I'm going to put

321
00:19:36,408 --> 00:19:39,630
a word on the screen now, and this word is going to

322
00:19:39,640 --> 00:19:42,358
give you all the shivers. You're all going to get a bit tingly, you're going

323
00:19:42,364 --> 00:19:46,274
to feel awful. It's a really naughty word. Please stick

324
00:19:46,322 --> 00:19:50,026
with me. I promise it won't be on the screen for long. That word

325
00:19:50,048 --> 00:19:53,414
is governance. Yeah, boring, horrible,

326
00:19:53,462 --> 00:19:56,950
right? It gives you all feelings of red tape and bureaucracy.

327
00:19:57,030 --> 00:20:00,550
But governance is really important in event driven systems.

328
00:20:00,630 --> 00:20:04,302
And this doesn't need to be painful. There doesn't need to be bureaucracy and red

329
00:20:04,356 --> 00:20:07,662
tape. You can simply use a process that I'm sure

330
00:20:07,716 --> 00:20:10,922
many of you are familiar with, and that's the process of the RFC,

331
00:20:10,986 --> 00:20:14,394
or the request for comment whenever you want. To make a breaking

332
00:20:14,442 --> 00:20:17,998
change to your events, you simply introduce an RFC

333
00:20:18,174 --> 00:20:21,682
and then you get the input of other key stakeholders in your business.

334
00:20:21,736 --> 00:20:25,026
And you can do this completely asynchronously. All your teams can

335
00:20:25,048 --> 00:20:28,754
stay decoupled, but you're still keeping an element of collaboration

336
00:20:28,802 --> 00:20:32,680
and knowledge sharing. Once you've gone through the RFC process,

337
00:20:33,050 --> 00:20:36,806
then you can actually manage this at a technical level as well.

338
00:20:36,988 --> 00:20:40,250
You can introduce a pattern like the metadata data

339
00:20:40,320 --> 00:20:43,450
pattern. You break your event payload into

340
00:20:43,520 --> 00:20:47,926
two separate parts. You have a really clearly defined schema.

341
00:20:48,118 --> 00:20:51,770
An alternate approach to metadata data is to use the cloud

342
00:20:51,840 --> 00:20:55,102
events specification. The cloud event specification is a really

343
00:20:55,156 --> 00:20:59,278
formal defined specification for communicating between

344
00:20:59,364 --> 00:21:03,038
different systems and event driven architectures. And what makes this really powerful is some

345
00:21:03,044 --> 00:21:06,546
of these metadata fields that get included. You'll notice I've got

346
00:21:06,568 --> 00:21:09,778
a type and a source, an event ID,

347
00:21:09,864 --> 00:21:13,218
a uniquely generated event identifier that's generated at

348
00:21:13,224 --> 00:21:16,686
the point of publish to then allow downstream consumers

349
00:21:16,718 --> 00:21:20,630
to implement things like item potency to understand if it's seen an event before.

350
00:21:20,780 --> 00:21:24,630
You've also got the time, you've got the actual data, the actual event

351
00:21:24,700 --> 00:21:28,454
payload, and one of the most important properties in here

352
00:21:28,572 --> 00:21:31,914
is the version having a version number

353
00:21:31,952 --> 00:21:36,246
in your events. The ability to version things is vital

354
00:21:36,438 --> 00:21:39,386
as you start building event driven systems. And let's have a look what this could

355
00:21:39,408 --> 00:21:43,034
look like in practice. Right now your order processing service is publishing version

356
00:21:43,082 --> 00:21:46,734
one of your order confirmed event. And when the kitchen service defined its

357
00:21:46,772 --> 00:21:49,598
subscription, it subscribed to version one,

358
00:21:49,684 --> 00:21:53,278
specifically of the order confirmed event. And then when you need to make the

359
00:21:53,284 --> 00:21:56,734
breaking change, you'll start publishing version two of the order confirmed event.

360
00:21:56,772 --> 00:22:00,386
And notice you are still also publishing version one. So at this

361
00:22:00,408 --> 00:22:04,094
moment in time you're publishing version two. And version two is incredibly sad and upset

362
00:22:04,142 --> 00:22:07,426
because there's no one actually listening to it. You can then

363
00:22:07,448 --> 00:22:10,262
put out a message to the rest of your organization saying hey everybody,

364
00:22:10,396 --> 00:22:14,658
can you switch over to version two? And over time all of your downstream consumers

365
00:22:14,674 --> 00:22:18,166
are going to switch over and start working with version two of the

366
00:22:18,188 --> 00:22:21,798
event. Eventually you can then turn off version one.

367
00:22:21,884 --> 00:22:25,066
And that brings us back to the question, fat versus spice events. Which one is

368
00:22:25,088 --> 00:22:28,682
the one to use? And of course this is a software conference, so the answer

369
00:22:28,736 --> 00:22:32,106
to this is always, it depends. Personally,

370
00:22:32,138 --> 00:22:36,014
I've gone backwards and forwards with this argument so many times in my own

371
00:22:36,052 --> 00:22:39,946
head. Fatter events, combined with some kind of metadata

372
00:22:39,978 --> 00:22:44,074
pattern that allows versioning, really eases the evolvability.

373
00:22:44,202 --> 00:22:47,666
It reduces coupling and it also removes the need for

374
00:22:47,688 --> 00:22:50,834
a callback. What it does give you, however, is really

375
00:22:50,872 --> 00:22:54,926
tight coupling at the schema level. You need to be really careful whenever

376
00:22:54,958 --> 00:22:58,366
you introduce breaking changes, and without the right governance and versioning

377
00:22:58,398 --> 00:23:01,606
in place, that can cause you problems over time, which then might make

378
00:23:01,628 --> 00:23:05,890
you think, well, long live the sparse event. Only ever publish sparse events.

379
00:23:06,050 --> 00:23:09,274
And honestly, even as I think about this now, my opinion on this starts to

380
00:23:09,312 --> 00:23:12,506
change. To take this sparse event idea to

381
00:23:12,528 --> 00:23:15,958
its absolute extreme, you could publish events

382
00:23:15,974 --> 00:23:19,258
that only ever include identifiers, and you

383
00:23:19,264 --> 00:23:23,070
maybe only add additional properties as and when additional people

384
00:23:23,140 --> 00:23:26,446
ask for them. Remember, one of the core principles of

385
00:23:26,468 --> 00:23:29,582
microservice is that each service owns its own data.

386
00:23:29,716 --> 00:23:33,310
So just publishing identifiers allows each service to stay in control

387
00:23:33,380 --> 00:23:36,994
of its own data, and this gives you the purest amount of

388
00:23:37,032 --> 00:23:40,834
looser coupling. If you never allow services to call

389
00:23:40,872 --> 00:23:44,434
back and gather more data, it forces the rest of your system to act

390
00:23:44,472 --> 00:23:47,922
in a really specific way. However, this is

391
00:23:47,976 --> 00:23:51,542
a pretty impractical approach. You're almost always

392
00:23:51,596 --> 00:23:54,854
going to run into some kind of issues if you try and stick to this

393
00:23:54,892 --> 00:23:58,002
rigid sparse event where you only ever include identifier.

394
00:23:58,146 --> 00:24:01,862
However, an additional option I've been exploring is actually to still only include

395
00:24:01,926 --> 00:24:06,278
identifiers, but include a wider range of identifiers.

396
00:24:06,454 --> 00:24:10,086
So as well as publishing the order ID, which is something that the order processing

397
00:24:10,118 --> 00:24:14,010
service owns, you also publish the customer ID and the delivery address

398
00:24:14,080 --> 00:24:17,466
ID. And if you think about this from a logical perspective, as I'm

399
00:24:17,498 --> 00:24:20,638
on my phone trying to order my pizza, the first thing I'm going to do

400
00:24:20,644 --> 00:24:23,966
is I'm going to add my delivery address. And then when I actually come to

401
00:24:23,988 --> 00:24:27,746
submit my order, I'm going to select the delivery address that I want to

402
00:24:27,768 --> 00:24:31,298
use. That means that the order service is going to receive the ID

403
00:24:31,384 --> 00:24:34,626
for my delivery address. I can publish that as part of the

404
00:24:34,648 --> 00:24:38,150
event payload, and then my delivery service now knows which

405
00:24:38,220 --> 00:24:42,550
delivery address to deliver this order to. The really

406
00:24:42,620 --> 00:24:46,134
key takeaway here, talking about evolvability, is to

407
00:24:46,172 --> 00:24:50,050
embrace that metadata data pattern. Be incredibly intentional

408
00:24:50,130 --> 00:24:53,466
about how you structure your events. Now, as you've seen

409
00:24:53,488 --> 00:24:56,138
over these last few diagrams, one of the big things you'll need to embrace with

410
00:24:56,144 --> 00:24:59,814
Eventdriven architecture is that your systems are going to be asynchronous.

411
00:24:59,942 --> 00:25:03,478
You need to think about every part of your system interacting in an

412
00:25:03,504 --> 00:25:06,986
asynchronous way. And if you're a developer who's used to making method

413
00:25:07,018 --> 00:25:10,814
calls or HTTP calls, and then waiting for that call to return,

414
00:25:11,012 --> 00:25:14,026
this can be a bit of a paradigm shift.

415
00:25:14,218 --> 00:25:18,610
Although I really struggled with this when I started building event driven systems.

416
00:25:19,030 --> 00:25:22,802
Now your service is doing a piece of work, maybe storing some data,

417
00:25:22,856 --> 00:25:26,382
and then it's just going to publish an event. And then maybe sometime,

418
00:25:26,446 --> 00:25:29,942
potentially, possibly later, your service is going to receive that event

419
00:25:29,996 --> 00:25:33,318
back. Let's think about this same flow again. The order processing service publishes an

420
00:25:33,324 --> 00:25:36,338
order confirmed event and some point somewhere,

421
00:25:36,434 --> 00:25:39,542
hopefully, eventually, it's going to receive an order cooked event

422
00:25:39,596 --> 00:25:42,946
when the kitchen has finished doing its work. But you might not.

423
00:25:42,988 --> 00:25:45,162
There's no way to know if that event is ever going to come back.

424
00:25:45,216 --> 00:25:48,774
Frankly, there's no way to know if the kitchen ever even receives

425
00:25:48,822 --> 00:25:52,350
that order confirmed event. And this can lead to a challenge around

426
00:25:52,420 --> 00:25:56,206
consistency. Asynchronous systems naturally lead you to need to

427
00:25:56,228 --> 00:25:59,754
embrace eventual consistency. And there's two types of consistency.

428
00:25:59,802 --> 00:26:03,018
There's strong consistency and eventual consistency.

429
00:26:03,194 --> 00:26:06,834
And I want to explain this through the lens of the payment part of

430
00:26:06,872 --> 00:26:10,194
plant based pizza. And if it's close to a meal time for you now,

431
00:26:10,232 --> 00:26:13,394
I really apologize for this next few minutes because

432
00:26:13,432 --> 00:26:17,294
I want you to imagine that you've ordered your pizza and you've

433
00:26:17,342 --> 00:26:20,694
walked down to the pizza shop. You walk into the pizza store to pick your

434
00:26:20,732 --> 00:26:23,910
pizza up. You walk in, the smell hits you in the face.

435
00:26:23,980 --> 00:26:27,746
You can almost taste the pizza. You can see them being prepared

436
00:26:27,778 --> 00:26:31,802
behind the counter. You think you see your pizza being boxed up. You get super

437
00:26:31,856 --> 00:26:35,834
excited because it's almost time. But there's one thing you need to do before

438
00:26:35,872 --> 00:26:39,478
you can take that pizza away. You need to pay for your pizza.

439
00:26:39,654 --> 00:26:42,938
And you have two options at this point. The first option you have is to

440
00:26:42,944 --> 00:26:46,186
pay with cash. You can take out your purse or your wallet,

441
00:26:46,298 --> 00:26:49,646
take the money out, hand it over to the cashier, and the cashier will put

442
00:26:49,668 --> 00:26:53,306
that in the till. That's an example of a strongly consistent

443
00:26:53,338 --> 00:26:56,942
transaction. It's strongly consistent because you can absolutely guarantee

444
00:26:57,006 --> 00:27:00,974
at that moment in time that the money has changed hands, that transaction

445
00:27:01,022 --> 00:27:04,546
has happened. You open up your purse and there's no money in it.

446
00:27:04,728 --> 00:27:07,700
Alternatively, if you were to pay with your card,

447
00:27:08,390 --> 00:27:12,066
all you're doing when you pay for something with your credit card is that you're

448
00:27:12,098 --> 00:27:15,718
making a theoretical guarantee that at some point in the future

449
00:27:15,884 --> 00:27:19,382
the money is going to change hands. You might pay with your card,

450
00:27:19,436 --> 00:27:22,714
take your pizza, walk out, get back in your car, check your

451
00:27:22,752 --> 00:27:26,406
bank statement, and the pizza hasn't appeared on your bank statement.

452
00:27:26,438 --> 00:27:29,670
And now you're celebrating because you think you've got free pizza.

453
00:27:29,830 --> 00:27:33,274
Free pizza. That'll be wonderful. What you then realize is that

454
00:27:33,312 --> 00:27:36,734
eventually, of course, as you all know, that that transaction is going to come through

455
00:27:36,772 --> 00:27:40,206
eventually and it will eventually be displayed on

456
00:27:40,228 --> 00:27:44,026
your bank statement. This is an example of an eventually consistent transaction.

457
00:27:44,218 --> 00:27:48,194
Eventually, providing nothing else happens, all the different services in your

458
00:27:48,232 --> 00:27:51,518
system will converge on the same view of the world. But there's

459
00:27:51,534 --> 00:27:54,802
no way you can guarantee at any point in time that another service

460
00:27:54,856 --> 00:27:58,094
has seen a specific piece of data. And eventual

461
00:27:58,142 --> 00:28:01,666
consistency is one of the trade offs you make when you build eventor

462
00:28:01,698 --> 00:28:05,094
and systems. You can't solve for it, you simply need to

463
00:28:05,132 --> 00:28:08,754
embrace it and architect for it correctly. Because architecture

464
00:28:08,802 --> 00:28:11,498
is just balancing a whole bunch of different trade offs and this is one of

465
00:28:11,504 --> 00:28:14,762
the trade offs you make. Another thing that's really important

466
00:28:14,816 --> 00:28:18,314
with event driven systems is observability. When something goes wrong,

467
00:28:18,432 --> 00:28:21,020
how the heck do you work out what's gone wrong?

468
00:28:21,390 --> 00:28:24,698
And let's revisit one of them schema patterns from earlier. And I'm

469
00:28:24,714 --> 00:28:28,026
going to look at the metadata data version here. And what you'll notice I've

470
00:28:28,058 --> 00:28:31,770
done is introduced two additional properties to this structure,

471
00:28:31,850 --> 00:28:35,646
a trace ID and a span ID. I'm using open telemetry here

472
00:28:35,668 --> 00:28:38,514
and if you're not using open telemetry, this could be as simple as just a

473
00:28:38,552 --> 00:28:41,906
correlation ID. The important point is that you

474
00:28:41,928 --> 00:28:45,506
have a common piece of data that's passed through every single one

475
00:28:45,528 --> 00:28:49,010
of your services. And that way whether you're using distributed tracing

476
00:28:49,090 --> 00:28:52,646
or you're using structured logging, you can include the same piece

477
00:28:52,668 --> 00:28:55,686
of data and actually determine cause and effect.

478
00:28:55,868 --> 00:28:59,478
Cause and effect is really hard in event driven systems because producers

479
00:28:59,494 --> 00:29:03,462
just publish events and consumers maybe or maybe don't

480
00:29:03,526 --> 00:29:06,822
consume them. So you need to be able to really easily

481
00:29:06,886 --> 00:29:10,326
link these requests together. And doing this with trace IDs,

482
00:29:10,358 --> 00:29:13,614
span IDs or correlation IDs is a really helpful way

483
00:29:13,652 --> 00:29:17,054
of doing that. Another question I commonly get asked with event

484
00:29:17,092 --> 00:29:21,786
driven systems is what do I do at the boundaries of my system? Sometimes surely

485
00:29:21,978 --> 00:29:25,726
I'm going to need some synchronous communication. If you think about

486
00:29:25,748 --> 00:29:29,490
the front end to back end communication. If the back end is driven completely

487
00:29:29,560 --> 00:29:33,426
by events, what happens when my mobile client or my web client needs to

488
00:29:33,448 --> 00:29:37,982
actually communicate? And really you can't just have asynchronous communication

489
00:29:38,046 --> 00:29:42,546
everywhere. Somehow, somewhere you're going to need some kind of synchronous API

490
00:29:42,738 --> 00:29:46,086
and there are patterns that can help you here. I'm a really big fan of

491
00:29:46,108 --> 00:29:49,366
having these really thin APIs at the boundaries of a

492
00:29:49,388 --> 00:29:52,954
system. This API might perform a really small amount

493
00:29:52,992 --> 00:29:56,538
of validation when a request comes in, maybe stores some data in a

494
00:29:56,544 --> 00:29:59,580
database, and then actually publishes an event to an event bus.

495
00:30:00,190 --> 00:30:03,534
Commands are sent to your system, and then the crux of your

496
00:30:03,572 --> 00:30:07,534
business logic happens using events asynchronously. So now

497
00:30:07,572 --> 00:30:10,686
all of that meteor business logic, that can take a little bit longer to

498
00:30:10,708 --> 00:30:14,330
run, that can all be shifted and happen asynchronously.

499
00:30:14,490 --> 00:30:18,114
Now, I mentioned the word command and event there, so let's consider

500
00:30:18,312 --> 00:30:21,634
quickly the different types of messages that you might see, which are

501
00:30:21,672 --> 00:30:25,122
commands, events, and queries. Now the difference between a command and an event

502
00:30:25,256 --> 00:30:28,914
is mostly a statement of an intent, but they deliver

503
00:30:28,962 --> 00:30:32,774
a very similar outcome. I'm either asking a specific service to do some work,

504
00:30:32,892 --> 00:30:36,662
or I'm observing some functionality that has happened and I'm running

505
00:30:36,716 --> 00:30:39,978
some other functionality off the back of that. Commands are typically at the

506
00:30:39,984 --> 00:30:44,726
boundaries of your system, where it interacts with the external world API

507
00:30:44,758 --> 00:30:49,126
request coming in. Submit order aws an example events,

508
00:30:49,238 --> 00:30:52,806
then, at least in event of an architecture, are the first class citizens that

509
00:30:52,848 --> 00:30:56,606
drive the vast majority of your business logic. And then queries are

510
00:30:56,628 --> 00:30:59,822
mostly about reading data, reading a specific view of the world

511
00:30:59,876 --> 00:31:03,706
that's optimized for a specific use case for external

512
00:31:03,738 --> 00:31:07,486
clients to receive data, or your front end to display the status

513
00:31:07,518 --> 00:31:10,242
of your order as you furiously refresh the page,

514
00:31:10,296 --> 00:31:13,810
wondering where your pizza is. And it's important here to think that

515
00:31:13,880 --> 00:31:17,474
both commands and events can both run asynchronously. You can do

516
00:31:17,512 --> 00:31:21,538
asynchronous commands in an event driven system, much like you can asynchronous events.

517
00:31:21,714 --> 00:31:25,126
But let's pull all this together now to find out exactly how this

518
00:31:25,148 --> 00:31:28,118
can all work as events flow around your system.

519
00:31:28,284 --> 00:31:32,454
So imagine you get a submit order request that comes into your order API,

520
00:31:32,582 --> 00:31:36,634
your order API does some validation, does some work, and then it publishes an

521
00:31:36,672 --> 00:31:40,394
order confirmed event onto your event bus. At this

522
00:31:40,432 --> 00:31:43,674
point, the kitchen service is incredibly interested in that order confirmed event,

523
00:31:43,712 --> 00:31:47,262
and it grabs that to do some work. And you'll also notice that the order

524
00:31:47,316 --> 00:31:50,778
processing service is also interested in that order confirmed event, and it's

525
00:31:50,794 --> 00:31:54,254
using that to update a view of the world ready for any

526
00:31:54,292 --> 00:31:57,806
requests to come in from the front end. Once the kitchen has finished doing

527
00:31:57,828 --> 00:32:00,914
its work, it publishes an order prepared event, which the delivery service

528
00:32:00,952 --> 00:32:03,826
is then interested in to actually get the pizza and deliver it, but to the

529
00:32:03,848 --> 00:32:07,442
person who ordered it. Again, your order processing service is

530
00:32:07,496 --> 00:32:11,314
also interested in that order prepared event to update the status

531
00:32:11,362 --> 00:32:14,982
of the order in the order processing database. And then finally,

532
00:32:15,036 --> 00:32:18,986
when that get order status comes in when I'm sat there furiously refreshing my

533
00:32:19,008 --> 00:32:22,682
mobile app that can return really, really quickly because

534
00:32:22,736 --> 00:32:26,038
I've got this optimized view of the world created by my audit

535
00:32:26,054 --> 00:32:29,290
processing service. If this all sounds

536
00:32:29,360 --> 00:32:32,938
wonderful and exciting and magical, and you really want to start building an event driven

537
00:32:32,954 --> 00:32:35,854
system, but you don't just know how,

538
00:32:36,052 --> 00:32:38,734
what I'd encourage you to do is to start small.

539
00:32:38,852 --> 00:32:42,826
Don't try to make your entire system event driven overnight.

540
00:32:43,018 --> 00:32:46,894
Pick an area, get it right, and then start to scale

541
00:32:46,942 --> 00:32:50,818
up. And if you're working within an existing system, let's say

542
00:32:50,984 --> 00:32:54,974
you have the same scenario as plant based pizza and you've already got HTTP communication

543
00:32:55,022 --> 00:32:58,278
between all your microservices. One of the low impact things you

544
00:32:58,284 --> 00:33:02,200
can do to get started is to simply start adding events to your system.

545
00:33:02,570 --> 00:33:06,070
Even if you still prioritize HTTP communication,

546
00:33:06,410 --> 00:33:09,766
starting to publish events onto event buses gives

547
00:33:09,788 --> 00:33:13,446
you the potential to then add any new functionality

548
00:33:13,558 --> 00:33:16,714
using events and a more event driven architecture and get used to your

549
00:33:16,752 --> 00:33:20,694
systems working with messages and events. And then over time you can hopefully

550
00:33:20,742 --> 00:33:24,138
shift away from that more HTTP based communication.

551
00:33:24,314 --> 00:33:28,570
And remember that event driven architecture is fundamentally a communication pattern.

552
00:33:28,650 --> 00:33:32,282
It's a way of modeling the integration between your systems at a technical

553
00:33:32,346 --> 00:33:35,826
level. Of course it's about the technical integration. It's a way of

554
00:33:35,848 --> 00:33:38,990
integrating systems together, but using business events.

555
00:33:39,150 --> 00:33:42,386
But it's also a useful communication pattern at a business level.

556
00:33:42,488 --> 00:33:45,746
At a human to human level, one of the hardest things in

557
00:33:45,768 --> 00:33:48,926
software development is communication. The language you use

558
00:33:48,968 --> 00:33:53,094
to talk about your system between the technical and the business people can

559
00:33:53,132 --> 00:33:56,754
be one of the biggest challenges. If the technical people are talking about microservices

560
00:33:56,802 --> 00:34:00,554
and rest APIs, your business people are going to glaze over and

561
00:34:00,592 --> 00:34:03,674
probably stop listening to you. And remember,

562
00:34:03,792 --> 00:34:07,210
words and stories are the master key to human

563
00:34:07,280 --> 00:34:10,842
success. And given that, at least for the moment event,

564
00:34:10,896 --> 00:34:14,858
if software development is fundamentally a human endeavor,

565
00:34:15,034 --> 00:34:18,858
then this directly impacts the potential success of your system. Now, event driven

566
00:34:18,874 --> 00:34:22,862
architecture gives you that language to talk about your system across your entire

567
00:34:22,916 --> 00:34:26,322
organization, and it does that with some nice technical benefits

568
00:34:26,376 --> 00:34:30,002
as well. It gives you looser coupling, a more easily evolvable system

569
00:34:30,056 --> 00:34:33,086
that allows you to extend and change in a more flexible

570
00:34:33,118 --> 00:34:36,562
way. Of course, like everything, it isn't without

571
00:34:36,616 --> 00:34:40,086
its trade offs. Silver bullets do not exist in software. All you

572
00:34:40,108 --> 00:34:43,250
have is just a big collection of trade offs.

573
00:34:43,410 --> 00:34:46,358
And in this talk you've learned about some of these trade offs, some of the

574
00:34:46,364 --> 00:34:49,814
pitfalls, and hopefully some practical patterns that you can take away

575
00:34:49,852 --> 00:34:53,538
and use as you start building event driven systems.

576
00:34:53,714 --> 00:34:57,046
If you want to talk more, please feel free to reach out on any of

577
00:34:57,068 --> 00:35:00,286
the social media platforms. I have a lot of content on my YouTube channel talking

578
00:35:00,308 --> 00:35:03,630
about serverless and event driven architecture. I'd love to see you all there.

579
00:35:03,700 --> 00:35:06,862
And finally, thank you all for taking the time, but of your day to day

580
00:35:06,916 --> 00:35:10,154
to come and hear me talk. I'd really, really appreciate

581
00:35:10,202 --> 00:35:11,850
it. Enjoy the rest of the conference.

