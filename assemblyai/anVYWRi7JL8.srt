1
00:00:27,534 --> 00:00:31,126
Thank you for joining this session. I am pleased to be here and

2
00:00:31,150 --> 00:00:34,510
we are going to see today building secure and flexible multicloud

3
00:00:34,542 --> 00:00:38,086
image with multiple a comprehensive CI CD approach.

4
00:00:38,230 --> 00:00:41,486
But before starting I'd like to present myself. So who

5
00:00:41,510 --> 00:00:44,950
I am, I am a brazilian expert living in Poland. I have

6
00:00:44,982 --> 00:00:48,190
about 70 years of experience in it and my

7
00:00:48,222 --> 00:00:51,766
main experience relies on being a developer specialist

8
00:00:51,910 --> 00:00:54,674
with Fox automation, infra and cloud.

9
00:00:55,274 --> 00:00:58,534
So in this session what we will see, we will see

10
00:00:59,154 --> 00:01:02,882
hints of the code and we will see why we choose the

11
00:01:02,898 --> 00:01:05,334
approach, our solution,

12
00:01:05,794 --> 00:01:09,754
some overview of the CI and

13
00:01:09,914 --> 00:01:14,122
the reason behind all of this

14
00:01:14,258 --> 00:01:18,274
approach. So the CI CD overview.

15
00:01:18,394 --> 00:01:21,716
So we are going to see what stands for CI

16
00:01:21,740 --> 00:01:25,764
CD. For those that don't know, CI CD stands for continuous

17
00:01:25,804 --> 00:01:31,044
integration and CD stands for deployment.

18
00:01:31,204 --> 00:01:34,516
Depends on which kind of product do you have.

19
00:01:34,660 --> 00:01:38,220
So for CI is usually when you have

20
00:01:38,372 --> 00:01:42,012
automated builds, automatic testing, you want early detection,

21
00:01:42,148 --> 00:01:45,796
you have code qualities and continuous delivery is

22
00:01:45,820 --> 00:01:48,824
like when you have automated deployment,

23
00:01:50,604 --> 00:01:54,684
it wants to reduce the time to the market. So you build and

24
00:01:54,724 --> 00:01:58,604
you promote this to the marketplace for example,

25
00:01:58,644 --> 00:02:03,700
and this you help to have a better delivery

26
00:02:03,812 --> 00:02:08,012
and deployment. You have a commit, you push and

27
00:02:08,148 --> 00:02:11,332
you build and you deploy production services.

28
00:02:11,428 --> 00:02:14,870
So you have an efficient feedback loop. In our case,

29
00:02:14,942 --> 00:02:18,822
in our approach we just need CI and

30
00:02:18,838 --> 00:02:22,006
the CD four coach which is delivered because we are not deploying anything to the

31
00:02:22,030 --> 00:02:25,034
customer in the resource connector.

32
00:02:25,654 --> 00:02:29,446
So in

33
00:02:29,470 --> 00:02:32,674
the user expectation,

34
00:02:33,254 --> 00:02:38,502
the user expect reliable and available system

35
00:02:38,638 --> 00:02:41,764
that you can have frequent updates is easier

36
00:02:41,844 --> 00:02:44,956
to fix bug and it's

37
00:02:44,980 --> 00:02:48,780
very fast to fix the bug. It's constant in the user experience,

38
00:02:48,972 --> 00:02:52,700
has security and you can have privacy and

39
00:02:52,732 --> 00:02:56,076
you can also see the logs, so you can see the transparency, you can see

40
00:02:56,100 --> 00:03:00,100
what's happening in the jobs has nice and

41
00:03:00,252 --> 00:03:03,740
features. So that's what the user usually expect from

42
00:03:03,772 --> 00:03:07,576
a CI CD system. So our

43
00:03:07,640 --> 00:03:10,840
context is the resource connected product.

44
00:03:10,912 --> 00:03:14,856
So the resource connected product is

45
00:03:14,880 --> 00:03:18,552
a piece of inside of the zero

46
00:03:18,608 --> 00:03:22,552
trust network access suite. So Cisco

47
00:03:22,608 --> 00:03:26,408
has this product to help the customer to guarantee

48
00:03:26,456 --> 00:03:30,280
zero trust in the network. So you are allowing security

49
00:03:30,392 --> 00:03:34,774
features from access to internal websites

50
00:03:34,934 --> 00:03:37,234
or systems or any endpoint.

51
00:03:38,934 --> 00:03:42,594
The resource connectors works as a kind of tunnel or

52
00:03:43,094 --> 00:03:46,622
proxy VPN and is deployed in

53
00:03:46,638 --> 00:03:50,914
the same subnet where the private app he wants to

54
00:03:51,494 --> 00:03:55,182
give access to the user in his smartphone or

55
00:03:55,238 --> 00:03:59,072
his computer and to access is not via directly but

56
00:03:59,158 --> 00:04:03,308
via the suite of zeropress and then using

57
00:04:03,356 --> 00:04:07,076
the connect resource tool to access. So because

58
00:04:07,220 --> 00:04:10,900
the customer can have different clouds and be in

59
00:04:10,932 --> 00:04:14,548
different data centers. So we,

60
00:04:14,676 --> 00:04:18,476
for our own reasons we want to support different

61
00:04:18,540 --> 00:04:20,972
clouds. So that's why we want to support Azure,

62
00:04:21,068 --> 00:04:24,044
Google, AWS and so on and so on,

63
00:04:24,204 --> 00:04:27,686
VMware and OpenStack. Whatever is where the

64
00:04:27,710 --> 00:04:31,982
customer is, we want to be there because his interest

65
00:04:32,038 --> 00:04:35,478
will be there. So that's why he wants to have a product

66
00:04:35,526 --> 00:04:41,234
that is much cloud and because

67
00:04:43,814 --> 00:04:47,214
the clouds may support TPM, may support

68
00:04:47,334 --> 00:04:50,910
security boot and we want to

69
00:04:50,942 --> 00:04:54,804
have the safety features available

70
00:04:54,884 --> 00:04:58,244
in each cloud. So that's why you want to have different boot.

71
00:04:58,284 --> 00:05:01,764
But also internally we need to disable the security boot for

72
00:05:01,804 --> 00:05:05,332
internal and reason or troubleshooting and debugging.

73
00:05:05,468 --> 00:05:08,420
So that's why you need to build Gifron boot modes.

74
00:05:08,572 --> 00:05:13,172
And we have a strategy on building different stages.

75
00:05:13,308 --> 00:05:16,972
So we are creating harden, so we get from the supply

76
00:05:17,028 --> 00:05:20,826
for canonical we get Ubuntu, we harden where we install

77
00:05:20,890 --> 00:05:24,162
and configure the OS with secure checks,

78
00:05:24,218 --> 00:05:28,362
mandatory regulation, anything that's necessary to create a secure

79
00:05:28,458 --> 00:05:31,954
and harden OS and that os we use

80
00:05:32,074 --> 00:05:36,330
in the product and in our own internal

81
00:05:36,362 --> 00:05:40,194
builds, runners, internal services, anything that

82
00:05:40,274 --> 00:05:43,970
we need to use. Then with the hardened image we

83
00:05:44,002 --> 00:05:47,154
create a baseline product where we could partitions,

84
00:05:47,574 --> 00:05:50,874
make os grades with for example

85
00:05:53,534 --> 00:05:57,278
anything that we update some software internally and

86
00:05:57,366 --> 00:06:01,078
that we get latest version with

87
00:06:01,126 --> 00:06:05,038
everything, with any cv set and so on.

88
00:06:05,206 --> 00:06:09,534
And it's the base image. Then we use as an input

89
00:06:09,614 --> 00:06:13,970
to correct the boot mode, so users base and then we install Cisco

90
00:06:14,002 --> 00:06:17,746
preparatory code that's like for example the inconnect and

91
00:06:17,770 --> 00:06:21,346
other software that makes the product WhatsApp

92
00:06:21,370 --> 00:06:24,874
product and enable disable the boot modes

93
00:06:24,914 --> 00:06:28,386
or selecting boot modes to enable in

94
00:06:28,410 --> 00:06:32,194
that VME machine. And we have a code

95
00:06:32,314 --> 00:06:36,146
overlap. So we don't want to copy and

96
00:06:36,170 --> 00:06:40,254
paste code all over the place, we want to share

97
00:06:40,294 --> 00:06:44,382
the code. For example to create the product is similar code

98
00:06:44,518 --> 00:06:48,366
to build the

99
00:06:48,390 --> 00:06:52,142
product. So instead we have one file

100
00:06:52,318 --> 00:06:55,694
for azure, one file for VMware, one file for AWS

101
00:06:55,734 --> 00:07:00,110
and so on, so on. We have a build a script that

102
00:07:00,142 --> 00:07:02,954
will do similar all across to the,

103
00:07:04,624 --> 00:07:09,352
to the clouds so it's easier to maintain. But also the

104
00:07:09,368 --> 00:07:13,536
other hand is tricky because if you change one line and

105
00:07:13,640 --> 00:07:17,328
you can maybe break something that you are not even thinking,

106
00:07:17,376 --> 00:07:20,648
so you are changing something for taking change

107
00:07:20,696 --> 00:07:24,044
for AWS. But then you start

108
00:07:24,744 --> 00:07:28,800
knowing you break something as you. So we need to double check

109
00:07:28,872 --> 00:07:32,794
how the that you support. So every time that you support a new boot

110
00:07:32,834 --> 00:07:36,774
mode or a new cloud, this increased the pain.

111
00:07:37,914 --> 00:07:41,066
So as much we are increasing the support, increasing also the

112
00:07:41,090 --> 00:07:45,074
pain. So this is very critical for our developers

113
00:07:45,194 --> 00:07:48,890
to support and are very painful as well.

114
00:07:49,082 --> 00:07:53,002
So because that we came with the approach that

115
00:07:53,098 --> 00:07:58,124
is supporting different

116
00:07:59,984 --> 00:08:03,312
states in different repo. So every stage will

117
00:08:03,328 --> 00:08:06,720
be a repo, so the harden will be a repo, the base image

118
00:08:06,752 --> 00:08:10,176
will be a repo and the product

119
00:08:10,240 --> 00:08:13,488
image will be another repo. And we will use GitHub

120
00:08:13,536 --> 00:08:17,056
actions because we are using GitHub. So we are placing the

121
00:08:17,080 --> 00:08:20,544
indigo, we are using the GitHub action as

122
00:08:20,584 --> 00:08:24,152
function. So with arguments and values we have a

123
00:08:24,168 --> 00:08:28,512
contract where I say okay for build, this is the inputs

124
00:08:28,528 --> 00:08:31,400
that receive and this is the values that I expect.

125
00:08:31,512 --> 00:08:34,720
What you do internally, I don't care because this concerns

126
00:08:34,752 --> 00:08:38,464
the self contained inside of the, in that

127
00:08:38,504 --> 00:08:42,320
component. We use Packer

128
00:08:42,472 --> 00:08:45,528
to build image. So Packer

129
00:08:45,576 --> 00:08:49,440
has infrasorce that is nice to

130
00:08:49,472 --> 00:08:53,042
use to build different cloud providers

131
00:08:53,208 --> 00:08:57,518
and we use the app one to deploy because we need to build and test.

132
00:08:57,686 --> 00:09:01,294
We need to deploy the machine and everything that's around

133
00:09:01,374 --> 00:09:05,234
of the machine, the environment that's necessary to test

134
00:09:06,094 --> 00:09:10,126
the VM and also we use ansible to

135
00:09:10,150 --> 00:09:14,086
build, to run some command

136
00:09:14,110 --> 00:09:17,454
lines to build and also to test. So we want to

137
00:09:17,534 --> 00:09:21,272
test it. Something is working properly inside the machines. We use ansible

138
00:09:21,328 --> 00:09:25,264
to test and we need to use regression test strategy.

139
00:09:25,304 --> 00:09:28,600
So every time that you change a critical part

140
00:09:28,632 --> 00:09:32,304
of the infra code, in any part of this stage, we need to

141
00:09:32,344 --> 00:09:35,680
run a full regression test. So if we change one

142
00:09:35,712 --> 00:09:39,568
line, one script that's shared in the hardware image,

143
00:09:39,656 --> 00:09:43,128
we need to test then the build, then we test the building base and we

144
00:09:43,136 --> 00:09:46,168
test the built in product and we test the deployment and everything.

145
00:09:46,336 --> 00:09:50,104
And if everything's fine, yes, then we are saying that it's safe,

146
00:09:50,144 --> 00:09:53,832
that our build is okay and we

147
00:09:53,848 --> 00:09:57,896
can merge that code without any problem. So that's how

148
00:09:57,920 --> 00:10:01,848
we structure the project. So we have four

149
00:10:01,976 --> 00:10:05,604
different repos, one for each

150
00:10:06,904 --> 00:10:12,018
stage view. So harden product base and the product itself

151
00:10:12,176 --> 00:10:15,334
and a tester repo where we have 70

152
00:10:15,414 --> 00:10:19,154
tests, integration test, performance, test,

153
00:10:21,374 --> 00:10:25,254
vulnerabilities, scans, test, anything that concerns

154
00:10:25,294 --> 00:10:28,926
to different stage of testing. We are placing this repo

155
00:10:29,030 --> 00:10:33,114
and we are calling from the other build repos

156
00:10:35,934 --> 00:10:40,004
in across pipeline strategy.

157
00:10:40,384 --> 00:10:43,904
So the builder suite structure has

158
00:10:43,984 --> 00:10:47,784
a similar folder and structure across all

159
00:10:47,824 --> 00:10:51,424
repos. So it's easier to maintain. So the developer when reads

160
00:10:51,544 --> 00:10:54,568
the repo, the code will see okay, yes,

161
00:10:54,616 --> 00:10:58,480
stimuli is a bit different because the context

162
00:10:58,512 --> 00:11:02,016
is different. When you are building a hardening it will be different from building a

163
00:11:02,040 --> 00:11:05,502
project, but the structure is similar. So it's

164
00:11:05,518 --> 00:11:08,782
easier to maintain if you know how to maintain one repo you

165
00:11:08,798 --> 00:11:12,166
know how to maintain the other repos. So we use reusable

166
00:11:12,230 --> 00:11:15,502
workflows from GitHub. So then

167
00:11:15,598 --> 00:11:18,822
we use composite actions like is components,

168
00:11:18,878 --> 00:11:22,238
its functions in high level terms that

169
00:11:22,286 --> 00:11:25,934
allow us to use inputs and outputs and

170
00:11:25,974 --> 00:11:30,078
do self contained logic in niche cloud.

171
00:11:30,206 --> 00:11:34,138
So if needs to get some secret, some specific configuration for that cloud,

172
00:11:34,286 --> 00:11:37,922
we don't care because it's self contained. We just pass what we

173
00:11:37,938 --> 00:11:41,554
need to do like build with that version, with those parameters

174
00:11:41,674 --> 00:11:46,074
and give me an image with some

175
00:11:46,114 --> 00:11:50,094
name and I get this and we'll be using the reusable workflows

176
00:11:50,834 --> 00:11:54,186
Anskivo files are used to

177
00:11:54,210 --> 00:11:57,322
build. So we use playbook with some

178
00:11:57,458 --> 00:12:01,222
roles and some tabs that give us the freedom

179
00:12:01,358 --> 00:12:04,594
to install to configuring

180
00:12:06,694 --> 00:12:10,646
the van as we want. With those in symbol tasks it's

181
00:12:10,710 --> 00:12:14,194
very easy to provision the deployment

182
00:12:14,494 --> 00:12:18,046
and we use bucket script

183
00:12:18,190 --> 00:12:21,846
to build the cloud image.

184
00:12:21,990 --> 00:12:26,002
So it's multi cloud supported

185
00:12:26,198 --> 00:12:30,074
is if as a code sales also is a

186
00:12:30,114 --> 00:12:34,034
stack that we use. So the file dependency

187
00:12:34,114 --> 00:12:38,026
is how we manage the pin inversion.

188
00:12:38,090 --> 00:12:42,170
So we use pin inversion across all the repos so

189
00:12:42,242 --> 00:12:45,666
that this way when we are changing something it will

190
00:12:45,690 --> 00:12:49,538
be committed, will be reviewed in the code review in

191
00:12:49,546 --> 00:12:52,924
the PR so we know exactly what we changed and

192
00:12:52,964 --> 00:12:57,244
then we can track back by

193
00:12:57,324 --> 00:13:01,224
the commit hatch when was maybe some change and how

194
00:13:01,644 --> 00:13:05,452
some bug was injected. So we can trace back and find

195
00:13:05,508 --> 00:13:08,824
the bug and fix the bug very fast.

196
00:13:09,404 --> 00:13:12,732
And the test suite structure, we have a

197
00:13:12,748 --> 00:13:16,428
similar structure from the build, but GStav Packer

198
00:13:16,476 --> 00:13:19,936
we use the form. So we use health to deploy

199
00:13:20,120 --> 00:13:23,976
the VM and the environment around any resource that's necessary to

200
00:13:24,000 --> 00:13:27,984
deploy in that cloud. And also

201
00:13:28,024 --> 00:13:30,784
we use common ansible files.

202
00:13:30,944 --> 00:13:35,136
So in this case we don't use to the provider the

203
00:13:35,160 --> 00:13:38,216
VM, but we use to run some tests.

204
00:13:38,240 --> 00:13:42,952
So every test in the Xbox

205
00:13:42,968 --> 00:13:46,780
roles are one type of test. So for example, let's assume that

206
00:13:46,852 --> 00:13:50,372
our product needs to create some files and some folders and we

207
00:13:50,388 --> 00:13:54,108
need to guarantee that those files and folders are in place inside the machine

208
00:13:54,156 --> 00:13:58,388
because it's critical for the running software.

209
00:13:58,556 --> 00:14:03,036
So one type of test for example, could be a

210
00:14:03,060 --> 00:14:06,244
test that goes and make assessment machine check

211
00:14:06,284 --> 00:14:10,020
if the file and the folder exists and check if the file

212
00:14:10,092 --> 00:14:14,720
has the format and the content expected to

213
00:14:14,752 --> 00:14:18,344
be executed with success. So if everything's fine,

214
00:14:18,464 --> 00:14:22,128
so the asymptotes will run with success. If something

215
00:14:22,176 --> 00:14:25,272
is wrong, we ignore, so we place ignore the

216
00:14:25,288 --> 00:14:29,280
errors and later when everything is executed, we summarize

217
00:14:29,352 --> 00:14:34,096
our success and error or ignore tasks

218
00:14:34,160 --> 00:14:38,096
and we say okay, we have some testing or because they are errors,

219
00:14:38,160 --> 00:14:43,604
that means we run all tests but we place

220
00:14:43,644 --> 00:14:47,380
a failure because we should not ignore anything because that means we

221
00:14:47,412 --> 00:14:50,692
have a failed case. So that's how we

222
00:14:50,708 --> 00:14:54,788
use this strategy to build and test. But why this

223
00:14:54,836 --> 00:14:58,908
step? So I just give a hint why. But let's go deeper

224
00:14:58,956 --> 00:15:02,780
and check some nice features on for example GitHub.

225
00:15:02,932 --> 00:15:07,824
So because we use GitHub as their repo was

226
00:15:07,984 --> 00:15:12,456
very natural to use GitHub action because it

227
00:15:12,560 --> 00:15:16,976
has seamless integration. You don't need to use external Ci

228
00:15:17,000 --> 00:15:20,664
CD like Jenkins or another

229
00:15:20,744 --> 00:15:24,616
type of CI CD that's commonly used for

230
00:15:24,640 --> 00:15:28,232
the community. But we choose GitHub action

231
00:15:28,328 --> 00:15:32,084
for because then has efficient Ci CD pipelines.

232
00:15:32,464 --> 00:15:35,616
You can customize because it's made

233
00:15:35,640 --> 00:15:39,168
in YamL file is human readable.

234
00:15:39,336 --> 00:15:43,000
The developers can easily extend

235
00:15:43,192 --> 00:15:46,568
or create nice features. You can

236
00:15:46,616 --> 00:15:50,336
create the whole end to end automation. So you can build, you can test,

237
00:15:50,440 --> 00:15:54,336
you can deploy everything in one place, you don't need to build in one place,

238
00:15:54,400 --> 00:15:57,632
then you have to test in other places and you have to deploy in a

239
00:15:57,648 --> 00:16:01,838
third place. That is very handy and covers many

240
00:16:01,886 --> 00:16:05,174
aspects of the soft delivery lifecycle,

241
00:16:05,294 --> 00:16:09,590
software development lifecycle. So that is why

242
00:16:09,622 --> 00:16:12,990
you choose the GitHub action and

243
00:16:13,022 --> 00:16:16,594
why they have form. We choose to have formed because

244
00:16:17,454 --> 00:16:21,742
infra is a code. So we can define the infra with code

245
00:16:21,878 --> 00:16:25,462
in a very constant way, so we can see. So if we need

246
00:16:25,478 --> 00:16:29,594
to change something that we deploy the infra,

247
00:16:30,094 --> 00:16:36,046
we can use that to always have the same state

248
00:16:36,110 --> 00:16:39,074
we desire in that cloud,

249
00:16:39,814 --> 00:16:43,670
because we need to support different cloud on Prem and also public

250
00:16:43,742 --> 00:16:47,550
clouds. Terraform supports that you can even create your own

251
00:16:47,662 --> 00:16:51,724
provider if your environment is not

252
00:16:52,144 --> 00:16:55,936
supported officially by community or for Dev or for the hashtag.

253
00:16:56,080 --> 00:17:00,392
So that's how you can use and has

254
00:17:00,448 --> 00:17:04,552
resource graphs. That means if you create the order

255
00:17:04,728 --> 00:17:08,792
that makes sense and that makes your

256
00:17:08,848 --> 00:17:12,776
environment work. So if you need to deploy

257
00:17:12,960 --> 00:17:16,680
the VM and then after the VM you need to run some

258
00:17:16,792 --> 00:17:20,809
scripts that will call some APIs to make some

259
00:17:21,001 --> 00:17:24,489
hash string, for example, you can decide his

260
00:17:24,521 --> 00:17:27,849
order, you can place it to use some depends

261
00:17:27,881 --> 00:17:31,345
on properties that we okay run one

262
00:17:31,409 --> 00:17:35,529
after another and guarantee that everything

263
00:17:35,601 --> 00:17:39,713
will work as should you can reuse

264
00:17:39,753 --> 00:17:44,264
components. So for example if you need to register something in

265
00:17:44,924 --> 00:17:48,116
our builds for all cloud, so you can create a register

266
00:17:48,180 --> 00:17:51,668
module and reuse this across the different

267
00:17:51,836 --> 00:17:55,164
clouds so that you reduce the copy

268
00:17:55,204 --> 00:17:59,064
paste script, you have a state management

269
00:17:59,484 --> 00:18:04,860
file. So because we built in

270
00:18:04,892 --> 00:18:08,548
one job, we deploy another job and this deployment

271
00:18:08,596 --> 00:18:12,082
can take can run for after minutes, you can once

272
00:18:12,138 --> 00:18:15,450
run for a few hours or even you want to leave the machine

273
00:18:15,482 --> 00:18:19,042
there for a few days for some longevity

274
00:18:19,098 --> 00:18:22,450
tests. We want to have the build the test

275
00:18:22,522 --> 00:18:27,626
and the tear down in different jobs. And they are different

276
00:18:27,810 --> 00:18:32,014
individually, they are not dependency.

277
00:18:33,394 --> 00:18:36,730
But when we need to have to destroy,

278
00:18:36,802 --> 00:18:39,546
we need to know what we are destroying. So that's why we need to have

279
00:18:39,570 --> 00:18:43,336
a I state to know what we need to destroy.

280
00:18:43,520 --> 00:18:46,824
So that's why we use the form because it's easier. We just have to pass.

281
00:18:46,864 --> 00:18:50,688
Okay, this is the file. Please make a trdon

282
00:18:50,736 --> 00:18:54,208
of this file that has everything that you need to know

283
00:18:54,336 --> 00:18:57,600
about what was deployed in AWS or in Azure,

284
00:18:57,672 --> 00:19:01,160
in any other cloud. And let's assume that

285
00:19:01,352 --> 00:19:04,792
the deployment didn't occur with success. So something

286
00:19:04,848 --> 00:19:08,344
was deployed and something didn't apply. So you need to make a cleanup.

287
00:19:08,504 --> 00:19:12,792
So because the terraform has a state of what was deployed

288
00:19:12,888 --> 00:19:16,288
and what was not deployed. So you have,

289
00:19:16,336 --> 00:19:19,728
okay, make a cleanup that will destroy everything that was created.

290
00:19:19,776 --> 00:19:22,960
And you have a clean lab so you're not

291
00:19:22,992 --> 00:19:26,656
leaving anything behind on the lab. So it's good

292
00:19:26,680 --> 00:19:29,552
to reduce any trash,

293
00:19:29,608 --> 00:19:33,024
anything that should be deleted and has many

294
00:19:33,064 --> 00:19:36,164
integrations with the commute x system.

295
00:19:38,024 --> 00:19:42,496
So why you choose fucker Packer is

296
00:19:42,520 --> 00:19:46,176
very quickly to build image with

297
00:19:46,200 --> 00:19:49,648
parallelization. So that's why we need it once

298
00:19:49,696 --> 00:19:53,624
built very fast and we want to build with parallelization

299
00:19:53,744 --> 00:19:57,724
different clouds and different

300
00:19:58,224 --> 00:20:01,800
types of boots and we want to support different

301
00:20:01,872 --> 00:20:05,582
platforms as we RLC, so we want to support where the

302
00:20:05,598 --> 00:20:09,374
customer is. So we need to build for different platforms and

303
00:20:09,414 --> 00:20:13,438
we have also the seamless

304
00:20:13,486 --> 00:20:16,994
integration so we can integrate with all the tools.

305
00:20:17,974 --> 00:20:22,478
We want to have security so we want to use from trust

306
00:20:22,526 --> 00:20:26,486
certs that also unpacker supports and

307
00:20:26,670 --> 00:20:31,016
we use different plugins and the

308
00:20:31,040 --> 00:20:34,432
plugins are very different plugins

309
00:20:34,568 --> 00:20:38,384
wide supported for the community. So that's also a nice feature.

310
00:20:38,544 --> 00:20:42,680
And as terraform is infra

311
00:20:42,832 --> 00:20:46,164
and why is multiple infra for building images

312
00:20:46,504 --> 00:20:50,408
at least for the product, we have a mandatory reason

313
00:20:50,536 --> 00:20:54,044
that we need from the same input, the same files

314
00:20:54,664 --> 00:20:57,686
and we need to generate the same output.

315
00:20:57,880 --> 00:21:01,654
So that's why we are using pin versions, we are using

316
00:21:02,354 --> 00:21:05,818
infraso code because we can guarantee that that same

317
00:21:05,866 --> 00:21:09,114
commit will guarantee you generate the

318
00:21:09,154 --> 00:21:12,774
same result over and over. So this guarantee

319
00:21:13,834 --> 00:21:17,090
trust for some oddity or anything that

320
00:21:17,122 --> 00:21:21,074
we need to guarantee that. Okay yeah we can. That's what

321
00:21:21,114 --> 00:21:25,190
your, this binary, this image is this code and

322
00:21:25,222 --> 00:21:28,354
you can guarantee that because if you build you have

323
00:21:28,814 --> 00:21:32,606
the same output and asymbol why use

324
00:21:32,630 --> 00:21:35,998
the asymbol? Because it's agentless. So we don't need

325
00:21:36,006 --> 00:21:39,206
to install anything in the products to guarantee

326
00:21:39,230 --> 00:21:42,910
that we can test or we can build. So we

327
00:21:42,942 --> 00:21:46,558
just use over ssh and very

328
00:21:46,606 --> 00:21:50,086
simple so we can run comments

329
00:21:50,230 --> 00:21:54,038
as doing SSh in command line manually but

330
00:21:54,086 --> 00:21:58,302
via automated and programmatic code is

331
00:21:58,358 --> 00:22:01,914
using emo file as well. And as

332
00:22:02,334 --> 00:22:05,822
GitHub action is human readable so you

333
00:22:05,838 --> 00:22:09,542
can read it's easier to understand and is easier to change.

334
00:22:09,678 --> 00:22:13,670
That documentation is a good documentation has

335
00:22:13,742 --> 00:22:17,150
many plugins. So if you want to use third

336
00:22:17,182 --> 00:22:20,822
party plugins, for example you want to use AWS, not t

337
00:22:20,838 --> 00:22:24,830
UA from NS but instead to call this AWS

338
00:22:24,862 --> 00:22:28,094
ClI you can use the plugin for AWS.

339
00:22:28,214 --> 00:22:32,470
So you know has different plugins and you

340
00:22:32,502 --> 00:22:35,594
can predict the automation so it's id potent.

341
00:22:36,014 --> 00:22:39,590
So and also the community is very

342
00:22:39,662 --> 00:22:42,990
wide and has different plugins

343
00:22:43,022 --> 00:22:46,294
that you can install using galaxy repository.

344
00:22:46,874 --> 00:22:50,002
And let's talk about the workflows.

345
00:22:50,178 --> 00:22:53,586
So here we have the build pipeline workflow.

346
00:22:53,730 --> 00:22:57,290
So we have the hard image where we

347
00:22:57,322 --> 00:23:01,370
call the. When we change the code

348
00:23:01,522 --> 00:23:05,066
this will create the hardware image and then we use as

349
00:23:05,130 --> 00:23:08,374
input create the product and the product will create,

350
00:23:09,314 --> 00:23:12,598
will be used to create the the product image with the

351
00:23:12,646 --> 00:23:16,314
web security boot or the web security boot

352
00:23:16,694 --> 00:23:21,150
for the body for this example. So now

353
00:23:21,182 --> 00:23:24,526
imagine that we need to support last azure and any

354
00:23:24,550 --> 00:23:30,238
other clouds and increasing. So this is our

355
00:23:30,286 --> 00:23:34,286
case right? So and then for each one we need to

356
00:23:34,390 --> 00:23:37,690
run tests, we need to deploy the inference, we need to run the

357
00:23:37,722 --> 00:23:40,734
test and we need to tear down the infra as well.

358
00:23:41,474 --> 00:23:44,730
So here is how will be look

359
00:23:44,762 --> 00:23:48,370
like the full pipeline. So there one

360
00:23:48,402 --> 00:23:52,054
orchestrator that will know what to trigger

361
00:23:53,194 --> 00:23:56,570
the builds the hardware. Then for each hardened image in each

362
00:23:56,602 --> 00:24:00,922
cloud we create a product based image and then we'll create

363
00:24:01,098 --> 00:24:04,610
the product image with the proper boot mode. And for

364
00:24:04,642 --> 00:24:07,930
each image that was product image that was created,

365
00:24:08,042 --> 00:24:11,754
was built we triggered a deploy sanity test

366
00:24:11,834 --> 00:24:16,554
and then a chair down machine. So how

367
00:24:16,594 --> 00:24:20,034
we can make this, you know to guarantee regression

368
00:24:20,074 --> 00:24:23,254
tests in this case, in this scenario.

369
00:24:24,594 --> 00:24:28,354
So I will give you here

370
00:24:28,394 --> 00:24:32,240
an example about one

371
00:24:32,272 --> 00:24:36,284
user changed as shared ansible test in the harden suite

372
00:24:36,624 --> 00:24:40,840
via PR. So is adding a new security

373
00:24:40,952 --> 00:24:44,664
check or security configuration in the harder and

374
00:24:44,704 --> 00:24:48,112
this may affect the whole chain right?

375
00:24:48,168 --> 00:24:51,444
Because you add in something that will

376
00:24:51,864 --> 00:24:55,004
change the os that will affect,

377
00:24:55,324 --> 00:24:59,012
that may affect the base image that can may affect also the

378
00:24:59,028 --> 00:25:03,124
product that will affect the product itself and affecting

379
00:25:03,164 --> 00:25:07,220
the test. So we need to guarantee that any change in

380
00:25:07,252 --> 00:25:11,224
any stage is fully tested. So in this case we are building

381
00:25:11,804 --> 00:25:15,844
temporary hardened image. Then with this temporary

382
00:25:15,964 --> 00:25:20,036
hardened image we use as inputs to create the temporary basic

383
00:25:20,060 --> 00:25:24,320
product. Then we use the result of that to create a temporary product.

384
00:25:24,512 --> 00:25:28,424
Then for each security boot then we deploy

385
00:25:28,544 --> 00:25:32,160
that temporary product, then we run the test and you're done.

386
00:25:32,192 --> 00:25:35,992
So if everything's passing in our clouds, in our

387
00:25:36,168 --> 00:25:39,564
security boot modes that was affected by this change,

388
00:25:40,424 --> 00:25:43,004
then we are fine to merge. And we merge.

389
00:25:44,024 --> 00:25:47,328
Once it's merged it will

390
00:25:47,376 --> 00:25:51,058
create automatically APR with the new

391
00:25:51,226 --> 00:25:55,114
latest we build a hardened

392
00:25:55,154 --> 00:25:58,626
final harden image. Then we create a PR with the

393
00:25:58,650 --> 00:26:02,138
latest build of this harden to

394
00:26:02,226 --> 00:26:05,774
baseos. Then same thing. Because you create

395
00:26:06,274 --> 00:26:09,690
a new version you need to check if everything is still working

396
00:26:09,842 --> 00:26:13,362
because in the base image we

397
00:26:13,378 --> 00:26:19,584
are not having everything pinned. We run some OS

398
00:26:19,664 --> 00:26:22,792
grades software like we need to

399
00:26:22,968 --> 00:26:27,384
update their python, we need to run Ubuntu

400
00:26:27,424 --> 00:26:30,928
updates or something like that. That is not possible to pin unless

401
00:26:30,976 --> 00:26:34,824
we have cache. So in that case. So that's why every

402
00:26:34,864 --> 00:26:38,416
time that you build a final hardware image,

403
00:26:38,560 --> 00:26:41,908
we create a PR, then the PR will run the regression test

404
00:26:42,016 --> 00:26:45,500
to guarantee if everything is working. Then when

405
00:26:45,532 --> 00:26:49,300
the regression test is passed we merge. Then we create a final

406
00:26:49,372 --> 00:26:52,964
base image, same thing. We create a PR to the

407
00:26:53,084 --> 00:26:55,604
product and guarantee that everything is fine.

408
00:26:55,764 --> 00:26:59,292
But because the product image we

409
00:26:59,308 --> 00:27:02,548
are not running anything that is OSB grade. We are pinning

410
00:27:02,596 --> 00:27:06,932
everything, the base image, the Cisco proprietary code and

411
00:27:07,108 --> 00:27:11,194
out versions are pinned because we need to reproduce all

412
00:27:11,274 --> 00:27:14,706
over again the same build. We don't need to

413
00:27:14,770 --> 00:27:18,322
run regression tests in the PR. When we create the PR

414
00:27:18,378 --> 00:27:21,882
with the new versions, we are just creating a build.

415
00:27:21,978 --> 00:27:24,334
We will see later a bit more on that.

416
00:27:24,914 --> 00:27:28,934
So see about the promotion testing was saying so

417
00:27:29,234 --> 00:27:32,850
we create a pr, change the version, the version

418
00:27:32,882 --> 00:27:36,104
of the base OS or the version of the any

419
00:27:36,144 --> 00:27:39,736
connect or anything that is of the Cisco preparatory code that

420
00:27:39,760 --> 00:27:44,008
we have different repos that create binaries

421
00:27:44,136 --> 00:27:48,384
and other versions. Then if

422
00:27:48,424 --> 00:27:51,920
this file change it, we will see okay,

423
00:27:51,952 --> 00:27:55,824
I change it for all. This change will affect all calls

424
00:27:55,904 --> 00:27:59,576
and also boot mode or will change

425
00:27:59,720 --> 00:28:03,462
only one specific input mode and one specific cloud.

426
00:28:03,518 --> 00:28:07,034
So based on the permutation of the change that we made,

427
00:28:07,614 --> 00:28:11,342
the pipeline will run a script that we define

428
00:28:11,518 --> 00:28:14,782
which pipeline should execute. If you execute

429
00:28:14,838 --> 00:28:19,034
all pipelines for all clouds, or only for one specific

430
00:28:19,334 --> 00:28:23,674
boot mode and one specific cloud or subset of clouds

431
00:28:24,054 --> 00:28:27,718
and so on, then this will create real product

432
00:28:27,806 --> 00:28:30,912
images. Then with this image we deploy,

433
00:28:31,048 --> 00:28:34,680
we run the test, we guarantee a down. So we guarantee that it's

434
00:28:34,712 --> 00:28:38,256
fine, it's working. Once we merge that

435
00:28:38,360 --> 00:28:42,048
image created in the PR will be used for further

436
00:28:42,136 --> 00:28:46,096
testing. So contest we are going to scan for

437
00:28:46,120 --> 00:28:49,944
vulnerabilities, CV's and other stuff, and we run performance

438
00:28:50,064 --> 00:28:53,256
longevity tests and then we are placing stage for a

439
00:28:53,280 --> 00:28:56,956
few days where we are running all the kind of manual

440
00:28:57,020 --> 00:29:00,236
tests and other stuff that we guarantee that we

441
00:29:00,260 --> 00:29:04,108
are, everything's fine, we run against the provider

442
00:29:04,196 --> 00:29:07,676
scans, vulnerability and other tasking as

443
00:29:07,700 --> 00:29:11,428
well. And then when we are ready and then we are ready for GA,

444
00:29:11,516 --> 00:29:14,916
it's not necessary that we are going to deploy that we are going to deliver

445
00:29:14,980 --> 00:29:18,804
that, but it's just that it's already. So if

446
00:29:18,844 --> 00:29:22,848
you want to deliver a new version is ready, we just

447
00:29:22,896 --> 00:29:26,256
have to write the

448
00:29:26,280 --> 00:29:29,416
change logs to the customer that say okay, what we are changing and

449
00:29:29,440 --> 00:29:32,944
why we're changing and then it's ready to

450
00:29:32,984 --> 00:29:36,336
be on the marketplaces all over

451
00:29:36,400 --> 00:29:40,720
the clouds. So that's how we can have end

452
00:29:40,752 --> 00:29:44,600
to end from one image

453
00:29:44,712 --> 00:29:49,008
to the marketplace. So in depth builds.

454
00:29:49,176 --> 00:29:53,248
So we also need to guarantee productivity and

455
00:29:53,336 --> 00:29:57,336
facilitate the life of developers so they don't need to have a

456
00:29:57,360 --> 00:30:00,928
toil of tasks to get some

457
00:30:00,976 --> 00:30:04,584
buildings and some machines. In this

458
00:30:04,624 --> 00:30:08,496
case here for example, a user wants

459
00:30:08,520 --> 00:30:12,376
to place some permutation of real

460
00:30:12,440 --> 00:30:16,378
versions or that versions of everything and

461
00:30:16,506 --> 00:30:20,234
then create an image using this as input.

462
00:30:20,394 --> 00:30:23,682
Then this devil developer

463
00:30:23,738 --> 00:30:27,574
can run some tests and something that

464
00:30:27,994 --> 00:30:32,122
is cycle before to place in

465
00:30:32,138 --> 00:30:35,506
the code in the repository. So you still

466
00:30:35,610 --> 00:30:39,778
running some code

467
00:30:39,826 --> 00:30:43,304
or something that is still not mature to be merged to make.

468
00:30:43,424 --> 00:30:46,844
But you need some, some results, some products

469
00:30:47,144 --> 00:30:50,960
that you can test, that you can deploy and you can make troubleshooting

470
00:30:50,992 --> 00:30:53,804
or some analysis on the dev side.

471
00:30:55,144 --> 00:30:58,576
Another case is where you have an image,

472
00:30:58,680 --> 00:31:02,816
can be the image that we built in the previous step or

473
00:31:02,880 --> 00:31:06,152
real image that we want to,

474
00:31:06,328 --> 00:31:09,880
you know, run manual tests. For example, you are

475
00:31:09,912 --> 00:31:13,404
changing the instrument as you are adding new, new cases,

476
00:31:14,144 --> 00:31:18,168
new cases to guarantee more coverage

477
00:31:18,216 --> 00:31:22,120
in the test. So this changed the code. So if

478
00:31:22,152 --> 00:31:25,584
you commit and push it will trigger the regression test

479
00:31:25,744 --> 00:31:28,804
for outlooks. But it's not very,

480
00:31:29,864 --> 00:31:33,472
let's say effective because if you have a bug you have

481
00:31:33,488 --> 00:31:37,558
to push over and over. So this will

482
00:31:37,726 --> 00:31:41,726
create and destroy, create and destroy will take some time

483
00:31:41,870 --> 00:31:45,766
and the feedback loop is not very fast so

484
00:31:45,950 --> 00:31:50,514
it will be a time consuming task. One way is to use

485
00:31:51,174 --> 00:31:54,582
deployment, so you choose exactly which version that you want to

486
00:31:54,598 --> 00:31:58,102
deploy and you deploy. We create environments

487
00:31:58,198 --> 00:32:02,060
and you have the ephemeral SSH access for the

488
00:32:02,092 --> 00:32:05,964
time that you decide. I need 1 hour deployment,

489
00:32:06,004 --> 00:32:09,532
I need one day so the developer decide how much time you

490
00:32:09,548 --> 00:32:12,836
need and after that automatically you tear down.

491
00:32:13,020 --> 00:32:16,140
And during this access you can make troubleshooting or

492
00:32:16,172 --> 00:32:19,636
you can also run asybo playbook. So you change the playbook

493
00:32:19,740 --> 00:32:22,780
manually in your code. You don't need to push, you don't need to commit,

494
00:32:22,932 --> 00:32:26,332
you just run and you see the results. Okay,

495
00:32:26,348 --> 00:32:30,146
it's working. Okay, now I can push. No it's

496
00:32:30,170 --> 00:32:33,666
still not working. I have a typo, I have a bug.

497
00:32:33,730 --> 00:32:37,026
So you can just fix in the code and run again

498
00:32:37,090 --> 00:32:40,250
the playbook, fix the code and run again

499
00:32:40,402 --> 00:32:43,214
the code. So it's very fast feedback,

500
00:32:43,914 --> 00:32:45,894
very handy to developers.

501
00:32:46,554 --> 00:32:50,214
These features that we have in our ci.

502
00:32:50,674 --> 00:32:53,954
So about the code sample, so I have

503
00:32:54,114 --> 00:32:57,590
some here, some screenshots how

504
00:32:57,622 --> 00:33:01,514
we organize the repo. So you can see here

505
00:33:01,894 --> 00:33:04,990
our repo. So in the first

506
00:33:05,142 --> 00:33:08,758
column is the build. So where

507
00:33:08,806 --> 00:33:13,366
we have, this is how we like replace

508
00:33:13,390 --> 00:33:16,918
structure with the GitHub folder with the actions and

509
00:33:16,926 --> 00:33:21,624
the workflows, the in symbol, the backer have

510
00:33:22,684 --> 00:33:26,764
a packer script repair boot

511
00:33:26,804 --> 00:33:29,884
mode. So that's how we can know, okay,

512
00:33:30,004 --> 00:33:33,384
for security boot we need

513
00:33:33,964 --> 00:33:36,972
coding one way, for bios we

514
00:33:36,988 --> 00:33:40,380
need another way, for TPM we need another way.

515
00:33:40,412 --> 00:33:44,932
So this is just a sample how you could, you know how we can have

516
00:33:45,108 --> 00:33:49,504
different cloud providers

517
00:33:49,584 --> 00:33:53,644
building using bucker and

518
00:33:54,864 --> 00:33:58,984
for the testing we have also

519
00:33:59,144 --> 00:34:02,784
similar structure, as you can see actions. Then inside the actions

520
00:34:02,824 --> 00:34:06,504
we have instable test,

521
00:34:06,584 --> 00:34:10,136
that is action set up and chill down. So why three?

522
00:34:10,280 --> 00:34:14,816
Because we want to have separated components

523
00:34:14,920 --> 00:34:18,616
that we can use in different times. So I want to

524
00:34:18,640 --> 00:34:22,944
set up on setup, I want to run

525
00:34:23,024 --> 00:34:26,176
the AC bot testing another time and I want to destroy something.

526
00:34:26,240 --> 00:34:31,040
That's why it's three different components.

527
00:34:31,192 --> 00:34:35,040
And why is this split in different clouds.

528
00:34:35,072 --> 00:34:38,624
So when we need to deploy for

529
00:34:38,784 --> 00:34:43,124
AWS we need to know exactly the conditionals,

530
00:34:43,824 --> 00:34:47,164
this CPNET, VPC and other

531
00:34:47,584 --> 00:34:50,744
specific uses from the AWS for

532
00:34:50,784 --> 00:34:54,240
access, anything. So we need to know the subscription group,

533
00:34:54,392 --> 00:34:57,712
resource group and other stuff for Azure we need

534
00:34:57,728 --> 00:35:01,424
to know where is the lab, what is the game sphere formation.

535
00:35:01,504 --> 00:35:06,084
So this is self contained. So this concern

536
00:35:06,224 --> 00:35:09,980
to outside of the component. So that's, we have

537
00:35:10,052 --> 00:35:13,652
this self contained action and then we have the

538
00:35:13,668 --> 00:35:16,884
workflows, same thing that will,

539
00:35:16,964 --> 00:35:20,964
this workflows will call the composite actions based

540
00:35:21,084 --> 00:35:24,420
in the what we are building,

541
00:35:24,532 --> 00:35:27,796
what you are building. And as you can see this we

542
00:35:27,820 --> 00:35:31,984
have also callable plugin. So this is how we have

543
00:35:32,684 --> 00:35:36,068
the testing I mentioned before where we collect

544
00:35:36,196 --> 00:35:40,316
all state from the incivol and then we check what was passing what

545
00:35:40,340 --> 00:35:43,804
was not passing and then we break the pipeline

546
00:35:43,844 --> 00:35:47,744
or not based on how many tests was passed,

547
00:35:49,884 --> 00:35:53,724
a bit of the composite action. So for

548
00:35:53,764 --> 00:35:57,644
those that don't know the composite actions, this looks

549
00:35:57,684 --> 00:36:01,596
like more or less composite action. You have a

550
00:36:01,620 --> 00:36:04,854
name, you have a description, you have inputs and outputs.

551
00:36:04,974 --> 00:36:08,646
So the inputs, that's how you call, you pass and

552
00:36:08,670 --> 00:36:12,630
then you have outputs. What you expect after you call this

553
00:36:12,742 --> 00:36:16,358
composite and using the runs using

554
00:36:16,406 --> 00:36:19,622
composite is the syntax. So if you

555
00:36:19,638 --> 00:36:22,750
want to know more about the syntax, I recommend you to

556
00:36:22,782 --> 00:36:26,070
go to the GitHub documentation is

557
00:36:26,142 --> 00:36:29,566
well documented and Very simple to implement. Again,

558
00:36:29,670 --> 00:36:33,150
have some very nice examples how to implement and

559
00:36:33,222 --> 00:36:37,038
you can use the GitHub SAS to test

560
00:36:37,166 --> 00:36:40,222
by yourself. Here in

561
00:36:40,238 --> 00:36:44,046
the second column we have a step. So the

562
00:36:44,070 --> 00:36:48,074
composite is a grouping of step, and step is

563
00:36:48,534 --> 00:36:52,262
basically some, one common group of commands that you

564
00:36:52,318 --> 00:36:56,026
run inside of your crop.

565
00:36:56,160 --> 00:37:00,206
So in this case the

566
00:37:00,230 --> 00:37:03,766
packer, we are calling the initializing packer,

567
00:37:03,870 --> 00:37:09,726
we are validating and then we are building the

568
00:37:09,750 --> 00:37:11,114
machine for AWS.

569
00:37:12,894 --> 00:37:16,094
That's how we build for an image.

570
00:37:16,134 --> 00:37:20,030
In this case could be instead mi could be

571
00:37:20,182 --> 00:37:24,340
the security boot that we are saving. So and

572
00:37:24,372 --> 00:37:27,484
we received the security boot as the input.

573
00:37:27,524 --> 00:37:30,900
So we could make this as customized. So we said

574
00:37:30,932 --> 00:37:34,084
to be hard coded. The amount will be the secret boot in

575
00:37:34,124 --> 00:37:37,932
this case as from the base or the seat

576
00:37:37,988 --> 00:37:41,796
because the Basel seed has no cpu. So that's why I placed this

577
00:37:41,820 --> 00:37:42,584
example.

578
00:37:44,964 --> 00:37:49,172
The reusable workflow. So the reusable workflow.

579
00:37:49,308 --> 00:37:55,220
So workflow is basic script

580
00:37:55,292 --> 00:37:59,788
where you have jobs and each job has steps

581
00:37:59,876 --> 00:38:03,260
or groups of steps that you can have many composite

582
00:38:03,292 --> 00:38:07,156
actions or you can have specified the

583
00:38:07,180 --> 00:38:10,908
steps directly in the jobs and

584
00:38:11,076 --> 00:38:14,184
you can have many jobs in the same workflow.

585
00:38:14,564 --> 00:38:18,084
So in this case we have

586
00:38:18,504 --> 00:38:22,144
a build, we have reusable build pipeline

587
00:38:22,304 --> 00:38:26,568
where we have one job that is built that

588
00:38:26,616 --> 00:38:30,784
will generate one

589
00:38:30,824 --> 00:38:34,264
contract to call the composite

590
00:38:34,304 --> 00:38:38,040
action. As we can see in the last line, the second

591
00:38:38,192 --> 00:38:41,720
column where you say okay, this is the platform and

592
00:38:41,752 --> 00:38:44,916
this is the, the tag, the version of

593
00:38:44,940 --> 00:38:49,044
the code from the if I want to use and here is

594
00:38:49,084 --> 00:38:52,708
my inputs, the version

595
00:38:52,756 --> 00:38:56,516
and this version is this. So with

596
00:38:56,620 --> 00:39:00,224
those inputs the composite will know how to

597
00:39:00,684 --> 00:39:04,460
handle these informations and build a base image

598
00:39:04,612 --> 00:39:07,384
from the seed and the version that we want,

599
00:39:08,124 --> 00:39:12,294
the version that you want to use as the suffix version,

600
00:39:12,914 --> 00:39:18,578
how we call this reusable workflow, right. So we

601
00:39:18,626 --> 00:39:22,626
have another workflow that is executed

602
00:39:22,770 --> 00:39:26,490
by PR changes and then

603
00:39:26,562 --> 00:39:30,138
this PR disk workflow has different jobs.

604
00:39:30,226 --> 00:39:34,454
So the has a job to generate the jobs to know which.

605
00:39:37,174 --> 00:39:41,046
So here we are saying okay, I changed the spec file

606
00:39:41,230 --> 00:39:44,414
and compare with the spec file in

607
00:39:44,454 --> 00:39:48,190
the main, give me the diff. And then based

608
00:39:48,222 --> 00:39:52,246
on that we create a matrix of pipelines.

609
00:39:52,390 --> 00:39:56,474
And then based on the matrix we call

610
00:39:57,134 --> 00:40:00,434
the job. So the workflow has

611
00:40:00,774 --> 00:40:04,300
these, so we

612
00:40:04,332 --> 00:40:06,804
know pipeline AWS, BIos,

613
00:40:06,844 --> 00:40:11,492
pipeline AWS with security groups. So those are jobs

614
00:40:11,628 --> 00:40:16,028
in this, in this workflow we

615
00:40:16,116 --> 00:40:19,532
could use matrix that could generate automatically

616
00:40:19,588 --> 00:40:22,852
this script, but this doesn't work well at

617
00:40:22,868 --> 00:40:26,284
least today with chain of pipelines

618
00:40:26,324 --> 00:40:29,502
like a build that calls another build. So in the graph in

619
00:40:29,518 --> 00:40:33,334
the pipeline is not working well. It makes

620
00:40:33,414 --> 00:40:36,830
one unique block and you cannot see the flow

621
00:40:36,862 --> 00:40:40,910
is a bit hard to get. So this could be done automatically.

622
00:40:41,102 --> 00:40:45,394
But we decided to place hard coded

623
00:40:45,694 --> 00:40:49,126
this block or this small piece of

624
00:40:49,150 --> 00:40:53,006
block to guarantee that we can see in the graph everything.

625
00:40:53,150 --> 00:40:57,044
And we will see later in another screenshot what I need for

626
00:40:57,464 --> 00:41:00,584
this pipeline. In this

627
00:41:00,624 --> 00:41:03,832
slide you can see. So we have a job that generates the

628
00:41:03,848 --> 00:41:07,168
pipeline. We have then in this case

629
00:41:07,216 --> 00:41:10,528
we are generating for everything. Then we generate for

630
00:41:10,616 --> 00:41:14,744
the base image for AWS, for Azure and for Kcal,

631
00:41:14,864 --> 00:41:19,816
and then the base image for AWS will generate for

632
00:41:19,840 --> 00:41:23,864
views and for security books and each one will generate

633
00:41:27,084 --> 00:41:31,148
a setup of the environment. Then the test and teardown

634
00:41:31,276 --> 00:41:35,344
and the azure in this case only triggered

635
00:41:36,924 --> 00:41:40,644
in this case that simple case we are only supporting Azure

636
00:41:40,724 --> 00:41:44,184
bios and we are only supporting VMware bios.

637
00:41:44,484 --> 00:41:48,132
Just to show that we can have different numbers

638
00:41:48,188 --> 00:41:52,066
of security boot per cloud and each

639
00:41:52,130 --> 00:41:55,546
one after the base image was built will trigger the

640
00:41:55,570 --> 00:41:59,114
following stage. Here in the

641
00:41:59,154 --> 00:42:04,226
debug VM pipeline we have example of how

642
00:42:04,250 --> 00:42:07,626
the developer can set up the machine run for them

643
00:42:07,650 --> 00:42:11,426
for 1 hour and after 1 hour because we are

644
00:42:11,450 --> 00:42:14,994
using the environment rules

645
00:42:15,114 --> 00:42:18,746
from the GitHub, it automatically will wait for

646
00:42:18,770 --> 00:42:22,218
1 hour and then you trigger the tier dump. So you have 1 hour

647
00:42:22,266 --> 00:42:25,314
window to do whatever you want inside this machine.

648
00:42:25,434 --> 00:42:29,090
Then later you lose access and the machine will be destroyed together

649
00:42:29,162 --> 00:42:33,334
with everything that was deployed on the first job.

650
00:42:34,314 --> 00:42:37,594
Some crucial takeaways. So we

651
00:42:37,634 --> 00:42:41,010
learned that with this the developers don't need to

652
00:42:41,042 --> 00:42:44,574
deploy the thermal efrain themselves, they just need

653
00:42:44,614 --> 00:42:48,454
to use if they are using integration test is

654
00:42:48,494 --> 00:42:52,350
done by the pipeline if they need to do for some

655
00:42:52,502 --> 00:42:56,874
manual reasons, the dev reasons, so they can

656
00:42:57,174 --> 00:43:01,078
deploy using just passing some parameters

657
00:43:01,166 --> 00:43:04,990
so they pass what they want to use and that will automatically

658
00:43:05,022 --> 00:43:08,542
apply for that. The worst case scenario that

659
00:43:08,598 --> 00:43:13,054
we identified was 3 hours. So we changed the hardened

660
00:43:13,094 --> 00:43:16,958
and then we built everything and test so it takes 3

661
00:43:17,006 --> 00:43:20,910
hours. So if you fired a CVE in the

662
00:43:20,942 --> 00:43:24,222
hardened in the or a

663
00:43:24,358 --> 00:43:27,606
problem, a security issue in the harden,

664
00:43:27,670 --> 00:43:30,766
we can that we create APIs,

665
00:43:30,830 --> 00:43:34,422
we merge and then we have in 3 hours everything tested

666
00:43:34,478 --> 00:43:38,690
and working ready to be patched

667
00:43:38,842 --> 00:43:41,534
to the marketplace. If we need,

668
00:43:42,274 --> 00:43:45,674
we can add easily my providers without affecting the build

669
00:43:45,714 --> 00:43:49,754
and the testing timing because they run in parallel so

670
00:43:49,794 --> 00:43:54,334
they are not depending on each other. And because we are using

671
00:43:55,034 --> 00:43:58,402
infrastructure code principles along with the pin versions,

672
00:43:58,578 --> 00:44:02,382
it allows us to find bugs faster. Because if

673
00:44:02,438 --> 00:44:06,318
we change something, one proportion

674
00:44:06,486 --> 00:44:09,630
for example, and something start to

675
00:44:09,662 --> 00:44:12,966
break for some reason we know okay,

676
00:44:13,030 --> 00:44:17,034
that was working with that version. The new version is not working. So we identified

677
00:44:17,494 --> 00:44:20,990
what was the reason of the break and

678
00:44:21,102 --> 00:44:24,382
the pipeline is modified. So the difference between the

679
00:44:24,398 --> 00:44:28,102
cloud providers are self contained

680
00:44:28,158 --> 00:44:31,738
so they don't affect the rest of the pipeline

681
00:44:31,786 --> 00:44:34,254
or outside of the components.

682
00:44:35,994 --> 00:44:39,978
Here I placed some links where you can learn

683
00:44:40,146 --> 00:44:43,162
how to use this stack.

684
00:44:43,338 --> 00:44:46,690
I think this stack is pretty nice so you can have

685
00:44:46,842 --> 00:44:50,794
very good get started. So if you want to have

686
00:44:50,874 --> 00:44:54,866
some similar implementations on your

687
00:44:55,010 --> 00:44:59,236
pipeline you can start looking into these links

688
00:44:59,260 --> 00:45:02,972
to get some knowledge. And here are my

689
00:45:03,068 --> 00:45:06,324
social networks so you can find me on LinkedIn,

690
00:45:06,404 --> 00:45:10,564
you can send me a DM and be happy to answer

691
00:45:10,724 --> 00:45:13,940
any question that you have from this talk or

692
00:45:13,972 --> 00:45:17,444
if you want have more details how to about

693
00:45:17,484 --> 00:45:21,424
some implementations or any other subject.

694
00:45:21,744 --> 00:45:25,680
Happy to be answering your

695
00:45:25,712 --> 00:45:29,484
DM and if you want to follow me on GitHub here is

696
00:45:30,344 --> 00:45:34,184
my profile as well. So I appreciate

697
00:45:34,224 --> 00:45:37,640
your time to listen to my presentation. I hope you have

698
00:45:37,672 --> 00:45:41,720
enjoyed this session and have a good conference as

699
00:45:41,752 --> 00:45:41,824
well.

