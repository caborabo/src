1
00:00:25,090 --> 00:00:29,558
Hi everyone, welcome to Conforted to Cloud Native 2024.

2
00:00:29,724 --> 00:00:33,362
I'm very happy to be part of this year's Cloud native

3
00:00:33,426 --> 00:00:36,966
conference and I'll be walking you through about how you

4
00:00:36,988 --> 00:00:41,090
can leverage AWS to build a comprehensive observability maturity

5
00:00:41,170 --> 00:00:44,406
model which will take your observability from reactive to

6
00:00:44,428 --> 00:00:47,400
autonomous. You had to ask this question,

7
00:00:47,770 --> 00:00:51,402
are you working for a machine or machines

8
00:00:51,466 --> 00:00:54,814
are working for you? It's middle of the night, you get a call

9
00:00:54,852 --> 00:00:59,194
out and you have to open your laptop and start working. I am afraid

10
00:00:59,242 --> 00:01:02,938
that little means you are working for machine. So what you

11
00:01:02,964 --> 00:01:06,862
have to understand is how you can take it to more of autonomous

12
00:01:06,926 --> 00:01:10,500
way so that machines will start working for you.

13
00:01:13,270 --> 00:01:17,110
During my presentation I'll walk you through about why

14
00:01:17,180 --> 00:01:20,520
observability is important, especially in cloud native area,

15
00:01:20,970 --> 00:01:24,882
and why you need to focus on observability

16
00:01:24,946 --> 00:01:29,462
maturity. The topic of my presentation is mainly around the

17
00:01:29,516 --> 00:01:32,902
maturity model which I have came up with and the pillars

18
00:01:32,966 --> 00:01:36,506
around that. And I'll go more into details about the

19
00:01:36,528 --> 00:01:40,586
maturity model where it's a four state maturity, how you can take it

20
00:01:40,608 --> 00:01:44,894
from reactive to autonomous, and then we will talk about some

21
00:01:44,932 --> 00:01:48,334
of the implementation guidelines where you are able to

22
00:01:48,372 --> 00:01:51,870
leverage these when you are implementing and you

23
00:01:51,940 --> 00:01:55,170
start your own AWS observability journey.

24
00:01:55,670 --> 00:01:59,154
It's very important when you are implementing a maturity model to

25
00:01:59,192 --> 00:02:03,246
ensure that you are measuring business outcomes.

26
00:02:03,358 --> 00:02:07,266
Every step of the way you try to see what is that value you

27
00:02:07,288 --> 00:02:10,902
are generating to your business. Unless you do that, it will be just

28
00:02:10,956 --> 00:02:14,386
another approach and your business partners

29
00:02:14,418 --> 00:02:17,782
will not see the expected benefits. So it's very important.

30
00:02:17,916 --> 00:02:21,766
We kind of have an ability to measure everything and then see how it's

31
00:02:21,798 --> 00:02:25,622
impacting the overall, the business goals

32
00:02:25,766 --> 00:02:29,434
and other things. And then we'll wrap it up with going through

33
00:02:29,472 --> 00:02:33,482
some of the best practices pitfalls you have to avoid.

34
00:02:33,626 --> 00:02:37,262
And also, I'll briefly talk about my predictions for cloud

35
00:02:37,316 --> 00:02:39,040
native observability in future.

36
00:02:41,490 --> 00:02:45,742
So moving on. As you might already aware, cloud native

37
00:02:45,806 --> 00:02:49,602
is not the buzzword now. So everyone is almost in the cloud

38
00:02:49,736 --> 00:02:53,266
or like partially already move

39
00:02:53,288 --> 00:02:57,700
into the cloud as well. So cloud native is,

40
00:02:58,310 --> 00:03:01,574
even though it's simplifying lot of stuff. When you are moving

41
00:03:01,612 --> 00:03:05,078
from your on premise data centers to cloud, it's cutting over a

42
00:03:05,084 --> 00:03:08,986
lot of overheads, but it has its own complexities as

43
00:03:09,008 --> 00:03:13,050
well. So one of the key complexity

44
00:03:13,630 --> 00:03:17,226
thing which is bringing is the distributed nature due to

45
00:03:17,248 --> 00:03:21,670
the applications are nowadays heavily

46
00:03:21,830 --> 00:03:25,454
dependent on microservices architectures and there

47
00:03:25,492 --> 00:03:29,306
are a lot of upstreams and downstreams this naturally results.

48
00:03:29,418 --> 00:03:33,162
Our systems are pretty much distributed and very complex

49
00:03:33,226 --> 00:03:36,758
and hard to track. And also most of our Trixa

50
00:03:36,794 --> 00:03:40,126
systems are dynamic in nature. So that means there will be auto

51
00:03:40,158 --> 00:03:44,350
scaling happening, there will be other, the dynamic elasticity

52
00:03:44,430 --> 00:03:49,910
is there. So that is required a new way of doing

53
00:03:49,980 --> 00:03:53,622
observability, because the traditional way of doing

54
00:03:53,756 --> 00:03:57,490
the monitoring and managing and operations

55
00:03:57,570 --> 00:04:01,366
will not work. And of course we have the containers,

56
00:04:01,478 --> 00:04:05,114
we have the continuous integration and deployments. And this

57
00:04:05,152 --> 00:04:09,350
is doing is it has increased the production velocity.

58
00:04:09,510 --> 00:04:13,854
This has resulted in, we have lot of complexities in

59
00:04:13,972 --> 00:04:17,726
our cloud native solutions. So this is

60
00:04:17,908 --> 00:04:21,738
a recipe for, again another disaster

61
00:04:21,834 --> 00:04:25,434
unless you plan properly. So what we are suggesting

62
00:04:25,482 --> 00:04:29,106
is the traditional monitoring will fall about when

63
00:04:29,128 --> 00:04:32,994
you are in cloud native. So you have to look at observability and

64
00:04:33,032 --> 00:04:36,614
you have to look at what are the ways how you can

65
00:04:36,652 --> 00:04:41,270
get the benefit of cloud as well. So in nutshell,

66
00:04:42,010 --> 00:04:45,298
observability is a key part of your cloud native journey.

67
00:04:45,394 --> 00:04:49,198
Without observability you will definitely fall apart

68
00:04:49,314 --> 00:04:52,010
and you will not achieve your end objectives.

69
00:04:54,590 --> 00:04:58,522
So moving on, why you think we need a maturity model?

70
00:04:58,656 --> 00:05:02,140
So there are lot of reasons. One is that

71
00:05:02,530 --> 00:05:05,854
not a technical reason, but one of the main thing

72
00:05:05,892 --> 00:05:10,382
is you need to have a north star. So when you start your

73
00:05:10,516 --> 00:05:14,058
observability journey, you'll probably start in someplace,

74
00:05:14,154 --> 00:05:17,266
but you want to know where you are heading and you want to

75
00:05:17,288 --> 00:05:20,558
have kind of a decent objectives

76
00:05:20,734 --> 00:05:24,306
in a particular timeline so that you are able to work with your

77
00:05:24,328 --> 00:05:28,062
resources and then able to go in that direction.

78
00:05:28,206 --> 00:05:31,654
So one of the main thing is if you don't have a maturity model,

79
00:05:31,772 --> 00:05:35,606
you don't know how to measure the quality and you

80
00:05:35,628 --> 00:05:39,394
don't know where you stand when it comes to the rest of the industry.

81
00:05:39,522 --> 00:05:43,542
So it's very important that you kind of have an observability maturity

82
00:05:43,606 --> 00:05:47,258
model. Doesn't mean that you will have to stick to

83
00:05:47,344 --> 00:05:50,826
what I am presenting today, but you can take it, do a little bit

84
00:05:50,848 --> 00:05:54,638
of customizations to suit your needs and then probably make it to a

85
00:05:54,644 --> 00:05:58,800
blueprint where you can look into that and from there you can start

86
00:05:59,410 --> 00:06:03,262
your observability journey. So as I said

87
00:06:03,316 --> 00:06:06,834
earlier, the maturity model is very important because that

88
00:06:06,872 --> 00:06:08,450
is we are not stuck.

89
00:06:10,790 --> 00:06:14,446
So when we are building an AWS based observability,

90
00:06:14,638 --> 00:06:18,118
what are the key pillars? So obviously there are a

91
00:06:18,124 --> 00:06:21,846
lot of pillars, and I'm going to touch upon few. So one

92
00:06:21,868 --> 00:06:26,200
of the main thing is logs. As you might know, logs are

93
00:06:26,890 --> 00:06:29,994
the most ancient type of

94
00:06:30,032 --> 00:06:33,450
observability element. It would have been there

95
00:06:33,520 --> 00:06:36,650
when the distributed systems or the computer systems started.

96
00:06:36,800 --> 00:06:40,086
Syslog is kind of like the most oldest logs

97
00:06:40,118 --> 00:06:43,518
we might know, and logs have been used as a

98
00:06:43,604 --> 00:06:47,070
way of auditing or even troubleshooting purpose.

99
00:06:47,410 --> 00:06:51,070
And then comes the metrics. Metric is usually a number

100
00:06:51,220 --> 00:06:55,282
which is providing indication of how something

101
00:06:55,336 --> 00:06:59,154
is working. So metrics generally are

102
00:06:59,272 --> 00:07:02,190
being used to trigger alerts,

103
00:07:02,270 --> 00:07:05,618
because we have the metrics and it's easy for us to set a

104
00:07:05,624 --> 00:07:08,898
threshold or kind of like a profile based alerting,

105
00:07:08,994 --> 00:07:12,226
where we can get this benefit of using metrics

106
00:07:12,258 --> 00:07:15,926
to alert us. So metrics are very important aspects of

107
00:07:15,948 --> 00:07:20,794
observability, because that allow us to understand some

108
00:07:20,832 --> 00:07:23,958
of the internal state of our systems.

109
00:07:24,134 --> 00:07:28,620
Then tracing. Tracing is probably

110
00:07:30,110 --> 00:07:34,554
the newest kid in the block, where it's about trying

111
00:07:34,592 --> 00:07:38,334
to understand how your code is doing. So we are good at

112
00:07:38,372 --> 00:07:41,214
looking at the logs and going through what things are happening.

113
00:07:41,332 --> 00:07:44,654
But you have to understand, logs are a little limited and

114
00:07:44,692 --> 00:07:48,114
sometimes it might not provide you the exact details you are looking for,

115
00:07:48,232 --> 00:07:51,650
but when it comes to tracing, traces will provide you that

116
00:07:51,720 --> 00:07:54,962
exact unit of work. What is your code is doing,

117
00:07:55,096 --> 00:07:58,534
you can able to trace back into the method level and

118
00:07:58,572 --> 00:08:02,834
even to the database queries level. So the traces are very powerful

119
00:08:02,882 --> 00:08:06,582
thing which is allow you to especially help

120
00:08:06,636 --> 00:08:09,846
you in troubleshooting issues. And then I don't

121
00:08:09,878 --> 00:08:13,498
have to spend time on the alarms, you have to have the right

122
00:08:13,584 --> 00:08:17,382
alarms in place so that you get automated call outs

123
00:08:17,446 --> 00:08:19,820
and you are in.

124
00:08:20,590 --> 00:08:24,382
But what we have to understand is automated call out is not

125
00:08:24,436 --> 00:08:27,646
the way to go, but you have to understand, is there a

126
00:08:27,668 --> 00:08:31,866
way I can automate it? I can get systems

127
00:08:31,898 --> 00:08:35,582
to resolve itself, or the self healing capabilities,

128
00:08:35,646 --> 00:08:39,346
the autonomous work, which I'm going to talk about. So again,

129
00:08:39,448 --> 00:08:43,218
alarms are kind of like very early,

130
00:08:43,304 --> 00:08:47,486
or like primarily things, but you have to have some alarms

131
00:08:47,598 --> 00:08:50,934
in case your autonomous things are not working. And then of course

132
00:08:50,972 --> 00:08:54,454
you'll have to have dashboards. Canneries are nothing but about

133
00:08:54,572 --> 00:08:58,566
doing some synthetic testing in your application. So it's good that

134
00:08:58,588 --> 00:09:01,894
we are looking at our end users behaviors, what they are doing,

135
00:09:02,012 --> 00:09:05,286
all the service calls, and we have kind of a full stack observable

136
00:09:05,318 --> 00:09:09,002
to our application. But what if that customers have a network issue

137
00:09:09,056 --> 00:09:12,398
or some other issues where those are outside our control?

138
00:09:12,564 --> 00:09:15,850
So having a synthetic monitor which is trying to mimic

139
00:09:15,930 --> 00:09:19,246
actual end user behavior will help us here,

140
00:09:19,348 --> 00:09:23,582
because with this we are able to mimic end user the

141
00:09:23,636 --> 00:09:27,202
actions, behaviors and then get an alert when

142
00:09:27,256 --> 00:09:30,418
our synthetic monitor is hitting issues. So this is

143
00:09:30,424 --> 00:09:33,874
a good way of keeping track of things and being on top

144
00:09:33,912 --> 00:09:37,234
of our systems and real user monitoring is very

145
00:09:37,272 --> 00:09:41,574
important. It's about front end monitoring, it's about trying to understand the

146
00:09:41,612 --> 00:09:44,502
exact customer experience your end users are getting.

147
00:09:44,636 --> 00:09:48,498
And of course you'll have to do your infrastructure monitoring, network monitoring,

148
00:09:48,594 --> 00:09:52,050
security and finally be mindful of cost as well.

149
00:09:52,140 --> 00:09:55,306
Because especially in AWS, you have to make a

150
00:09:55,328 --> 00:09:58,906
decision when to enable the detailed logging, even though it might be

151
00:09:58,928 --> 00:10:02,886
costly. You might have to make a decision when to enable my anomaly

152
00:10:02,918 --> 00:10:06,346
detections and other great features AWS is

153
00:10:06,368 --> 00:10:09,866
providing. And these will obviously have some cost associated

154
00:10:09,898 --> 00:10:13,022
with that. So you will have to start balancing your

155
00:10:13,156 --> 00:10:16,786
needs with the cost as well. So in high level, these are

156
00:10:16,808 --> 00:10:20,466
the key pillars of observability. So observability, if I

157
00:10:20,488 --> 00:10:24,386
just trying to remind you, is about approach based on

158
00:10:24,408 --> 00:10:27,506
the application emitted telemetry data

159
00:10:27,608 --> 00:10:31,414
trying to understand system's internal state. The more we

160
00:10:31,452 --> 00:10:35,158
understand the system's internal estate, we are in control of

161
00:10:35,244 --> 00:10:38,006
ensuring that the systems are working fine.

162
00:10:38,108 --> 00:10:41,626
And in case if we identify that internal states are kind

163
00:10:41,648 --> 00:10:45,562
of like deteriorating, we are able to take actions in

164
00:10:45,616 --> 00:10:48,698
advance so that end user customer experience

165
00:10:48,784 --> 00:10:52,334
will not get impacted. And what is our mission here?

166
00:10:52,452 --> 00:10:55,998
Our mission is to ensure we reduce or

167
00:10:56,084 --> 00:11:00,170
completely eliminate anything which can impact our end users

168
00:11:00,250 --> 00:11:03,754
customer experience. Because what we are trying to do is ensure that

169
00:11:03,812 --> 00:11:07,780
our systems are reliable and available as well.

170
00:11:08,550 --> 00:11:12,014
So the key pillars of observability is generally locks,

171
00:11:12,062 --> 00:11:15,394
metrics, traces, but you have to add other things as

172
00:11:15,432 --> 00:11:19,030
well that will complement your observability journey.

173
00:11:20,650 --> 00:11:23,320
So moving on, what are the key,

174
00:11:24,570 --> 00:11:28,962
the levels we are referring when we are saying observability model

175
00:11:29,116 --> 00:11:32,934
here, these are the four levels I am referring.

176
00:11:33,062 --> 00:11:36,346
So first model is reactive, you can call it more for

177
00:11:36,448 --> 00:11:40,506
keeping your lights on, where it's about just

178
00:11:40,608 --> 00:11:44,526
doing the basics to ensure that you are kind of like getting

179
00:11:44,628 --> 00:11:48,382
alerts when the systems goes down and the next level is being

180
00:11:48,436 --> 00:11:52,430
proactive. So it's about doing things little more

181
00:11:52,500 --> 00:11:56,478
and being little advanced in detecting and fixing

182
00:11:56,574 --> 00:11:59,826
the issues which can cause impact on end

183
00:11:59,848 --> 00:12:03,730
user customer experience. And then predictive. The third level

184
00:12:03,800 --> 00:12:07,630
is the way to go where that will allow you to predict

185
00:12:07,710 --> 00:12:11,046
something because being proactive is good,

186
00:12:11,148 --> 00:12:14,678
but if that is still having an impact on the inducer experience,

187
00:12:14,844 --> 00:12:18,482
that is not so great. So what we want is to predict

188
00:12:18,546 --> 00:12:21,654
early, so that we identify symptoms

189
00:12:21,702 --> 00:12:25,114
early so that we can fix it even before those get

190
00:12:25,152 --> 00:12:27,980
materialized and have impact on the end user experience.

191
00:12:28,430 --> 00:12:31,894
And the final cloud, the Nirvana state is the autonomous

192
00:12:31,942 --> 00:12:35,726
level where our systems are able to look at all the telemetry data.

193
00:12:35,828 --> 00:12:39,674
And with that it's able to make a judgment

194
00:12:39,722 --> 00:12:43,534
of its internal state. And if it sees that it's not

195
00:12:43,572 --> 00:12:47,086
going in the right direction, it's able to do some self healing

196
00:12:47,118 --> 00:12:50,658
remediation by its own so that it's able to keep that

197
00:12:50,744 --> 00:12:54,306
internal state. The key thing to note is that

198
00:12:54,488 --> 00:12:58,022
observability is about understanding the internal state and

199
00:12:58,076 --> 00:13:01,622
more data we have. We are able to let our

200
00:13:01,676 --> 00:13:05,126
systems to understand its internal state and then take

201
00:13:05,148 --> 00:13:08,178
the precautionary measure, even with us involved.

202
00:13:08,274 --> 00:13:11,306
So that is what we call the autonomous. So if I

203
00:13:11,328 --> 00:13:14,826
come back again reactive, we will have some logs and

204
00:13:14,848 --> 00:13:18,006
probably we'll have some metrics as well. And metrics

205
00:13:18,038 --> 00:13:22,074
are probably the limited and we might not have traces at all,

206
00:13:22,192 --> 00:13:25,886
but we will able to know if our application comes down, we might get some

207
00:13:25,908 --> 00:13:29,566
process alert, infra heavy alerts, and that will able to

208
00:13:29,588 --> 00:13:32,986
do some work. But it's just keeping the insights on. But it's

209
00:13:33,018 --> 00:13:35,300
not necessarily a great customer experience.

210
00:13:37,350 --> 00:13:40,542
Being proactive is you have the access of the logs,

211
00:13:40,606 --> 00:13:43,874
metrics and traces, and with that you are

212
00:13:43,912 --> 00:13:47,654
able to proactively identifying issues. It means

213
00:13:47,772 --> 00:13:51,394
probably you identify some issue and that might still have impact

214
00:13:51,442 --> 00:13:55,494
on customers, but you can still speedify the resolutions. You can

215
00:13:55,532 --> 00:14:00,358
probably identify even your end users. Getting known

216
00:14:00,374 --> 00:14:04,362
to that issues, sometimes it feel little great.

217
00:14:04,496 --> 00:14:08,362
You don't have to wait until your customers reporting and telling something

218
00:14:08,416 --> 00:14:12,106
is down or someplace there's an issue, but you kind of

219
00:14:12,128 --> 00:14:15,358
like get to know it first. And probably you can send some comms and you

220
00:14:15,364 --> 00:14:19,146
can be on top of the entire incident window.

221
00:14:19,258 --> 00:14:22,782
That is again not a great place to be, but it's still, it's better than

222
00:14:22,836 --> 00:14:25,550
keeping insights on or being reactive.

223
00:14:25,710 --> 00:14:29,502
Predictive is using these metrics, logs and traces,

224
00:14:29,646 --> 00:14:33,390
and being on top of the game, looking at the anomalies,

225
00:14:33,470 --> 00:14:37,190
forecasting things, looking at what is happening

226
00:14:37,340 --> 00:14:41,382
outside our BAU operations with that,

227
00:14:41,436 --> 00:14:44,694
come up with some intelligent predictions and then based on that,

228
00:14:44,732 --> 00:14:47,974
take the actions so that we can actually eliminate those

229
00:14:48,092 --> 00:14:51,818
issues which can have a bad impact on end user customer

230
00:14:51,904 --> 00:14:55,882
experience. And then finally autonomous. I have kind of like

231
00:14:55,936 --> 00:15:00,074
touch upon when I'm going through these four levels. Initially it's about

232
00:15:00,192 --> 00:15:03,902
looking at things and trying to understand when and

233
00:15:03,956 --> 00:15:08,094
where system internal estates is getting changed, and then

234
00:15:08,132 --> 00:15:11,614
what actions the system itself can take to ensure that it

235
00:15:11,652 --> 00:15:14,990
can bring its internal estate back to the normal

236
00:15:15,070 --> 00:15:18,878
state where it can able to self heal,

237
00:15:18,974 --> 00:15:23,074
remediate and do all those things so that it will be even far

238
00:15:23,192 --> 00:15:27,222
above the predictive level. And one of the questions you might ask

239
00:15:27,276 --> 00:15:30,758
is, does all your systems or the

240
00:15:30,764 --> 00:15:34,262
clients which you are working need to be at the autonomous level?

241
00:15:34,396 --> 00:15:38,242
The answer is no. It depend on the complexity,

242
00:15:38,306 --> 00:15:41,782
mission criticalness, it depend on lot of factors.

243
00:15:41,926 --> 00:15:45,274
So we are not advising everyone to be at autonomous level,

244
00:15:45,392 --> 00:15:49,034
but obviously everyone should not be at reactive level as

245
00:15:49,072 --> 00:15:53,106
well. For most of the systems between proactive and predictive

246
00:15:53,158 --> 00:15:57,514
will do the job. It will be able to balance

247
00:15:57,562 --> 00:16:00,814
your operations with the cost as well, and also provide some

248
00:16:00,852 --> 00:16:03,600
greater benefits to the end users and the business.

249
00:16:04,210 --> 00:16:08,340
But if you are in a mission critical system, any outage or

250
00:16:08,790 --> 00:16:11,810
bad customer experience will cost you money.

251
00:16:11,960 --> 00:16:15,678
And it's important for you to keep track of what the end users

252
00:16:15,694 --> 00:16:19,106
are feeling. Then obviously you will have to go to the predictive

253
00:16:19,138 --> 00:16:22,578
and autonomous level where you can leverage

254
00:16:22,674 --> 00:16:26,294
these levels to ensure that you are on top

255
00:16:26,332 --> 00:16:30,074
of your operations. So now let's go through the

256
00:16:30,112 --> 00:16:33,446
key pillars, which we discussed earlier

257
00:16:33,558 --> 00:16:37,594
with the four levels of maturity and trying to understand what

258
00:16:37,632 --> 00:16:40,906
the maturity levels mean for each pillar. So when it

259
00:16:40,928 --> 00:16:44,302
comes to logs reactive approach, you are simply using

260
00:16:44,356 --> 00:16:48,062
logs for troubleshooting. Customers are reporting some issue

261
00:16:48,196 --> 00:16:51,706
and then you are acknowledging that and you simply

262
00:16:51,738 --> 00:16:55,902
refer to the logs and then start troubleshooting and trying to find answers.

263
00:16:56,046 --> 00:17:00,994
But being proactive is that the

264
00:17:01,032 --> 00:17:04,370
exceptions are getting visible in the logs. And probably

265
00:17:04,440 --> 00:17:07,506
you are trying to get some alerts out of that so that you

266
00:17:07,528 --> 00:17:10,646
will get alerts and you can be little proactive in trying

267
00:17:10,668 --> 00:17:14,226
to identify issues. Obviously this will improve your meantime

268
00:17:14,258 --> 00:17:17,638
to detection. And with this you are able to

269
00:17:17,724 --> 00:17:21,850
kind of like be a little bit on top. And predictive is you

270
00:17:21,920 --> 00:17:25,254
are looking at all the logs and you are probably doing advanced

271
00:17:25,302 --> 00:17:29,110
anomaly detections. And with that you see the anomalies in advance.

272
00:17:29,190 --> 00:17:32,874
The moment you see something with going outside your

273
00:17:32,912 --> 00:17:36,214
BAU or the home internal

274
00:17:36,262 --> 00:17:39,318
state, you identify and then you can kind of like

275
00:17:39,344 --> 00:17:43,214
do a lot of predictions on top of that. Autonomous is that looking

276
00:17:43,252 --> 00:17:47,154
at those and then trying to do call relation and then doing kind

277
00:17:47,192 --> 00:17:50,802
of ability to trigger the other

278
00:17:50,856 --> 00:17:54,674
workflows which can actually do autonomous operations or

279
00:17:54,712 --> 00:17:57,946
the self healing metrics. Again, the reactive

280
00:17:57,998 --> 00:18:02,054
level, you will have the basic metrics and proactive, you will have

281
00:18:02,092 --> 00:18:05,858
some threshold based alerting, but when it comes to predictive,

282
00:18:05,954 --> 00:18:09,654
and you will use lot of anomaly detection capabilities

283
00:18:09,782 --> 00:18:13,818
and these capabilities will help you to predict issues

284
00:18:13,904 --> 00:18:18,090
in advance and also then build your autonomous capabilities.

285
00:18:18,430 --> 00:18:21,926
Tracing usually in the keeping the lights

286
00:18:21,958 --> 00:18:25,438
on the reactive level you will not see tracing proactive level. You will

287
00:18:25,444 --> 00:18:28,762
have some basic tracings, but when it comes to predictive,

288
00:18:28,826 --> 00:18:32,010
you probably have tracing, which is a time driven,

289
00:18:32,090 --> 00:18:35,162
and then you will have kind of a topology base as well,

290
00:18:35,236 --> 00:18:38,434
so that it's more of a distributed tracing where you are

291
00:18:38,472 --> 00:18:41,694
able to propagate your traces, the context,

292
00:18:41,742 --> 00:18:45,230
and that you can make a correlation between different systems,

293
00:18:45,310 --> 00:18:48,966
and then you are able to identify a lot of issues.

294
00:18:49,068 --> 00:18:53,666
So this is more of a full stack observability level in nutshell.

295
00:18:53,778 --> 00:18:57,350
And this will give you great benefits when come to being

296
00:18:57,420 --> 00:19:00,698
predictive. And you can definitely use this

297
00:19:00,784 --> 00:19:04,790
because with the traces you are able to identify actual root causes,

298
00:19:04,870 --> 00:19:08,890
and then you can able to trigger your autonomous workflows.

299
00:19:09,310 --> 00:19:12,702
The canaries are the synthetic monitoring, and while

300
00:19:12,756 --> 00:19:16,974
going through you will start from having no canneries to

301
00:19:17,012 --> 00:19:20,746
have all your key journeys being monitored by synthetic

302
00:19:20,778 --> 00:19:24,158
monitors. And real user monitoring is a very important

303
00:19:24,324 --> 00:19:27,794
one, where you will start it from proactive level

304
00:19:27,912 --> 00:19:31,314
and then you will improve it. When it comes to predictive level and

305
00:19:31,352 --> 00:19:35,278
when it comes to autonomous, you will obviously use AI and ML

306
00:19:35,374 --> 00:19:38,934
to improve the capabilities and then also to drive this

307
00:19:38,972 --> 00:19:41,640
autonomous capabilities as well.

308
00:19:42,490 --> 00:19:46,306
So infrastructure monitoring, again, when it comes to predictive

309
00:19:46,338 --> 00:19:48,994
autonomous, it's about bringing in AI,

310
00:19:49,042 --> 00:19:52,918
ML and being on top of your operations, and it's

311
00:19:52,934 --> 00:19:55,274
the same for the network and security as well.

312
00:19:55,392 --> 00:19:58,890
And those will actually allow

313
00:19:58,960 --> 00:20:02,174
you to keep walking in this

314
00:20:02,212 --> 00:20:06,378
journey. Achieving the observability

315
00:20:06,554 --> 00:20:10,026
objectives and cost is a very important factor.

316
00:20:10,138 --> 00:20:13,530
And from reactive to autonomous,

317
00:20:13,610 --> 00:20:16,426
even though there is a cost improvement increased,

318
00:20:16,538 --> 00:20:19,858
but with the autonomous nature or the predictive, you are able to

319
00:20:19,864 --> 00:20:22,990
bring down lot of human involvement, lot of human effort,

320
00:20:23,070 --> 00:20:26,366
and this will resulted in more gains for you as well.

321
00:20:26,488 --> 00:20:29,766
So you might start with little bit of expensive when you are starting your

322
00:20:29,788 --> 00:20:33,846
observability journey, but you can reduce the cost definitely when

323
00:20:33,868 --> 00:20:35,350
you are ending your journey.

324
00:20:37,930 --> 00:20:42,006
So now let's look at how we can implement a comprehensive

325
00:20:42,118 --> 00:20:45,482
observability setup using

326
00:20:45,536 --> 00:20:49,146
AWS. So in this example, this is

327
00:20:49,168 --> 00:20:52,634
an application hosted in AWS where you have

328
00:20:52,672 --> 00:20:56,382
a database and you have microservices and you have front

329
00:20:56,436 --> 00:21:00,574
end code as well, and you have upstreams, downstreams and

330
00:21:00,612 --> 00:21:03,646
end users. So in high level, when we are trying

331
00:21:03,668 --> 00:21:07,386
to implement a comprehensive observability setup, what we need

332
00:21:07,428 --> 00:21:10,798
is we have to implement RAM, which is real user monitoring.

333
00:21:10,894 --> 00:21:15,058
That is usually where I start, because I would like to know how

334
00:21:15,144 --> 00:21:18,834
my end users are feeling. RAM is all about understanding front

335
00:21:18,872 --> 00:21:22,358
end performance, and front end performance is the most important thing

336
00:21:22,444 --> 00:21:25,590
because that's what our end users will see.

337
00:21:25,740 --> 00:21:29,522
So next we'll try to implement APM or the application performance

338
00:21:29,586 --> 00:21:33,114
with distributed tracing, so that we know from end to

339
00:21:33,152 --> 00:21:36,970
end how things are happening. And we also have a full control of

340
00:21:37,040 --> 00:21:40,346
our code. What's important is to understand how

341
00:21:40,368 --> 00:21:44,458
is our code is behaving and with that we can understand the bottlenecks

342
00:21:44,474 --> 00:21:48,602
and the other issues so that we can rectify. So enabling

343
00:21:48,666 --> 00:21:51,886
application performance monitoring and distributed tracing or

344
00:21:51,908 --> 00:21:55,786
the full stack observability is very important. With the distributed tracing,

345
00:21:55,898 --> 00:21:59,554
when a user request comes in, we are able to correlate that

346
00:21:59,592 --> 00:22:02,814
with what's happening in the front end, what's happening in the microservice

347
00:22:02,862 --> 00:22:06,706
level, and what's happening in the database as well. Traditionally if

348
00:22:06,728 --> 00:22:10,454
you see a database query which is taking time, what happens is

349
00:22:10,492 --> 00:22:13,814
that your DBS or the SMEs will identify, they will

350
00:22:13,852 --> 00:22:17,126
reach out to the DevOps and the SRE teams, but they will

351
00:22:17,148 --> 00:22:20,586
sometimes struggle unless they have access to code or

352
00:22:20,688 --> 00:22:24,314
even they have access to code. They will search, but they might have

353
00:22:24,432 --> 00:22:27,900
trouble identifying which part of

354
00:22:28,270 --> 00:22:31,666
module or sometimes which journey this is getting triggered.

355
00:22:31,798 --> 00:22:35,146
Even in case if they are good with the code, they identify

356
00:22:35,338 --> 00:22:39,326
the module and everything. It will be next to impossible for

357
00:22:39,348 --> 00:22:43,262
them to isolate and identify which

358
00:22:43,316 --> 00:22:47,346
user, which part of user profiles has invoked this

359
00:22:47,448 --> 00:22:50,526
because there's no connect. But with distributed tracing

360
00:22:50,638 --> 00:22:54,034
we are able to propagate the trace context which will take from

361
00:22:54,072 --> 00:22:57,254
front end to the microservice to our database layers as well,

362
00:22:57,372 --> 00:23:01,110
where with the trace propagation we are able to understand

363
00:23:01,260 --> 00:23:04,534
the queries which is getting run by or

364
00:23:04,572 --> 00:23:08,450
queries which got triggered due to the end user request.

365
00:23:08,530 --> 00:23:12,314
So this is very powerful. This will enable us to understand and

366
00:23:12,352 --> 00:23:16,314
go through and identify the bottlenecks, issues in our

367
00:23:16,352 --> 00:23:19,654
code and other errors and everything related

368
00:23:19,702 --> 00:23:23,258
to customer experience which can directly correlate it with our code.

369
00:23:23,424 --> 00:23:26,926
And obviously we'll have to look at the logs and events and we will look

370
00:23:26,948 --> 00:23:30,814
at the metrics. And also you'll have to ensure that as

371
00:23:30,852 --> 00:23:34,522
part of site reliability engineering you define your SLIs,

372
00:23:34,586 --> 00:23:38,254
SLos and error budget, which is again complement

373
00:23:38,302 --> 00:23:42,146
by all your observability goals. And then finally, obviously you will have

374
00:23:42,168 --> 00:23:45,970
to do your infrastructure monitoring as well. And that will actually ensure that

375
00:23:46,040 --> 00:23:47,720
you are on top of your state.

376
00:23:49,610 --> 00:23:53,490
With this. Let's look at some of these key implementation

377
00:23:53,570 --> 00:23:57,110
areas so that you are able to get some idea about

378
00:23:57,180 --> 00:24:01,046
the implementation. So if you are using AWS, you can go into

379
00:24:01,068 --> 00:24:04,410
the real user monitoring where you can configure your application.

380
00:24:04,560 --> 00:24:08,070
It might give you the ability to get a code snippet

381
00:24:08,150 --> 00:24:11,706
which you have to embedded in all your front end code. With that you know

382
00:24:11,728 --> 00:24:15,326
you can enable the real user monitoring. It will allow you to

383
00:24:15,348 --> 00:24:20,238
see the page response times, the page errors and the

384
00:24:20,404 --> 00:24:24,206
epidemics as well, and all the things which is related

385
00:24:24,238 --> 00:24:28,274
to the front end performance. And then

386
00:24:28,312 --> 00:24:32,306
obviously you'll have to configure the cloud watch agent and then

387
00:24:32,328 --> 00:24:35,886
you can configure the relevant prop XMLs

388
00:24:35,918 --> 00:24:39,894
to ensure that you added all your log files and you can ensure that your

389
00:24:39,932 --> 00:24:43,510
logs are getting feeded into the cloudwatch.

390
00:24:45,370 --> 00:24:48,754
And once that happened, ensure that you enable

391
00:24:48,802 --> 00:24:52,906
log anomaly detection because it's very important.

392
00:24:53,088 --> 00:24:56,618
As I said earlier, what usually happen is in the

393
00:24:56,624 --> 00:25:00,266
reactive level when you get ripped, get your end users are

394
00:25:00,288 --> 00:25:03,622
complaining something is not working, you will trail your logs,

395
00:25:03,686 --> 00:25:07,406
you will identify those exceptions, then you will able to understand the

396
00:25:07,428 --> 00:25:11,054
issue and then you will try to come up with fixes. But what is

397
00:25:11,092 --> 00:25:14,622
great is once you identify the issues, probably someone will ask,

398
00:25:14,676 --> 00:25:18,226
can you go back and check when this issue started? And you have seen

399
00:25:18,248 --> 00:25:21,666
this started a couple of hours early or even sometimes a couple of

400
00:25:21,688 --> 00:25:24,914
days early. How great it is that if we are able to

401
00:25:24,952 --> 00:25:28,246
identify this the moment those are appearing. But one

402
00:25:28,268 --> 00:25:32,306
of the challenges how we do, because it can be something unknown

403
00:25:32,418 --> 00:25:36,134
which is not even aware by the development team or which has

404
00:25:36,172 --> 00:25:39,942
been difficult to capture. So with part of the log

405
00:25:39,996 --> 00:25:43,386
anomaly detection, the AI is able to understand what is

406
00:25:43,408 --> 00:25:47,402
the baseline, what are the existing errors, what are the things which is currently happening

407
00:25:47,536 --> 00:25:50,874
and braceline your state. And after

408
00:25:50,912 --> 00:25:54,078
that, on top of there are new errors are happening, new issues,

409
00:25:54,164 --> 00:25:57,742
new behavior changes happening. It's able to alert you.

410
00:25:57,796 --> 00:26:01,294
So log anomaly detection is a very powerful concept which

411
00:26:01,332 --> 00:26:04,626
you should definitely enable, which will provide you

412
00:26:04,728 --> 00:26:07,170
value when you are going through your observability.

413
00:26:08,630 --> 00:26:12,260
And once you enable your traces, you will start seeing

414
00:26:14,310 --> 00:26:18,958
the service map. So you can do this with open telemetry.

415
00:26:19,054 --> 00:26:22,854
And once you do that, the one great feature is that this

416
00:26:22,892 --> 00:26:27,334
map will allow you to see how the requests are getting served. And even

417
00:26:27,372 --> 00:26:29,980
if there are any bottle knocks or anything, it will show.

418
00:26:31,470 --> 00:26:34,906
As I said, traces are the great way because it allows you

419
00:26:34,928 --> 00:26:38,406
to track your request from the browser

420
00:26:38,438 --> 00:26:42,774
level, from the API gateways and to the SQL server.

421
00:26:42,902 --> 00:26:46,814
So like if you see this is about the time the front end is taken

422
00:26:46,932 --> 00:26:50,254
and this is probably about the time where the microservices are

423
00:26:50,292 --> 00:26:53,390
taking. And you can see some of the SQL running as well.

424
00:26:53,460 --> 00:26:57,442
So enabling full stack observability is very important because that

425
00:26:57,496 --> 00:27:00,914
provides you the full control of your state. So you

426
00:27:00,952 --> 00:27:03,458
have the ability to see all your system,

427
00:27:03,544 --> 00:27:07,106
internally state and especially the code. What is

428
00:27:07,128 --> 00:27:10,326
your code doing? But usually what happened is that in

429
00:27:10,348 --> 00:27:13,654
the reactive level you are more infra heavy. You'll see all

430
00:27:13,692 --> 00:27:17,094
the infrastructure and other things. But one thing to

431
00:27:17,132 --> 00:27:21,194
note is that it's the code. It's the code which is serving your

432
00:27:21,232 --> 00:27:25,466
customer request, the code which is doing the processing and other things.

433
00:27:25,568 --> 00:27:29,286
So you had to enable traces and start ensuring

434
00:27:29,398 --> 00:27:33,166
that you enable the full doors to your system where you

435
00:27:33,188 --> 00:27:36,814
can have the full visibility. And once

436
00:27:36,852 --> 00:27:40,366
you're doing that, you will have your metrics enabled as well. So it can be

437
00:27:40,388 --> 00:27:44,090
your intra level metric, application metric, performance metric,

438
00:27:44,170 --> 00:27:47,806
and you can have your custom metric as well. If you are using lambda,

439
00:27:47,838 --> 00:27:51,502
you can have the serverless based metrics as well, the database metrics.

440
00:27:51,566 --> 00:27:54,900
So metrics are everything like metrics are

441
00:27:55,910 --> 00:27:59,442
generally the numbers. Of course, it's always the number where

442
00:27:59,496 --> 00:28:03,286
you are able to, based on that, make lot of decisions and you can see

443
00:28:03,308 --> 00:28:06,674
the performance, and especially you can configure lot of alerting

444
00:28:06,722 --> 00:28:09,610
as well. So metrics will give you those trigger.

445
00:28:10,670 --> 00:28:14,294
And obviously with cloudwatch you are able to enable metric

446
00:28:14,342 --> 00:28:17,722
anomaly detection. So with that you have the power of

447
00:28:17,776 --> 00:28:21,514
not only having the metrics or

448
00:28:21,552 --> 00:28:25,226
not only going with some threshold based alerting, which is a very legacy

449
00:28:25,258 --> 00:28:28,394
or an old way of doing, and then enable

450
00:28:28,522 --> 00:28:31,966
anomalies. So what cloud watches do is it

451
00:28:31,988 --> 00:28:35,546
will start profiling the metric and how the metrics are going

452
00:28:35,588 --> 00:28:39,186
on and how it is changing. And with that it will try

453
00:28:39,208 --> 00:28:43,234
to create upper bound and a lower bound for a

454
00:28:43,272 --> 00:28:46,774
guidelines. And based on that, it will start sending you

455
00:28:46,812 --> 00:28:50,920
alerts if it sees that there are anomalies are happening.

456
00:28:53,050 --> 00:28:57,058
And also in AWS we have code guru. I'm recommending

457
00:28:57,074 --> 00:29:00,310
you to enable code guru for application profiling,

458
00:29:00,390 --> 00:29:04,026
because that will allow you to understand the code performance and

459
00:29:04,048 --> 00:29:07,562
you can correlate it multiple other factors and also

460
00:29:07,616 --> 00:29:11,690
enable the AWS DevOps guru, which will

461
00:29:11,840 --> 00:29:15,102
do a lot of AI ML in your entire account.

462
00:29:15,236 --> 00:29:18,794
So it's a very powerful tool, so that will have full holistic

463
00:29:18,842 --> 00:29:22,762
view of your entire state and ability to identify anomalies

464
00:29:22,826 --> 00:29:23,840
across the board.

465
00:29:26,230 --> 00:29:29,474
So that's kind of like what

466
00:29:29,512 --> 00:29:33,938
is required to implement a comprehensive observability solution in

467
00:29:34,024 --> 00:29:37,554
AWS. Now, let's discuss. One of the key

468
00:29:37,592 --> 00:29:41,302
thing is, so why we are doing this. We are doing this because

469
00:29:41,356 --> 00:29:44,966
we want to ensure our customers are getting the world class customer

470
00:29:45,068 --> 00:29:48,230
experience which our application is designed for.

471
00:29:48,380 --> 00:29:52,294
So while you are building and coming up with the observability

472
00:29:52,422 --> 00:29:56,326
journey, it's very important you clearly define your goals,

473
00:29:56,438 --> 00:29:59,834
how to measure your customer experience and with that trying

474
00:29:59,872 --> 00:30:03,674
to understand is your observability methodology.

475
00:30:03,802 --> 00:30:06,942
The framework allow you to achieve your

476
00:30:06,996 --> 00:30:10,270
customer targets and how it's able to

477
00:30:10,340 --> 00:30:13,614
correlate and identify when things are going wrong.

478
00:30:13,732 --> 00:30:17,218
So you can quickly identify and then fix it.

479
00:30:17,304 --> 00:30:21,026
So I am not going to go into much detail here, but one of

480
00:30:21,048 --> 00:30:24,114
the thing I'm iterating and important thing

481
00:30:24,152 --> 00:30:28,034
is to ensure that you understand your business objectives and

482
00:30:28,072 --> 00:30:31,638
you have a way of measuring it while you are traveling around

483
00:30:31,724 --> 00:30:35,526
level one to level four observability. So each level you

484
00:30:35,548 --> 00:30:38,966
will see the benefits and it's good even before you start

485
00:30:39,068 --> 00:30:42,970
you are able to identify what are the benefits and then see

486
00:30:43,120 --> 00:30:46,426
whether you keep or add some targets to

487
00:30:46,448 --> 00:30:50,010
your journey. Some of the KPIs, if you want to have few

488
00:30:50,080 --> 00:30:53,946
KPIs, is work on your meantime to detection,

489
00:30:54,058 --> 00:30:57,898
meantime to resolution, and meantime between failures

490
00:30:58,074 --> 00:31:01,866
and trying to see your service level objectives

491
00:31:01,978 --> 00:31:05,918
achievement. Because the more you are going from reactive to autonomous,

492
00:31:06,014 --> 00:31:09,470
you should be able to achieve your service level objectives.

493
00:31:09,550 --> 00:31:13,106
And that's a must. Unless we do that, the purpose of

494
00:31:13,128 --> 00:31:16,754
doing observability is not useful

495
00:31:16,802 --> 00:31:20,390
at all. And of course,

496
00:31:20,460 --> 00:31:25,222
as anything, enabling observability in AWS is

497
00:31:25,356 --> 00:31:29,286
pretty much easy. That's what the cloud is providing you. But you

498
00:31:29,308 --> 00:31:32,982
have to ensure you follow some of the best practices. So observability,

499
00:31:33,046 --> 00:31:36,282
as I said, it's about looking at the internal state

500
00:31:36,336 --> 00:31:40,486
of your system. So you must enable your logs and traces

501
00:31:40,598 --> 00:31:44,698
and metrics and you should ensure that in AWS,

502
00:31:44,794 --> 00:31:48,206
wherever needed, you enable your detailed monitoring because that

503
00:31:48,228 --> 00:31:51,834
will really help you as well. And don't forget your traces,

504
00:31:51,962 --> 00:31:55,754
because traces provide what's really happening at your code

505
00:31:55,812 --> 00:31:59,106
level. So that is what's most important thing. Because when

506
00:31:59,128 --> 00:32:02,338
you come to cloud native, most probably it's a

507
00:32:02,344 --> 00:32:06,114
safe guess to say your infrastructure is pretty stable. And then

508
00:32:06,152 --> 00:32:09,766
ensure that you send almost everything into a cloud watch. And then you

509
00:32:09,788 --> 00:32:13,174
have proper dashboards as well so that you are able to have

510
00:32:13,212 --> 00:32:17,314
a look and you are able to have a big picture, holistic picture

511
00:32:17,362 --> 00:32:20,554
of your entire state and what you should

512
00:32:20,592 --> 00:32:24,266
avoid. And definitely ensure that

513
00:32:24,368 --> 00:32:27,638
when you are shipping your logs to Cloudwatch and you're

514
00:32:27,654 --> 00:32:30,870
mindful of retention as well, you don't want to lose your logs.

515
00:32:30,950 --> 00:32:34,366
And when in a week's time you want to troubleshoot an issue. If you

516
00:32:34,388 --> 00:32:38,254
don't see your logs then that's a problem. And ensure that

517
00:32:38,372 --> 00:32:42,542
you have more granular level metrics and others as

518
00:32:42,596 --> 00:32:46,478
traces as well. So that's something which is very important because don't

519
00:32:46,494 --> 00:32:49,794
try to be very high level, because sometimes what you

520
00:32:49,832 --> 00:32:52,370
need is the ground level details.

521
00:32:53,510 --> 00:32:57,438
And when we are working in a very vast complex systems,

522
00:32:57,534 --> 00:33:01,314
it's very easy to forget about some of the critical systems

523
00:33:01,442 --> 00:33:04,706
virtusa of they are not feel like critical.

524
00:33:04,818 --> 00:33:08,750
So ensure that you have a proper way of understanding your critical systems

525
00:33:08,850 --> 00:33:12,634
and ensuring that those are being monitored, observed and everything

526
00:33:12,752 --> 00:33:16,522
you have done. And finally, it's very easy

527
00:33:16,576 --> 00:33:20,742
to have a technology or data siloed observability.

528
00:33:20,886 --> 00:33:24,090
Ensure that all your data observability

529
00:33:24,170 --> 00:33:27,886
telemetry data are centralized and it gives you a

530
00:33:27,908 --> 00:33:28,910
big picture.

531
00:33:33,280 --> 00:33:36,524
And finally, so where the cloud native observability is

532
00:33:36,562 --> 00:33:40,016
heading. So that's a very good question you should ask when you

533
00:33:40,038 --> 00:33:43,052
are coming up with your own observability maturity framework.

534
00:33:43,196 --> 00:33:46,976
So as far as I see immediately what I seeing is lot

535
00:33:46,998 --> 00:33:50,980
of clients are getting adopt into opentelementry because

536
00:33:51,050 --> 00:33:55,056
they are aware of the need of the traces,

537
00:33:55,168 --> 00:33:58,272
the distributed traces enabling full stack observability.

538
00:33:58,416 --> 00:34:02,010
So that will have more way of

539
00:34:02,860 --> 00:34:06,536
the first kind of the requirement for our customers. And then

540
00:34:06,558 --> 00:34:10,072
when it comes to the midterm, I'm thinking lot of people really

541
00:34:10,126 --> 00:34:13,820
start moving into AI ML because the

542
00:34:13,890 --> 00:34:18,188
observability tools are inbuilt, providing them the

543
00:34:18,354 --> 00:34:22,444
ability of doing anomaly detection and ability of doing

544
00:34:22,562 --> 00:34:26,124
the forecasting, ability of doing prediction. And those things

545
00:34:26,162 --> 00:34:29,792
are inbuilt and available and people really start using

546
00:34:29,846 --> 00:34:33,516
capabilities very quickly. And long term vision is it's

547
00:34:33,548 --> 00:34:36,844
about where I started. Do you want to work for a machine

548
00:34:36,892 --> 00:34:40,692
or you want machine to work for you? So ultimate objective of

549
00:34:40,746 --> 00:34:44,560
observability is it's about ensuring that you identify

550
00:34:44,640 --> 00:34:48,132
your system's internal state. And whenever it's getting

551
00:34:48,186 --> 00:34:51,716
slightly changed without human involved, you try to

552
00:34:51,738 --> 00:34:56,068
fix it, the systems try to self heal it. And that is the autonomous

553
00:34:56,164 --> 00:34:58,200
nature which I was discussing.

554
00:35:00,140 --> 00:35:03,816
And finally, my prediction for this year. So if you

555
00:35:03,838 --> 00:35:07,116
see the gardener's magic quadrant, you have seen we

556
00:35:07,138 --> 00:35:10,956
have the leaders as well. Dynatrace, Datadoc, new relic are the

557
00:35:10,978 --> 00:35:14,684
top three. And we have Amazon Web services, also a

558
00:35:14,722 --> 00:35:18,464
leading contender and in the challengers category. I feel

559
00:35:18,502 --> 00:35:22,156
like with all the new advancements

560
00:35:22,268 --> 00:35:26,460
and the announcements and the capabilities unleashed, part of last year's

561
00:35:26,540 --> 00:35:30,256
AWS reinvent, which is about application signals,

562
00:35:30,368 --> 00:35:33,556
which is about the log anomaly detections, which is

563
00:35:33,578 --> 00:35:37,556
about other more improvements and advancements to

564
00:35:37,578 --> 00:35:43,210
the anomalies and other AI based changes

565
00:35:44,460 --> 00:35:47,816
related to Cloudwatch, I'm pretty sure that Amazon Web

566
00:35:47,838 --> 00:35:51,336
service will be in the leaders category when the next time Gardner is going

567
00:35:51,358 --> 00:35:55,144
to release this magic quadrant, so keep your fingers

568
00:35:55,192 --> 00:35:58,828
crossed and I'm pretty sure this will happen

569
00:35:58,914 --> 00:36:01,996
probably this year, and if not next year for sure.

570
00:36:02,178 --> 00:36:05,812
So with that, I hope you enjoy my presentation.

571
00:36:05,976 --> 00:36:10,124
I wanted to ensure that you have an understanding of observability

572
00:36:10,252 --> 00:36:13,760
and you know how to use observability for your AWS.

573
00:36:14,260 --> 00:36:18,210
And observability is a journey. It's about starting from

574
00:36:18,760 --> 00:36:23,284
probably keeping lights on, then going into the proactive level

575
00:36:23,402 --> 00:36:26,996
and then trying to make it to predictive nature and

576
00:36:27,018 --> 00:36:30,100
then finally ending up with autonomous operations.

577
00:36:30,760 --> 00:36:34,196
So thank you very much for listening and in case if

578
00:36:34,218 --> 00:36:37,972
you have any questions you can find me in LinkedIn and

579
00:36:38,106 --> 00:36:41,412
you can also put comments into this video as well,

580
00:36:41,466 --> 00:36:45,032
which we might appreciate. There's a great line of speakers

581
00:36:45,176 --> 00:36:48,732
who are going to speak part of Cloud Native 2024.

582
00:36:48,866 --> 00:36:53,500
Please join and be really very much happy

583
00:36:53,650 --> 00:36:57,004
and appreciate the time you have spent. Take care.

584
00:36:57,122 --> 00:36:57,400
Bye.

