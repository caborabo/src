{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/6e7e3df8-aa99-403c-a3c6-ce27fd8369b3", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["attendees", "build", "by", "cloudnative", "conf fourty two", "gopowered", "itll", "kotal", "kubernetes", "minds", "mohamed abdelrhman", "objects", "senior software engineer", "steps", "tools", "understanding"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_audio_quality": null, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "speech_model": null, "id": "867fe7a8-25bd-4ce9-8370-a8d5c4f10599", "status": "completed", "error": null, "text": "Hello everyone and thank you for joining my session. Here we'll dive into the dynamic world of Kubernetes and explore how to create different Kubernetes objects using the Go programming language of course. Before we dive into the code, let's take a quick look at our agenda. Here we have the client to go Kubernetes Ebi and Ebi machinery libraries, how to connect to our cluster from our go application of course managing resources controllers and operators operator hub and then wrapping our session up. I'll do my best to cover each of these topics, providing as much information as possible within our limited time token. So to the next slide, what are client to go Kubernetes API and DBI machinery? So Kubectl is the official client to the official Kubernetes client to interact with Kubernetes API. But we can use client to go Kubernetes by and by machinery to interact with Kubernetes by server as well. But what are, what are they? So the client goal library is like the primary part or the primary library to interact with Kubernetes. It provides various tools to create, modify and delete Kubernetes objects kubernetes. When we use client to go library to interact with these resources, we actually modifying the Kubernetes objects defined in Kubernetes API. So basically Kubernetes API is where we define our Kubernetes objects. Lastly we have the ABi machinery. Ebay machinery is like a collection of utilities used to help us interact with Kubernetes Ebi better stuff like selectors, emitter scheme and so on. So now let's dive into our code and check how it's done. Now that we have established what are these packages and how they interact with each other, let's see how it works. Here I've created an empty directory and the first thing we need to do is to initialize our go module. So go initiatives with Go. Then we want to get our core libraries which are the client to go ebim machinery and Ebi library Kubernetes IO client go renew Imma sure. Then we want to create our main go file and here we're gonna create our package main then funk main within our funky main we won't get our so a cube config equals a file of join dire from line to goutils. Then the file name. So I'm assuming my, I'm assuming your cube config lies under the cube folder so you can change the balls if you need to. By the way, if you don't have a cluster running you can always use kind which is an amazing tool to create your cluster in your machine using docker. So it will create a cluster for you. Then what we need to do is to create a client set. First we gonna create rest config to bust those client a client comment. So list config an error equals client command build config from a flag. Then we want to empty string. Then the kube config file. If error was nil we're gonna ban it here. Then we want to create our client set using a Kubernetes interface. So we want to import this interface like go and we can use this interface kubernetes new for conflict. Then we're gonna buzz the rest. Of course here we hannah we gonna have the client set and error, error doesn't does equal nil. Doesn't equal nil. We're gonna panic. Then voila we have our client sit here. Of course there is a million way to get the client sit or to communicate with Kubernetes. But this is the way I'm most comfortable with. Now we want to check if this client set is working as expected. So we will get the number of nodes or the nodes we have in our cluster. For example we have a cube Ctl get here. I have a single node with this name. We want to do the same thing here. So as listaner equal client for v one nodes, list context, background list options, list options from ebay machinery. So we're gonna rename this v one because there is multiple interfaces with the name v one. So we're gonna name this one meta v one and use it here. Then we want to iterate over this list range list items. Then we want to print the name of our nodes. So record name. Let's check it out. Go around main go. Okay. Go. Mod go. Run go. And here we are. We have our node with the same name. So that's it. That's how we connect to Kubernetes using client set. Of course there is. You can take this further and create a singleton for your clients so you don't need to initialize it every time. But I'm sure you, you can handle this. For the sake of this example we're gonna make it simple and easy. Now we want to create a boot using the core v one interface from ebay library. We can, we can create our board. So basically what we need to do is to create the BoD struct. It takes pointer to core v one. We need to create the core v one. So core v one from Kubernetes ev one. We're gonna specify the board detail going to define the object meter. It's from meta v one object meter. Here we're creating a board named let's say demo board demo. Then we want to define our containers in this body. So specific v one bot spec will define the container contain gonna be called v one containers. We're gonna have we will define a single container or define a single container named nginx. Now we using the client set, we gonna create bot client. So what client gonna be clients core v one bots within the default name is this. Using this bot client we can create, update or delete our boards. So bot client create we're gonna bust the context background gonna bust the bottom. Then we gonna pass the list options. The create options. Sorry. This will return a bot and an error so result. Will it check if we got any errors on the equal nil we're gonna panic. Then we want to print out the the the board name. So. And here we go. Let's run this go. Run main go. As you can see here we have the node name and the board. If we checked using Kubectl get bots. We'll find here we have an open and it's one running. That's it for the boards. So next thing we want to do is to create a deployment similar to creating boot. Let's start and define our deployment create deployment. But first let's import the apps. V one package apps v one Kubernetes evil apps v one and here we can create our deployment structure apps and we name our deployment meta v one object meta with the name deployment. Then we want to define our as big Fcv one deployment is big. We'll define the replicas gonna have two replicas it needs and pointer two integers. So here we're gonna say for example and int 32 with the number of deployments. And here we're gonna bust pointer to the number of replicas. Then we want to boss our selector from pointer to meta v one label selector. And here we gonna match labels. We'll have app and demo for example. Then what we want to do is to define our template. So after the spec we want to have the template similar to the yaml file. If you used kubectl with yaml files to deploy a deployment, it's similarly, it's the same thing here. So suspicious. Gonna be the template, gonna be here template core v one template. The tricky here is to know which interface to use with which. So with this big we're using apps v one. With the object emitter, we using meta v one. Here was the template, we use core v one. This is just a trick in this part, but it's very straightforward, nice and easy as you can see. So object meter as you guessed it, gonna be meta, object meta with the name. No we don't need name, we need labels here, me string. Then within our template we want to add our aspect like containers similar to our bot above. Here we'll define a container as well. So let's see, core v one, we're going to have a single container with the name web for example and the image gonna be Nginx, what else? I think that's it. This is, this is our deployment struct. Now similar to what we want to create our deployment client, a deployment client from the client set of course. So deployment from our client v one deployment within, within the default namespace. Then we want to create our deployment from the deployment client. So we're going to see deploy and an error equals deployment client create context, background and our deployment and meta v one create options as well. We'll check if we got any error, we'll panic with the error. Then we want to print out our deployment print line deploy result. Let's check this together. But first we need to delete this bot or just comment as this part for the deployment, for the boots. I'm sorry because we already have the board here, so if we run this again it's gonna give us an error as saying we. You already have a board named the demo. But no, we want to go wrong. So we have here demo, deployment, let's check get deployments we have here to get bots. As you can see here we have our deployment, our boards here as well. So you can as well delete your deployment using the deployment decline. For example we can to do to do using deployment, let's comment this later. Deployment decline. That's it. Now we have created deployments, we created our board, we have created our client set. We can create secrets with the same idea, listener watchers, all the Kubernetes objects you want to create, you can create from this client. You just need to know which interface to use, which interface to define the name, which interface to use when defining this vic and so on. If you want to create something like ingress routes, you can always use something like traffic. And that's it for our third part which is managing resources. In this session we have talked about Kubernetes resources and how to manage and interact with these Kubernetes resources from our go applications. However, sometimes you might have a great idea or a need in your app and these resources aren't enough for you. Fortunately covering it support crds or custom resources definition which way we can develop our own resource. Let's say we have a resource called the burger stand and we want to develop our, this resource and use it in our cluster or any cluster really. So I've created these files here. The first one is a burger stand CRD. The second one is the big ban burger stand which is a resource I want to create at the end. So I want to let's, let's try it out and create the resource without, without defining our CRD. So Cube CTL, it will give us an error saying that Kubernetes service doesn't recognize, doesn't look like this kind or this definition. So what we need to do is to create our CRD. Here we have the name of our CRD, we have the version here we have the scheme here, the types as, I'm sorry, the probabilities of our, the probabilities of our CRD like resource like location capacity. Is it open or not? Scope should be namespaced. The names like Burger stands, Burger stand and the kind of course unshorting him to, to get our, to get our resources similar to Kubectl, get NMSB or cubes, get NS for example. So what we want to do is to Cube CTL Burger stand. Now we have our CRD configured so let's try our resource again. And here we go, we have our resource created in our cluster. Let's check it out. Cube Ctl, get B's and here we go. We have our resource, we can cube CTL of course get, get B's, big ban o Yaml. And as you can see here we have all the part of our resource. What we want to do next is to create a custom controller because custom resource only won't give us the operator or the complete cycle of resource. So the custom controller give us or example which we use to interact with this resource or save the desired state of this, of this resource. I'll leave this part for you. You can look into it, a hint, you can use a cube builder. It's a great tool. You can use it to create your custom controller. After that you would have your operator which lead us to the final part of our session with which is operator hub. If we opened our browser. If I opened my browser, you will find into operator, operator hub IO. You will find many operators here, some of them like search manager, eager operator, which we use all the time with Google Golang application to trace our requests and so on. So that's it. With that being said, I hope you enjoyed this session and thank you for watching me to the end. And boy, boy.", "words": [], "utterances": null, "confidence": 0.861963878091874, "audio_duration": 1254.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- How to create different Kubernetes objects using the Go programming language. How to connect to our cluster from our go application. managing resources controllers and operators operator hub. I'll do my best to cover each of these topics within our limited time token.\n- What are client to go Kubernetes API and DBI machinery? Kubectl is the official client to the official Kubernets client. Ebay machinery is like a collection of utilities used to help us interact with Kubers Ebi. Let's see how it works.\n- So next thing we want to do is to create a deployment similar to creating boot. Gonna be the template, gonna be here template core v one template. Then within our template we wants to add our aspect like containers similar to our bot above. Finally, print out our deployment print line deploy result.\n-  Kubernetes supports crds or custom resources definition which way we can develop our own resource. What we want to do next is to create a custom controller. The custom controller give us or example which we use to interact with this resource.\n- After that you would have your operator which lead us to the final part of our session with which is operator hub. You will find many operators here, some of them like search manager. With that being said, I hope you enjoyed this session and thank you for watching me to the end.", "auto_highlights_result": {"status": "success", "results": [{"count": 4, "rank": 0.09, "text": "deployment client", "timestamps": [{"start": 821588, "end": 822984}, {"start": 823948, "end": 825980}, {"start": 841850, "end": 843618}, {"start": 848178, "end": 849894}]}, {"count": 1, "rank": 0.09, "text": "Kubernetes IO client", "timestamps": [{"start": 192814, "end": 196270}]}, {"count": 2, "rank": 0.09, "text": "Kubernetes resources", "timestamps": [{"start": 986622, "end": 987934}, {"start": 990542, "end": 991914}]}, {"count": 3, "rank": 0.08, "text": "bot client", "timestamps": [{"start": 539134, "end": 540634}, {"start": 553934, "end": 554550}, {"start": 558326, "end": 559502}]}, {"count": 8, "rank": 0.08, "text": "client set", "timestamps": [{"start": 264592, "end": 265724}, {"start": 299844, "end": 300830}, {"start": 317962, "end": 319174}, {"start": 351010, "end": 351658}, {"start": 433790, "end": 434622}, {"start": 536482, "end": 537106}, {"start": 826508, "end": 827020}, {"start": 947884, "end": 948864}]}, {"count": 1, "rank": 0.08, "text": "client command", "timestamps": [{"start": 280084, "end": 281652}]}, {"count": 2, "rank": 0.07, "text": "Kubernetes Ebi", "timestamps": [{"start": 43534, "end": 44878}, {"start": 146630, "end": 147478}]}, {"count": 1, "rank": 0.07, "text": "different Kubernetes objects", "timestamps": [{"start": 29862, "end": 32062}]}, {"count": 1, "rank": 0.07, "text": "listaner equal client", "timestamps": [{"start": 370458, "end": 373734}]}, {"count": 1, "rank": 0.07, "text": "Kubernetes service", "timestamps": [{"start": 1054196, "end": 1055252}]}, {"count": 4, "rank": 0.07, "text": "Kubernetes API", "timestamps": [{"start": 74212, "end": 75268}, {"start": 85572, "end": 86944}, {"start": 129360, "end": 130632}, {"start": 132160, "end": 133416}]}, {"count": 1, "rank": 0.06, "text": "custom resource", "timestamps": [{"start": 1165880, "end": 1166840}]}, {"count": 1, "rank": 0.06, "text": "resources controllers", "timestamps": [{"start": 53534, "end": 55694}]}, {"count": 2, "rank": 0.06, "text": "Deployment decline", "timestamps": [{"start": 921696, "end": 922880}, {"start": 934104, "end": 936524}]}, {"count": 1, "rank": 0.06, "text": "custom resources definition", "timestamps": [{"start": 1007890, "end": 1009442}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}