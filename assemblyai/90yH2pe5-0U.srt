1
00:00:25,090 --> 00:00:28,422
Hello everyone, happy to present this topic in Con

2
00:00:28,476 --> 00:00:32,040
42 and thanks for taking time to attend this.

3
00:00:32,570 --> 00:00:36,466
Today's topic is cloud agnostic multitenant

4
00:00:36,498 --> 00:00:39,430
SaaS application challenges and solution.

5
00:00:40,090 --> 00:00:43,346
My name is Abaidat Baroha. I have around 16

6
00:00:43,378 --> 00:00:47,430
years of experience in building software and since last

7
00:00:47,580 --> 00:00:50,974
three years I'm managing engineering team s where we

8
00:00:51,012 --> 00:00:54,254
work on real time upstream operational data,

9
00:00:54,292 --> 00:00:57,242
ingestion and delivery. I work with ishrambajay,

10
00:00:57,306 --> 00:01:01,102
which is the world's number one company in upstream oil services.

11
00:01:01,236 --> 00:01:05,102
I have around 14 years of experience in various

12
00:01:05,166 --> 00:01:09,070
aspects of the oil field where we deal with the operational

13
00:01:09,150 --> 00:01:12,866
and technical okay, so jumping on to

14
00:01:12,888 --> 00:01:16,022
the today's topic, first I would like to start

15
00:01:16,076 --> 00:01:19,590
with the cloudagnostic part. So what is cloud

16
00:01:19,660 --> 00:01:23,666
agnostic? Building a cloud strategy that meets

17
00:01:23,698 --> 00:01:27,846
a unique needs of your company isn't as simple as spinning

18
00:01:27,878 --> 00:01:29,980
up a few workloads in the cloud.

19
00:01:30,510 --> 00:01:34,010
Today's sophisticated cloud deployments follow unique design

20
00:01:34,080 --> 00:01:37,194
patterns such as cloudagnostic strategy to meet

21
00:01:37,232 --> 00:01:41,230
a variety of unique businesses and technical requirements.

22
00:01:41,970 --> 00:01:45,674
So what is cloud agnostic? Cloud agnostic

23
00:01:45,722 --> 00:01:49,386
refers to a cloud design strategy in which applications,

24
00:01:49,498 --> 00:01:53,886
tools and services are designed to migrate seamlessly

25
00:01:53,998 --> 00:01:57,742
between multiple cloud platforms or between on premises

26
00:01:57,806 --> 00:02:02,002
and cloud in a hybrid model without disruption of

27
00:02:02,136 --> 00:02:06,334
services. Some of the advantages of a cloud diagnostic

28
00:02:06,382 --> 00:02:10,178
approach are it support seamless portability

29
00:02:10,354 --> 00:02:14,098
independent of the underlying operating system, to ensure

30
00:02:14,274 --> 00:02:18,074
limited disruption of the workloads in migration and to

31
00:02:18,112 --> 00:02:22,486
limit the risk of application downtime while enhancing

32
00:02:22,598 --> 00:02:26,394
cost efficiency. Before even going deeper into

33
00:02:26,432 --> 00:02:30,394
the cloud agnostic part, let's start with why

34
00:02:30,432 --> 00:02:34,542
we even started with the cloud. I mean, why was so special

35
00:02:34,676 --> 00:02:37,680
about the cloud? I mean, cloud is not a new word. Now,

36
00:02:38,210 --> 00:02:42,454
cloud based technology is becoming an increasingly popular choice

37
00:02:42,522 --> 00:02:45,858
for businesses around the world because cloud

38
00:02:45,944 --> 00:02:49,918
can help businesses to streamline their processes and operations,

39
00:02:50,094 --> 00:02:53,246
allowing them to focus more on their core

40
00:02:53,278 --> 00:02:57,382
business. As per Gartner report, by 2028,

41
00:02:57,516 --> 00:03:01,138
cloud computing will shift from being a technology disruptor

42
00:03:01,234 --> 00:03:05,014
to becoming a necessary component for maintaining business

43
00:03:05,132 --> 00:03:08,570
competitiveness. And why

44
00:03:08,640 --> 00:03:11,818
businesses moved or still moving to the cloud?

45
00:03:11,904 --> 00:03:15,580
Because there are several benefits, let's quickly

46
00:03:16,430 --> 00:03:19,706
go and check what are the significant ones. So the

47
00:03:19,728 --> 00:03:23,662
first one is pay as you go model, where it

48
00:03:23,716 --> 00:03:27,370
offer a tailored and cost effective software

49
00:03:27,530 --> 00:03:30,814
solution. But how cloud services

50
00:03:31,012 --> 00:03:34,402
and resources offer cost effective solutions as

51
00:03:34,456 --> 00:03:38,542
businesses only pay for their services and can reduce costs

52
00:03:38,686 --> 00:03:42,014
when demand decreases without worrying about wasted

53
00:03:42,062 --> 00:03:46,114
hardware investment. Moving from the capital heavy expense

54
00:03:46,162 --> 00:03:49,330
of installing, maintaining and upgrading on premises

55
00:03:49,410 --> 00:03:53,282
it infrastructure to the operational cost of a SaaS

56
00:03:53,346 --> 00:03:57,174
subscription provides a greater clarity on the cost of

57
00:03:57,212 --> 00:04:00,842
using a software solution in terms of license or

58
00:04:00,896 --> 00:04:04,860
maintenance and infrastructure cost. Second obvious

59
00:04:05,230 --> 00:04:09,094
benefit is scalability. Cloud resources can provide businesses

60
00:04:09,142 --> 00:04:12,542
the flexibility to adjust to changing needs. With cloud

61
00:04:12,596 --> 00:04:16,302
resources, companies can quickly scale up or down

62
00:04:16,436 --> 00:04:20,430
depending on their current requirements. This is especially

63
00:04:20,580 --> 00:04:24,974
beneficial for businesses that have unpredictable peaks

64
00:04:25,102 --> 00:04:29,230
and thoughts in their demand as they don't have to invest heavily

65
00:04:29,310 --> 00:04:33,230
in infrastructure, part that becomes redundant

66
00:04:33,310 --> 00:04:37,154
during the quieter periods. Other benefit

67
00:04:37,202 --> 00:04:40,434
is like automated backups and disaster

68
00:04:40,482 --> 00:04:43,874
recovery. In general, cloud solutions include

69
00:04:43,922 --> 00:04:47,966
automated backups. Out of the box, cloud vendors

70
00:04:48,018 --> 00:04:51,814
can perform daily backups and weekly and monthly backups

71
00:04:51,862 --> 00:04:54,780
so that you are sure that your data is in safe hands.

72
00:04:55,470 --> 00:04:58,842
In addition to backups, cloud vendors can offer

73
00:04:58,976 --> 00:05:02,782
advanced disaster recovery programs to protect you from

74
00:05:02,836 --> 00:05:06,398
unexpected disruption. Production data

75
00:05:06,564 --> 00:05:09,886
synchronized regularly to a secure server in

76
00:05:09,908 --> 00:05:13,422
a remote location. In the event of a disaster,

77
00:05:13,486 --> 00:05:17,186
the production server is updated with the latest backup of the

78
00:05:17,208 --> 00:05:20,962
remote server. Other benefits include up to date

79
00:05:21,016 --> 00:05:24,802
software upgrades so cloud system provide

80
00:05:24,856 --> 00:05:28,278
a higher uptime compared to on premises cloud system,

81
00:05:28,364 --> 00:05:32,454
help reduce technology complexity and rely on an enhanced and

82
00:05:32,492 --> 00:05:35,686
secure cloud infrastructure. There's also no

83
00:05:35,708 --> 00:05:38,678
need to plan for costly it upgrades.

84
00:05:38,854 --> 00:05:42,554
It eliminates the hassle of managing upgrades or any

85
00:05:42,592 --> 00:05:46,746
other it expansion. As your business grows, it ensures that

86
00:05:46,848 --> 00:05:50,586
your software solution is always up to date by letting

87
00:05:50,618 --> 00:05:53,390
the software vendor manage upgrades.

88
00:05:53,970 --> 00:05:57,440
One last advantage is enhanced data sick security.

89
00:05:58,210 --> 00:06:02,294
Cloud solutions are even more secure than on premise solutions,

90
00:06:02,442 --> 00:06:06,478
enabling you to store your strategic data on a secure infrastructure.

91
00:06:06,654 --> 00:06:09,742
Cloud providers are large companies with high technical

92
00:06:09,806 --> 00:06:14,254
expertise and hire. They can hire the certified professional

93
00:06:14,302 --> 00:06:17,842
as well. They comply with many international regulations

94
00:06:17,986 --> 00:06:21,666
and use the most recent. Cloud providers

95
00:06:21,698 --> 00:06:25,682
also run powerful cybersecurity software to prevent attacks

96
00:06:25,746 --> 00:06:29,386
and protect. So as we can see,

97
00:06:29,408 --> 00:06:33,610
there are lots of benefits of moving. Now let's

98
00:06:34,190 --> 00:06:37,738
talk about what are the pros and cons

99
00:06:37,824 --> 00:06:40,878
for the cloud agnostic? We discuss

100
00:06:40,964 --> 00:06:44,942
about the benefits of cloud, but why cloud

101
00:06:44,996 --> 00:06:48,622
agnostic now? So ever since

102
00:06:48,676 --> 00:06:53,006
public clouds were introduced, organizations have increasingly adopted

103
00:06:53,038 --> 00:06:56,820
the greater feature that cloud solution provide.

104
00:06:57,510 --> 00:07:00,766
Almost infinite scalability, cost efficiency,

105
00:07:00,878 --> 00:07:04,386
reduced management overhead and high flexibility are just

106
00:07:04,488 --> 00:07:07,826
some of the features that public cloud provides.

107
00:07:07,938 --> 00:07:12,418
All these can be used to gain an advantage over competitors.

108
00:07:12,594 --> 00:07:16,918
But as the IT industry goes, there has always been

109
00:07:17,084 --> 00:07:20,330
one thing that seems never to have changed over the years.

110
00:07:20,400 --> 00:07:23,910
That is a vendor lock in. One of the advantage

111
00:07:23,990 --> 00:07:28,006
of cloudagnostic is avoid the risk

112
00:07:28,038 --> 00:07:31,930
of vendor lock in. But what is this vendor lock in?

113
00:07:32,080 --> 00:07:35,854
So vendor lock in has been present in many forms ever since the

114
00:07:35,892 --> 00:07:39,994
first commercial software was introduced. Cloud providers

115
00:07:40,042 --> 00:07:44,638
practice vendor lock in as s web. They implement their infrastructure

116
00:07:44,814 --> 00:07:48,386
in such a way as to make it more difficult to migrate to

117
00:07:48,408 --> 00:07:52,222
their competitors. Software companies deploying their software

118
00:07:52,286 --> 00:07:55,322
on public cloud infrastructure such as Microsoft Azure,

119
00:07:55,406 --> 00:07:59,400
Google Cloud and AWS must keep that in mind.

120
00:07:59,850 --> 00:08:03,314
After all, nothing's future proof and even the biggest

121
00:08:03,362 --> 00:08:07,262
companies can fail significantly, raise their prices,

122
00:08:07,426 --> 00:08:11,114
change license or do pretty much anything that can make

123
00:08:11,312 --> 00:08:14,666
life more difficult. To avoid this, the concept of the

124
00:08:14,688 --> 00:08:18,874
cloud agnostic application was introduced. What are other

125
00:08:18,992 --> 00:08:22,926
benefits so performance, wide range of

126
00:08:22,948 --> 00:08:26,590
features and options that customer can use to maximize the performance.

127
00:08:27,250 --> 00:08:31,242
It provides flexibility as well because now developers

128
00:08:31,306 --> 00:08:34,782
are not restricted to one cloud platform capabilities

129
00:08:34,846 --> 00:08:38,574
or tooling and they can incorporate the open source tools

130
00:08:38,622 --> 00:08:42,382
libraries. It also help to increase

131
00:08:42,446 --> 00:08:46,910
the resiliency application, provide redundancy

132
00:08:46,990 --> 00:08:50,578
and improve recovery speed in the event of a failure

133
00:08:50,754 --> 00:08:55,158
and services can be switched to another platform if the initial platform experience

134
00:08:55,324 --> 00:08:59,014
some kind of downtime, but there is no

135
00:08:59,052 --> 00:09:02,394
free lunch. There are some disadvantages as

136
00:09:02,432 --> 00:09:05,834
well. So implementing or designing your application

137
00:09:05,952 --> 00:09:10,102
or services with cloud agnostic approach it's not

138
00:09:10,256 --> 00:09:14,622
easy. It is challenging because cloud

139
00:09:14,676 --> 00:09:18,142
agnostic multi happen at the developer level.

140
00:09:18,276 --> 00:09:22,110
Making implementation challenges other

141
00:09:22,180 --> 00:09:26,414
challenges is the time to market. The complexity of developing cloud agnostic

142
00:09:26,462 --> 00:09:30,114
application and features means that it can take longer for projects to

143
00:09:30,152 --> 00:09:34,286
get off the ground. How to design a cloudagnostic

144
00:09:34,478 --> 00:09:38,578
architecture? Simple answer. Use Kubernetes

145
00:09:38,674 --> 00:09:42,486
and you are done. What we can do, we can build our

146
00:09:42,588 --> 00:09:46,326
services using containerized workload. Our friend Docker is

147
00:09:46,348 --> 00:09:50,490
available and we can deploy containers to the Kubernetes

148
00:09:51,150 --> 00:09:55,242
and these Kubernetes offered as

149
00:09:55,376 --> 00:09:59,814
a service by major cloud provider in terms of aks,

150
00:09:59,942 --> 00:10:05,142
eks or GKE from Azure and AWS

151
00:10:05,206 --> 00:10:09,070
and go Google Cloud. Whenever we want to add new capability,

152
00:10:09,490 --> 00:10:13,394
just add a new container and as long as we can

153
00:10:13,512 --> 00:10:16,690
switch from one public

154
00:10:16,760 --> 00:10:20,180
cloud to other cloud because kubernetes is available.

155
00:10:20,630 --> 00:10:24,778
So in this way we can easily design a cloud agnostic

156
00:10:24,974 --> 00:10:29,110
architecture. But is it really simple

157
00:10:29,180 --> 00:10:33,394
that way? So let's

158
00:10:33,442 --> 00:10:36,806
take one example. Okay? If I want

159
00:10:36,828 --> 00:10:40,150
to run some kind of messaging, let's say rapid MQ

160
00:10:40,230 --> 00:10:43,366
or Kafka, just eat new container.

161
00:10:43,558 --> 00:10:47,050
I want some cache, run another

162
00:10:47,200 --> 00:10:51,078
container if I want. Redis has high availability.

163
00:10:51,174 --> 00:10:54,618
We can run our redis cluster in container.

164
00:10:54,714 --> 00:10:58,110
We want some dbms. Okay fine.

165
00:10:58,180 --> 00:11:01,406
You can run PostgreSQL in containers. You need

166
00:11:01,428 --> 00:11:04,994
some object storage like AWS S three. We have

167
00:11:05,032 --> 00:11:09,118
a solution. Minio in containers unit monitoring.

168
00:11:09,214 --> 00:11:12,686
We can add more containers for elasticsearch,

169
00:11:12,798 --> 00:11:16,694
logistache and Kibana. So what we

170
00:11:16,732 --> 00:11:20,114
are doing exactly, we are adding more and more containers

171
00:11:20,162 --> 00:11:23,720
to our solutions let's take a step back.

172
00:11:24,410 --> 00:11:28,090
Why we move so one reason for companies

173
00:11:28,160 --> 00:11:31,414
to move to the cloud is to reduce the engineering

174
00:11:31,462 --> 00:11:35,130
effort when we are adding more

175
00:11:35,280 --> 00:11:39,260
and more containers. So we are basically

176
00:11:40,130 --> 00:11:43,754
increasing the engineering efforts in maintaining

177
00:11:43,802 --> 00:11:47,882
this container instead of focusing on providing a solution

178
00:11:47,946 --> 00:11:51,726
or feature to our customer. Using a

179
00:11:51,828 --> 00:11:55,090
SaaS database or a SaaS message broker or a SaaS

180
00:11:55,670 --> 00:11:59,198
Kubernetes is a great for various reasons

181
00:11:59,294 --> 00:12:03,490
because it can reduce our operational effort

182
00:12:04,230 --> 00:12:07,254
and vendor takes care of patching and

183
00:12:07,292 --> 00:12:11,062
updating. We can focus on our product instead of building

184
00:12:11,116 --> 00:12:14,626
an internal engineering effort. How to maintain

185
00:12:14,658 --> 00:12:17,400
a cloud balancer to help our business.

186
00:12:17,870 --> 00:12:21,402
We can move faster and more efficiently because

187
00:12:21,456 --> 00:12:23,900
the provider scales up and down.

188
00:12:24,430 --> 00:12:28,490
New products can be used by triggering the cloud vendor APIs,

189
00:12:29,070 --> 00:12:32,590
but if we examine this cloud agnostic approach,

190
00:12:33,170 --> 00:12:37,658
the implication shows that unintentionally

191
00:12:37,754 --> 00:12:41,054
building a custom data center instead of

192
00:12:41,092 --> 00:12:44,450
leveraging the cloud provider capabilities,

193
00:12:44,870 --> 00:12:47,954
instead of using the SaaS capabilities offered by the

194
00:12:47,992 --> 00:12:52,290
cloud, we are creating an often worse data

195
00:12:52,360 --> 00:12:55,846
center or infrastructure. So we

196
00:12:55,868 --> 00:12:59,334
are increasing the engineering effort. As you can

197
00:12:59,372 --> 00:13:02,454
see, once these components are

198
00:13:02,492 --> 00:13:06,390
deployed, then we need to patch and maintain and

199
00:13:06,460 --> 00:13:09,420
our engineering team is always busy in this stuff.

200
00:13:09,950 --> 00:13:13,526
Let's talk about some other challenges

201
00:13:13,718 --> 00:13:17,980
comes with running the stateful application

202
00:13:18,750 --> 00:13:21,998
on Kubernetes. So what is a stateful application?

203
00:13:22,164 --> 00:13:26,190
So whenever we are running any database

204
00:13:26,530 --> 00:13:30,394
cache or messaging on Kubernetes.

205
00:13:30,442 --> 00:13:34,178
So kubernetes provide a workload API that call

206
00:13:34,264 --> 00:13:37,710
stateful set API. So what is stateful

207
00:13:37,870 --> 00:13:41,518
set API? So stateful set is a workload API

208
00:13:41,694 --> 00:13:45,250
object used to manage the stateful applications.

209
00:13:45,690 --> 00:13:49,782
It manages the deployment scaling of a set of pods and

210
00:13:49,836 --> 00:13:53,634
provides guarantees about the ordering and uniqueness

211
00:13:53,682 --> 00:13:57,486
of these pods. A stateful maintains a sticky identity

212
00:13:57,538 --> 00:14:01,146
for each of its pod. These poses are created from the same

213
00:14:01,248 --> 00:14:04,710
spec, but are not interchangeable.

214
00:14:04,870 --> 00:14:08,634
Each has a persistent identifier that it maintains across any

215
00:14:08,672 --> 00:14:12,238
rescheduling. So if you want to use

216
00:14:12,404 --> 00:14:16,410
storage volumes from the cloud to provide the persistence

217
00:14:16,490 --> 00:14:19,920
for your workload, you can use a stateful set as part of your

218
00:14:20,290 --> 00:14:23,934
solution. Although individual ports in a stateful set are

219
00:14:24,052 --> 00:14:27,514
susceptible to failure, the persistent

220
00:14:27,562 --> 00:14:31,298
port identifier make it easier to match existing volumes to

221
00:14:31,304 --> 00:14:34,370
the new poses that replace any that have failed.

222
00:14:34,970 --> 00:14:38,418
But it's not easy to run your stateful

223
00:14:38,594 --> 00:14:42,678
application by stateful set

224
00:14:42,764 --> 00:14:45,442
because there are several challenges.

225
00:14:45,586 --> 00:14:48,874
One of the primary challenge of running a stateful application on

226
00:14:48,912 --> 00:14:52,330
Kubernetes is managing a persistent data storage.

227
00:14:52,670 --> 00:14:56,262
A traditional stateless application can simply be replicated

228
00:14:56,326 --> 00:14:59,862
across multiple poses, but a stateful application also

229
00:14:59,936 --> 00:15:03,630
require persistent data storage, which can be difficult to manage

230
00:15:03,700 --> 00:15:07,466
in a containerized environment. Kubernetes provides

231
00:15:07,498 --> 00:15:11,306
several options for data storage. It includes a local storage

232
00:15:11,338 --> 00:15:14,526
or network attached storage or cloud storage, but choosing

233
00:15:14,558 --> 00:15:18,526
the right storage solution can be challenging. Other challenges

234
00:15:18,558 --> 00:15:22,334
is about networking. Because stateful applications

235
00:15:22,382 --> 00:15:26,114
typically require communication between nodes, it's important to ensure

236
00:15:26,162 --> 00:15:29,846
that the networking infrastructure is designed to support this.

237
00:15:30,028 --> 00:15:33,218
Kubernetes provide several networking solutions include

238
00:15:33,314 --> 00:15:36,390
container networking or pod networking and service

239
00:15:36,460 --> 00:15:40,490
networking, but configuring these options correctly can be complex.

240
00:15:41,150 --> 00:15:44,358
Security is another key challenge for stateful apps.

241
00:15:44,454 --> 00:15:48,266
Because stateful apps often store sensitive data,

242
00:15:48,448 --> 00:15:51,886
it is important to ensure that the container environment is

243
00:15:51,908 --> 00:15:55,914
secure. And Kubernetes provides several security features like role

244
00:15:55,962 --> 00:15:59,870
based access control, port security policies, and network.

245
00:16:00,530 --> 00:16:04,706
But properly configuring these features can be finally,

246
00:16:04,808 --> 00:16:08,222
monitoring stateful application on Kubernetes can be a challenge.

247
00:16:08,286 --> 00:16:11,586
Because stateful applications require persistent data storage, it is

248
00:16:11,608 --> 00:16:15,670
important to monitor the health and performance of the data storage system.

249
00:16:15,820 --> 00:16:19,362
Kubernetes provides several monitoring tools like Prometheus

250
00:16:19,426 --> 00:16:23,446
and Grafana and Kubernetes dashboard, but configuring these

251
00:16:23,468 --> 00:16:27,014
tools to monitor stateful application there are other

252
00:16:27,052 --> 00:16:31,222
challenges as well. Different cloud providers

253
00:16:31,286 --> 00:16:35,142
provide different capability. Sometimes we can compare these capabilities

254
00:16:35,206 --> 00:16:37,740
but most of the time not. For example,

255
00:16:38,510 --> 00:16:41,440
looking at the distribution of data center,

256
00:16:41,970 --> 00:16:45,920
the global cloud does not seem so global after all.

257
00:16:46,290 --> 00:16:49,502
For example, if we are building a system for

258
00:16:49,556 --> 00:16:53,190
a bank, then we have to meet the GDPR regulator

259
00:16:53,210 --> 00:16:56,354
requirements. That means we are not free

260
00:16:56,392 --> 00:17:00,002
to use any capability worldwide. So building

261
00:17:00,056 --> 00:17:03,554
an architecture around the available data center is

262
00:17:03,592 --> 00:17:07,458
a leaky abstraction. Other challenges are related to

263
00:17:07,544 --> 00:17:10,370
failover or resilience and latency.

264
00:17:11,110 --> 00:17:15,154
It all depends on the location of the data center. If one provider

265
00:17:15,202 --> 00:17:19,270
offers fewer locations than another, then we are logged in.

266
00:17:19,340 --> 00:17:22,742
We need to be aware of this fact and consider the impact

267
00:17:22,886 --> 00:17:26,006
when moving from one cloud to another. If we require

268
00:17:26,038 --> 00:17:29,466
a special hardware or dedicated server, we will find

269
00:17:29,488 --> 00:17:33,920
out pretty quickly that limitless scale may be a problem too.

270
00:17:34,370 --> 00:17:37,790
Other problems are related to networking.

271
00:17:38,290 --> 00:17:42,550
Unlike AWS and Azure, Google Cloud provides virtual

272
00:17:42,650 --> 00:17:46,482
private cloud resources that are not tied to any specific

273
00:17:46,616 --> 00:17:50,820
reason. It is a global resource and

274
00:17:52,310 --> 00:17:55,970
also we need to think in terms of the data cost

275
00:17:56,040 --> 00:17:59,574
as well because ingress is free, but egress can be expensive and

276
00:17:59,612 --> 00:18:02,470
different cloud providers have their own policy of egress.

277
00:18:03,130 --> 00:18:06,678
Last but not the least, infrastructure as a code,

278
00:18:06,844 --> 00:18:10,422
it is considered a good practice to automate infrastructure

279
00:18:10,486 --> 00:18:14,326
environment using tools like terraform or AWS CDK.

280
00:18:14,518 --> 00:18:17,862
This helps reduce configuration drift and increases

281
00:18:17,926 --> 00:18:20,810
the overall quality of the infrastructure.

282
00:18:21,410 --> 00:18:24,890
However, the capabilities of the underlying cloud provider

283
00:18:24,970 --> 00:18:28,240
tend to get baked into the infrastructure code.

284
00:18:28,690 --> 00:18:32,634
Moving infrastructure code from GCP to Azure effectively

285
00:18:32,762 --> 00:18:37,214
means rewriting everything. Sure, the concepts of the high level architecture

286
00:18:37,262 --> 00:18:40,946
may be similar, but for the code, this is similar to moving an

287
00:18:40,968 --> 00:18:44,814
application from Java to Golang. In terraform, switching from

288
00:18:44,952 --> 00:18:48,694
GCP to an Azure means throwing everything

289
00:18:48,812 --> 00:18:52,662
away. Okay, so let's talk about

290
00:18:52,716 --> 00:18:56,454
some solution. What kind of approach, in my

291
00:18:56,492 --> 00:18:59,946
experience worked well for me. So it's a

292
00:18:59,968 --> 00:19:04,330
well known design prince principle, what we call

293
00:19:04,480 --> 00:19:08,090
facade. So a facade is basically a structural design

294
00:19:08,160 --> 00:19:11,674
pattern that provides a simplified interface to a library,

295
00:19:11,802 --> 00:19:14,942
a framework or any other

296
00:19:14,996 --> 00:19:18,494
complex set of classes. We can apply the

297
00:19:18,532 --> 00:19:22,758
same facade principle while designing a cloud agnostic

298
00:19:22,954 --> 00:19:26,642
application. As you can see, we have

299
00:19:26,696 --> 00:19:29,954
this blue box with cloud agnostic microservice which

300
00:19:29,992 --> 00:19:33,422
is talking to some messaging facade,

301
00:19:33,566 --> 00:19:37,286
and messaging facade is basically talking to

302
00:19:37,388 --> 00:19:41,330
a specific cloud provider adapter. In GCP,

303
00:19:41,490 --> 00:19:44,130
we want to connect to cloud pub sub in Azure,

304
00:19:44,210 --> 00:19:48,230
Azure service bus in AWS, we want to run SNS.

305
00:19:48,590 --> 00:19:51,900
So whenever we are

306
00:19:52,590 --> 00:19:56,486
changing any cloud provider, we just need to write another adapter

307
00:19:56,598 --> 00:20:00,746
and our service is intact. And this messaging

308
00:20:00,778 --> 00:20:03,262
facade, we need to change this until,

309
00:20:03,316 --> 00:20:07,310
unless we have this flexibility available

310
00:20:07,460 --> 00:20:11,386
where we are not touching the cloudagnostic

311
00:20:11,418 --> 00:20:15,394
microservice code, then we can always switch easily from

312
00:20:15,512 --> 00:20:19,620
one cloud provider to other other thing like

313
00:20:20,630 --> 00:20:24,670
what worked well. We need to identify the areas

314
00:20:24,750 --> 00:20:28,600
where lock in must be kept to a minimum and

315
00:20:29,130 --> 00:20:33,506
we should only focus on using product that have corresponding counterparts

316
00:20:33,538 --> 00:20:37,090
on other platform. If you are choosing some relational

317
00:20:37,170 --> 00:20:40,354
database, then GCP has a cloud SQL.

318
00:20:40,402 --> 00:20:43,442
Azure has Azure database for PostgresQ,

319
00:20:43,506 --> 00:20:47,754
SQL for runtime we have public offering for

320
00:20:47,792 --> 00:20:50,170
kubernetes like GKE or EKS.

321
00:20:50,670 --> 00:20:54,262
For serverless we can use knative, for time series database

322
00:20:54,326 --> 00:20:58,510
we can use GCP bigtable or AWS DynamoDB.

323
00:20:58,930 --> 00:21:02,994
So what I'm trying to say, let's focus on

324
00:21:03,112 --> 00:21:07,300
using the cloud provider capability. Whenever you are running any

325
00:21:08,230 --> 00:21:12,078
stateful workload for database or messaging

326
00:21:12,254 --> 00:21:15,714
and at application level, wherever you are writing some

327
00:21:15,752 --> 00:21:19,586
new service, use facade better. After following

328
00:21:19,698 --> 00:21:23,014
these two approaches, I was

329
00:21:23,052 --> 00:21:28,186
able to solve a lot of problem which was there

330
00:21:28,288 --> 00:21:31,770
when we are not using the cloudagnostic approach.

331
00:21:32,270 --> 00:21:35,658
Now I am coming to the second part of my talk,

332
00:21:35,744 --> 00:21:39,082
that is SaaS. SaaS means

333
00:21:39,136 --> 00:21:42,910
software as a service. But why SaaS?

334
00:21:43,410 --> 00:21:46,670
I mean why companies are moving or asking for a

335
00:21:46,740 --> 00:21:50,714
SaaS solution? Because it provides a greater emphasis

336
00:21:50,762 --> 00:21:54,366
on the customer experience, rapid response

337
00:21:54,398 --> 00:21:58,034
to customer feedback and it

338
00:21:58,072 --> 00:22:01,326
promotes active customer engagement,

339
00:22:01,518 --> 00:22:05,640
higher value on operational and

340
00:22:06,490 --> 00:22:10,726
there are some fundamentals of any SaaS application.

341
00:22:10,828 --> 00:22:15,270
As you can see on my screen I'm showing few gray boxes,

342
00:22:15,770 --> 00:22:19,580
so let me quickly go through it.

343
00:22:19,950 --> 00:22:23,114
So the first important part of any SaaS application is

344
00:22:23,152 --> 00:22:26,794
onboarding. How the tenant introduced in your

345
00:22:26,992 --> 00:22:30,734
environment and how the infrastructure is

346
00:22:30,772 --> 00:22:34,750
provisioned, how the tier selection is happening for billing.

347
00:22:35,090 --> 00:22:38,670
Other important thing is authentication and authorization

348
00:22:39,570 --> 00:22:43,970
to associate these onboarded tenants to some notion of

349
00:22:44,120 --> 00:22:47,490
identity. And other

350
00:22:47,560 --> 00:22:51,646
important part is how to easily flow the tenant context

351
00:22:51,758 --> 00:22:55,060
across moving part of our complex system.

352
00:22:55,690 --> 00:22:59,670
There are two important things. One is like tenant solutions.

353
00:23:01,450 --> 00:23:04,870
How does your architecture ensure that one tenant can't access the

354
00:23:04,940 --> 00:23:08,906
resources of another tenant? And how

355
00:23:08,928 --> 00:23:12,906
do you instrument your application to meter tenant activities so

356
00:23:12,928 --> 00:23:15,580
that we can charge the bill and money?

357
00:23:16,030 --> 00:23:19,930
And at last we need to aware about the tenant operation.

358
00:23:20,770 --> 00:23:24,782
So before going deeper into

359
00:23:24,836 --> 00:23:29,134
the SaaS part, let's first discuss about the

360
00:23:29,172 --> 00:23:32,240
multitenant impact in our microservice application.

361
00:23:33,330 --> 00:23:37,194
So we need to think about the SaaS

362
00:23:37,242 --> 00:23:40,242
or multitenant at every layla level.

363
00:23:40,376 --> 00:23:44,002
For example, on the front end we need to think about

364
00:23:44,136 --> 00:23:47,478
how are we authenticating our user that are coming to access

365
00:23:47,564 --> 00:23:51,878
our system. We need to gather information needed

366
00:23:51,964 --> 00:23:55,110
to route these requests to the proper backend resource.

367
00:23:55,450 --> 00:23:58,962
Because it's SaaS, we will be running a single version of software

368
00:23:59,026 --> 00:24:02,794
for all customer. But if some client needs some different experience

369
00:24:02,992 --> 00:24:06,794
then we need to support feature flag to turn some things on or

370
00:24:06,832 --> 00:24:10,438
off. When you are going to the API gateway here,

371
00:24:10,464 --> 00:24:14,842
you need to make the decision about authorization or throttling

372
00:24:14,906 --> 00:24:18,798
or caching. Now we are going to hit our business

373
00:24:18,884 --> 00:24:22,366
logic. We are hitting our microservice where we need

374
00:24:22,388 --> 00:24:25,826
to gather data based on some tenant context. We need to

375
00:24:25,848 --> 00:24:30,130
add some metrics and logging and metering based on that particular tenant.

376
00:24:30,470 --> 00:24:34,174
This microservice we talk to some data persistence

377
00:24:34,222 --> 00:24:37,606
or data access layer. Then we need

378
00:24:37,628 --> 00:24:41,830
to think about how we partitioned our data resources

379
00:24:42,410 --> 00:24:46,546
so that we know where is the data located for a specific tenant.

380
00:24:46,738 --> 00:24:50,742
Of course, all these things are running over some infrastructure,

381
00:24:50,806 --> 00:24:54,950
so we need to take care about the infrastructure provisioning or isolation

382
00:24:55,030 --> 00:24:58,662
or maintenance. Overall tenant lifecycle let's

383
00:24:58,726 --> 00:25:02,134
take an example of a normal microservice flow.

384
00:25:02,262 --> 00:25:05,594
So what happens in a normal microservice flow?

385
00:25:05,642 --> 00:25:08,990
Let's say there is some client using our app,

386
00:25:09,140 --> 00:25:12,674
is accessing our app using some mobile client or it could be

387
00:25:12,712 --> 00:25:17,506
a computer as well. That person basically do

388
00:25:17,608 --> 00:25:20,574
a login operation through the UI.

389
00:25:20,622 --> 00:25:24,110
Then UI is basically talking to some identity

390
00:25:24,270 --> 00:25:27,686
provider. It could be OIDC flow to

391
00:25:27,788 --> 00:25:32,102
get the beta token. Then the third part is

392
00:25:32,236 --> 00:25:35,750
we are transferring that beta token and later

393
00:25:35,820 --> 00:25:39,846
that UI application is going through some API gateway

394
00:25:40,038 --> 00:25:44,106
and optionally it is talking to identity provider again

395
00:25:44,208 --> 00:25:48,042
to validate the token and do the authorization part.

396
00:25:48,176 --> 00:25:52,026
And if everything works well then at the end is talking to microservice

397
00:25:52,058 --> 00:25:55,438
and microservice is making call to some database. So this is

398
00:25:55,444 --> 00:25:59,722
like a typical flow of any microservice

399
00:25:59,866 --> 00:26:03,650
app going deeper into how this SaaS thing

400
00:26:03,720 --> 00:26:07,298
impacting our microservice application. Let's quickly

401
00:26:07,384 --> 00:26:10,926
check what is a non microservice? How does a non

402
00:26:10,958 --> 00:26:14,594
microservice code looks like? Okay, on right

403
00:26:14,632 --> 00:26:17,890
hand side I am showing a simple API.

404
00:26:18,050 --> 00:26:21,638
I mean it's not a working code,

405
00:26:21,724 --> 00:26:25,126
it's for a demonstration purpose only. What we are doing, we are creating a

406
00:26:25,148 --> 00:26:28,786
dynamoDB instance, there is some table name and

407
00:26:28,828 --> 00:26:32,202
we have some get data API. What we are doing,

408
00:26:32,256 --> 00:26:36,294
we are just getting the key from the request,

409
00:26:36,422 --> 00:26:40,150
from the query parameters coming into the API. Then we are

410
00:26:40,240 --> 00:26:43,566
referencing a table in dynamodb and after that we

411
00:26:43,588 --> 00:26:47,486
are getting the response and at the end we

412
00:26:47,508 --> 00:26:50,110
are doing some exception handling.

413
00:26:50,450 --> 00:26:54,306
But one important thing is missing in this example.

414
00:26:54,488 --> 00:26:57,460
If we want to write this API in,

415
00:26:57,910 --> 00:27:01,410
here's the example for a SaaS code

416
00:27:01,480 --> 00:27:05,374
or if you are writing some microservice to support multi

417
00:27:05,422 --> 00:27:08,466
tenants SaaS workflow.

418
00:27:08,658 --> 00:27:11,974
So what is the difference in this code from the

419
00:27:12,012 --> 00:27:15,880
last code? What we are doing? We are getting

420
00:27:16,410 --> 00:27:20,198
some tenant id from the request header, the highlighted

421
00:27:20,294 --> 00:27:23,738
code in yellow and rest of this stuff

422
00:27:23,824 --> 00:27:27,850
looks but why this tenant id matters?

423
00:27:28,350 --> 00:27:31,614
Why this tenant id matters because as

424
00:27:31,652 --> 00:27:35,034
I talked earlier, we need to take care about the tenant

425
00:27:35,082 --> 00:27:39,098
isolation and data partition and metric and billing.

426
00:27:39,274 --> 00:27:42,638
So we need to know about the tenants id

427
00:27:42,724 --> 00:27:46,738
and we need to flow that tenant id in the tenants context across

428
00:27:46,824 --> 00:27:49,794
all services. Otherwise there is no way to know,

429
00:27:49,832 --> 00:27:53,566
okay, how to serve the request for a specific tenant

430
00:27:53,598 --> 00:27:57,030
or how to charge the bill to my tenant.

431
00:27:57,610 --> 00:28:01,240
But how to get this tenant id and

432
00:28:02,170 --> 00:28:06,086
how our typical microservice workflow change.

433
00:28:06,188 --> 00:28:10,774
If you are talking about multitenant or SaaS

434
00:28:10,902 --> 00:28:14,154
workflow, go to a

435
00:28:14,192 --> 00:28:17,994
workflow and talk about how we want to provision or

436
00:28:18,032 --> 00:28:21,534
onboard our tenant. So we will go

437
00:28:21,572 --> 00:28:26,080
to the same example. We have some mobile client then

438
00:28:26,450 --> 00:28:30,158
right now the important part is we need to provision our

439
00:28:30,244 --> 00:28:35,198
tenants first. Why? So that we can flow

440
00:28:35,294 --> 00:28:39,860
these tenant ids as a tenant context across our app.

441
00:28:40,630 --> 00:28:44,690
So there could be a tenant provisioning

442
00:28:45,050 --> 00:28:48,642
service which may call to some user management

443
00:28:48,786 --> 00:28:52,230
service to create users and claims

444
00:28:52,570 --> 00:28:56,834
by using some or talking to some identity provider or OIDC

445
00:28:56,882 --> 00:29:00,778
workflow and also we can apply some access policy

446
00:29:00,864 --> 00:29:04,298
as well, like if we want to provide

447
00:29:04,384 --> 00:29:08,570
some rights like someone is admin or some other kind of tenant policies.

448
00:29:09,470 --> 00:29:13,198
And once these things are done then

449
00:29:13,364 --> 00:29:17,390
we can optionally called a tenant management service where

450
00:29:17,460 --> 00:29:21,774
we can create a tenant id and with

451
00:29:21,812 --> 00:29:26,674
this tenant management service we can get

452
00:29:26,712 --> 00:29:30,558
the tenant id or tier plan or the status of tenant

453
00:29:30,654 --> 00:29:34,334
and we can use these things to flow

454
00:29:34,382 --> 00:29:38,322
further downstream to our other microservice

455
00:29:38,466 --> 00:29:42,406
service and we can use the same tenant context to

456
00:29:42,428 --> 00:29:45,560
the metering and building service as well.

457
00:29:45,930 --> 00:29:49,826
But the question is how to flow these

458
00:29:49,868 --> 00:29:53,622
tenant context. So there are several

459
00:29:53,686 --> 00:29:56,714
ways to do this. Most used

460
00:29:56,832 --> 00:30:00,070
option is using the JWT token,

461
00:30:00,150 --> 00:30:03,438
which is what we call JSON web token as well.

462
00:30:03,604 --> 00:30:07,486
So what is a JWT token? It is

463
00:30:07,508 --> 00:30:11,626
basically a base 64 encoded string. Spread it into three parts,

464
00:30:11,738 --> 00:30:15,314
header, payload and signature header gives

465
00:30:15,352 --> 00:30:19,538
us the type and hashing algorithm. Payload is a list of key value

466
00:30:19,624 --> 00:30:23,202
pairs or sometimes we call it that

467
00:30:23,256 --> 00:30:26,806
tell us about the token, who issued it, when is it going to

468
00:30:26,828 --> 00:30:30,870
expire for intended audience we can add our

469
00:30:30,940 --> 00:30:34,518
own key value pair to these tokens and

470
00:30:34,524 --> 00:30:37,480
we will use this poses along the tenant id.

471
00:30:37,950 --> 00:30:41,174
The last part is signature combination

472
00:30:41,222 --> 00:30:45,146
of encoded header payload and secret and we can use it to

473
00:30:45,168 --> 00:30:49,500
ask identity provider to confirm that no one has modified it.

474
00:30:49,890 --> 00:30:54,186
Other ways to pass token is in the URL

475
00:30:54,298 --> 00:30:57,786
query string parameter. We can use the query string

476
00:30:57,818 --> 00:31:01,630
parameter and we can pass that token tenant id

477
00:31:01,700 --> 00:31:05,186
information. Third option is we can pass in

478
00:31:05,208 --> 00:31:10,002
the request header as some

479
00:31:10,136 --> 00:31:13,540
custom header like x tenant id.

480
00:31:14,470 --> 00:31:18,290
Last option is we can also create a separate microservice.

481
00:31:18,370 --> 00:31:21,990
So whenever request is coming to our business

482
00:31:22,060 --> 00:31:25,762
logic we can always make a call to some other service to get the tenant

483
00:31:25,826 --> 00:31:30,118
id. But there is one downside of this approach

484
00:31:30,214 --> 00:31:33,674
here we are always creating a single point of failure by

485
00:31:33,712 --> 00:31:37,114
making call to one service. And the

486
00:31:37,152 --> 00:31:40,846
disadvantage is let's say that service is not available, then we

487
00:31:40,868 --> 00:31:44,254
don't have any tenant information available and our workflow will not

488
00:31:44,292 --> 00:31:47,534
work. Other important thing, what we need to keep in

489
00:31:47,572 --> 00:31:51,466
mind, whenever we are building a multi

490
00:31:51,498 --> 00:31:56,210
tenant SaaS application we can move

491
00:31:56,280 --> 00:31:59,886
our code to some common libraries.

492
00:31:59,998 --> 00:32:04,382
For example for this repeating

493
00:32:04,526 --> 00:32:08,022
task where we always need to get the tenant id from

494
00:32:08,076 --> 00:32:12,034
JWT token. So the steps involved

495
00:32:12,082 --> 00:32:16,050
we need to read the header authorization header from the request.

496
00:32:16,210 --> 00:32:20,154
Then we need to get the vera token and claims and

497
00:32:20,192 --> 00:32:23,722
after that we can get this tenants id. So this is like a

498
00:32:23,776 --> 00:32:28,074
common piece of code, what we need to

499
00:32:28,112 --> 00:32:32,350
execute with each API call. So it's good to have

500
00:32:32,500 --> 00:32:35,934
this code in some library and other services are using

501
00:32:36,132 --> 00:32:39,066
this code from that shared library.

502
00:32:39,258 --> 00:32:43,294
Other important thing is it's good to capture

503
00:32:43,342 --> 00:32:46,510
this tenant context in the logging.

504
00:32:46,670 --> 00:32:50,850
So we can always use some common libraries for structured logging

505
00:32:51,430 --> 00:32:55,640
and we can capture all these tenant context in log itself.

506
00:32:56,330 --> 00:32:59,974
Last but not the least, we need

507
00:33:00,012 --> 00:33:03,654
to flow these tenant contexts to the

508
00:33:03,692 --> 00:33:07,742
metric as well. So here I'm giving you example of open telemetry.

509
00:33:07,906 --> 00:33:12,390
So as you can see on left hand side there are microservices

510
00:33:12,470 --> 00:33:16,854
and shared infra and we are running some open telemetric

511
00:33:16,902 --> 00:33:20,494
collector for doing the instrumentation part and

512
00:33:20,532 --> 00:33:24,010
we can easily flow these metrics

513
00:33:24,090 --> 00:33:28,046
to some time series database or tracing or some column store.

514
00:33:28,228 --> 00:33:32,534
So in this way we can capture this metric with the provided

515
00:33:32,682 --> 00:33:35,938
tenant id and context. Also we need to

516
00:33:36,024 --> 00:33:39,666
talk about how are we going to partition our data.

517
00:33:39,768 --> 00:33:41,940
So there are different ways available.

518
00:33:42,870 --> 00:33:46,054
One option is to

519
00:33:46,172 --> 00:33:49,654
go with the silo approach where we are

520
00:33:49,692 --> 00:33:53,510
creating a separate database for each tenant.

521
00:33:53,930 --> 00:33:58,814
Second option is the pool based model where database

522
00:33:58,962 --> 00:34:02,330
is shared between all tenants and we have a single

523
00:34:02,400 --> 00:34:05,766
schema and we have one column with a tenant

524
00:34:05,798 --> 00:34:10,090
id that is indexed. And whenever we are making our queries,

525
00:34:10,530 --> 00:34:14,094
all queries are following that index and we are

526
00:34:14,132 --> 00:34:18,174
returning the response to our customer. The last option

527
00:34:18,212 --> 00:34:21,822
is the bridge approach where we have a single database but

528
00:34:21,876 --> 00:34:25,940
multiple schemas. So in my personal experience

529
00:34:26,310 --> 00:34:29,806
I use this approach because it helped

530
00:34:29,838 --> 00:34:33,934
me to get some kind of isolation

531
00:34:33,982 --> 00:34:37,138
in place and I'm not sharing

532
00:34:37,314 --> 00:34:41,094
the data from one tenant to other tenant. But at the end

533
00:34:41,132 --> 00:34:44,294
it's a microservice based decision. I mean,

534
00:34:44,332 --> 00:34:48,194
we need to think in terms of compliance and security, what your

535
00:34:48,332 --> 00:34:52,342
client wants, how it is going to impact your performance

536
00:34:52,406 --> 00:34:56,410
and data distribution, because there are always

537
00:34:56,480 --> 00:35:00,254
a problem. I mean, if we are going with the approach like a pool based

538
00:35:00,292 --> 00:35:04,510
approach or bridge based approach, then it may cause a noisy neighbor

539
00:35:05,650 --> 00:35:08,910
problem where one tenant is more active than other tenant and

540
00:35:08,980 --> 00:35:12,502
it is taking your all iops cycle

541
00:35:12,586 --> 00:35:16,706
or cpu. Let's quickly talk about the tenant solutions part.

542
00:35:16,808 --> 00:35:20,354
So what is tenant isolation? So one thing I would

543
00:35:20,392 --> 00:35:23,762
like to emphasize here,

544
00:35:23,816 --> 00:35:27,750
I mean, data partitioning is not related to tenant solutions.

545
00:35:28,490 --> 00:35:32,646
Tenant isolation is like here also we

546
00:35:32,668 --> 00:35:36,680
have two, two approaches. One is like silo model

547
00:35:37,130 --> 00:35:40,902
where every tenants gets their own environment.

548
00:35:40,966 --> 00:35:44,090
When I'm saying environment, for example,

549
00:35:44,160 --> 00:35:47,846
let's say whenever we are running some Kubernetes cluster

550
00:35:47,878 --> 00:35:51,166
and we are deploying our app. So tenant one will

551
00:35:51,188 --> 00:35:54,478
get its own environment and tenant two will get its own.

552
00:35:54,644 --> 00:35:58,398
The second possible approach is like we can also

553
00:35:58,484 --> 00:36:02,230
isolate in a single environment using runtime

554
00:36:02,410 --> 00:36:05,778
policies. How does it work? Let's take one example.

555
00:36:05,944 --> 00:36:09,234
Let's say we have some client logging to our

556
00:36:09,272 --> 00:36:12,820
application using some mobile device and

557
00:36:13,510 --> 00:36:16,886
after that it is going to some OidCu workflow to

558
00:36:16,908 --> 00:36:20,726
get the mirror token and after going to

559
00:36:20,748 --> 00:36:24,582
the API gateway it is hitting our microservice and

560
00:36:24,716 --> 00:36:28,810
now we reach to our data access layer where we are basically getting

561
00:36:28,880 --> 00:36:32,634
data. So before making this call to

562
00:36:32,672 --> 00:36:36,070
our database with the tenant

563
00:36:36,150 --> 00:36:40,086
scoped access, what will we do? We will just go

564
00:36:40,128 --> 00:36:43,738
and call the tenant scope credential

565
00:36:43,834 --> 00:36:47,790
from some tenant access manager service. It will

566
00:36:47,940 --> 00:36:52,110
return back us tenant policies and

567
00:36:52,180 --> 00:36:55,794
by using those policies now we can make

568
00:36:55,912 --> 00:36:59,346
the call to the database. So it will

569
00:36:59,448 --> 00:37:03,474
help us to achieve the tenant isolation using

570
00:37:03,672 --> 00:37:07,702
the runtime policy mechanism. Okay, so now

571
00:37:07,756 --> 00:37:11,622
here I am on the last part

572
00:37:11,676 --> 00:37:15,702
of my today's so takeaways is okay, I started

573
00:37:15,756 --> 00:37:19,802
my talk with the cloud agnostic, why is it important and how

574
00:37:19,856 --> 00:37:23,274
to solve the solution. What we

575
00:37:23,312 --> 00:37:27,014
face using kubernetes. So one approach

576
00:37:27,062 --> 00:37:30,846
is like using the facade pattern and whenever we

577
00:37:30,868 --> 00:37:34,986
are writing any microservice use that facade

578
00:37:35,018 --> 00:37:38,858
pattern and write our code in cloud agnostic manner.

579
00:37:39,034 --> 00:37:43,026
That is also called a loosely coupled architecture. The other thing is

580
00:37:43,048 --> 00:37:48,014
we can focus on strategic locking. We can still use offerings

581
00:37:48,062 --> 00:37:51,426
from public cloud wherever we can use and we

582
00:37:51,448 --> 00:37:55,558
can only use Kubernetes to run our services

583
00:37:55,644 --> 00:37:59,846
instead of running database or messaging. Then we

584
00:37:59,868 --> 00:38:03,800
moved into the multi tenant SaaS part. I mean how to

585
00:38:04,730 --> 00:38:08,326
why and how to create a

586
00:38:08,348 --> 00:38:11,826
multi tenant SaaS app. I mean we covered the tenant

587
00:38:12,018 --> 00:38:15,234
lifecycle part, how to flow the tenant

588
00:38:15,282 --> 00:38:18,514
context using the JWT

589
00:38:18,562 --> 00:38:22,606
token or request header are and at

590
00:38:22,628 --> 00:38:26,910
last we covered what are the different models of data partition and

591
00:38:26,980 --> 00:38:29,550
how to achieve the tenant solutions.

592
00:38:30,450 --> 00:38:34,730
That's all for today's talk, thanks for listening,

593
00:38:34,810 --> 00:38:35,420
have a good day.

