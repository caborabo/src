1
00:00:20,970 --> 00:00:24,142
Everyone. So first of all, thanks for joining me.

2
00:00:24,276 --> 00:00:27,474
Thanks for having me at this conference. I'm excited

3
00:00:27,522 --> 00:00:29,990
to talk to you all about Python code mods.

4
00:00:31,210 --> 00:00:34,886
Before we get into it, let me just introduce myself briefly. My name

5
00:00:34,908 --> 00:00:38,534
is Dan Davella and I work at an early stage

6
00:00:38,582 --> 00:00:42,550
startup called Pixee, where we are building an automated

7
00:00:42,630 --> 00:00:46,314
product security engineer. So the idea is that we want to help

8
00:00:46,352 --> 00:00:50,210
developers and security engineers to automate

9
00:00:50,310 --> 00:00:52,640
improvements and fixes to their code.

10
00:00:54,290 --> 00:00:58,378
I work on security tools. I have a history of working on security tools.

11
00:00:58,474 --> 00:01:02,206
I've previously worked on runtime application security

12
00:01:02,308 --> 00:01:06,014
instrumentation. I have a bit of experience working on static analysis

13
00:01:06,062 --> 00:01:09,342
tools. And so it was kind of a natural transition

14
00:01:09,406 --> 00:01:13,090
for me to come to pixie and to work on tools that actually fixes

15
00:01:13,160 --> 00:01:16,306
security problems. If you've

16
00:01:16,328 --> 00:01:20,118
ever worked at an early stage startup, you realize that you wear a

17
00:01:20,124 --> 00:01:23,686
lot of different hats. But I would say the biggest hat that I

18
00:01:23,708 --> 00:01:27,190
wear is actually as the lead maintainer of this

19
00:01:27,260 --> 00:01:31,260
Python code moderator framework, which I'm going to be talking

20
00:01:31,630 --> 00:01:35,046
about today. This is an open source framework.

21
00:01:35,158 --> 00:01:38,598
We're going to get a lot into the details

22
00:01:38,614 --> 00:01:42,554
of this framework, some of the design decisions we've made. We'll talk about the

23
00:01:42,592 --> 00:01:46,320
motivation for having a new code mod framework at all.

24
00:01:46,770 --> 00:01:50,094
And I'm really excited to talk to you about that. But before

25
00:01:50,132 --> 00:01:53,106
I get into that, I want to take a moment to sort of set up

26
00:01:53,128 --> 00:01:57,202
the problem here. And so the problem

27
00:01:57,336 --> 00:02:01,374
really boils down to the fact that there's a lot of insecure

28
00:02:01,422 --> 00:02:05,358
code out there. And the even bigger problem

29
00:02:05,544 --> 00:02:09,030
is that this insecure code is not actually getting

30
00:02:09,100 --> 00:02:12,360
fixed. We're not fixing these security problems.

31
00:02:12,890 --> 00:02:16,422
And while I was preparing this talk, I was

32
00:02:16,476 --> 00:02:20,246
reading this state of software security report that was put out by Veracode

33
00:02:20,358 --> 00:02:24,266
pretty recently, and there were a couple of statistics that really stood out

34
00:02:24,288 --> 00:02:28,618
at me. The first one was this

35
00:02:28,704 --> 00:02:32,654
first quote here that says that roughly 63%

36
00:02:32,692 --> 00:02:36,446
of applications have flaws in first party code. And the

37
00:02:36,468 --> 00:02:39,934
reason that this stood out to me is that over the past few

38
00:02:39,972 --> 00:02:45,994
years, there's been so much emphasis on vulnerabilities

39
00:02:46,042 --> 00:02:49,954
in third party packages, like in our open source software that we're using

40
00:02:50,072 --> 00:02:53,906
and in our dependencies. And there's a lot of tools that have been helping us

41
00:02:53,928 --> 00:02:57,266
fix these kinds of things. There's been log for J and

42
00:02:57,288 --> 00:03:00,360
log for Shell, and a lot of big problems in third party code.

43
00:03:01,530 --> 00:03:05,254
We've tended to forget that there's also a lot of problems in our own

44
00:03:05,292 --> 00:03:08,642
code, in our own application code, and the code that we write

45
00:03:08,716 --> 00:03:12,454
and this is really important. And then this other statistic

46
00:03:12,502 --> 00:03:16,186
that stood out at me was this idea that 42% of

47
00:03:16,208 --> 00:03:20,146
all applications have flaws that persist unremediated

48
00:03:20,198 --> 00:03:23,438
for longer than one year. And this is

49
00:03:23,444 --> 00:03:26,938
how veracode is defining this concept of security debt.

50
00:03:27,034 --> 00:03:30,846
It's problems that aren't being resolved and

51
00:03:30,948 --> 00:03:34,354
these security issues just continue to live in our code and

52
00:03:34,392 --> 00:03:37,890
continue to get shipped. So there's a really big problem

53
00:03:37,960 --> 00:03:41,394
here that we're not fixing the security problems in our

54
00:03:41,432 --> 00:03:44,930
own code. And when you look at the security

55
00:03:45,000 --> 00:03:48,898
tool environment, there's really no lack of tools that are capable

56
00:03:48,994 --> 00:03:52,246
of finding security problems. If you

57
00:03:52,268 --> 00:03:55,446
look at all these different products, some of them are open source, some of them

58
00:03:55,468 --> 00:03:59,686
are enterprise grade commercial products. But if

59
00:03:59,708 --> 00:04:02,986
I asked everybody in the room or in the virtual room to kind of

60
00:04:03,008 --> 00:04:06,234
raise their hand if they were using at least one of these products

61
00:04:06,352 --> 00:04:10,026
on at least one of these projects, most people

62
00:04:10,128 --> 00:04:13,886
would probably raise their hand. And so we're all using security

63
00:04:13,988 --> 00:04:17,374
tools, but that doesn't seem to change the fact that these

64
00:04:17,412 --> 00:04:21,054
problems aren't actually getting fixes. And that's pretty

65
00:04:21,092 --> 00:04:23,978
concerning. Now,

66
00:04:24,004 --> 00:04:28,174
I will say that sometimes when I talk to developers and development teams

67
00:04:28,302 --> 00:04:31,634
and I ask them, what security tools are

68
00:04:31,672 --> 00:04:35,086
you using today, I actually do get a response

69
00:04:35,118 --> 00:04:39,346
that looks a little bit like this. I think that there's some smaller teams

70
00:04:39,378 --> 00:04:43,106
out there that have not really coalesced

71
00:04:43,298 --> 00:04:47,000
on some formalized security practices yet.

72
00:04:48,170 --> 00:04:51,834
So there are some teams out there that have not really adopted some of these

73
00:04:51,872 --> 00:04:55,158
security tools. And so obviously this means that they're

74
00:04:55,174 --> 00:04:59,020
not fixing some security problems as well because

75
00:05:00,590 --> 00:05:03,630
they don't even know that they're there in some cases.

76
00:05:04,210 --> 00:05:07,390
I think there's a couple of different reasons for this.

77
00:05:07,540 --> 00:05:11,870
One of them is that some developers feel like they don't have the expertise

78
00:05:12,470 --> 00:05:16,670
to really dive into security. And so it really requires

79
00:05:16,750 --> 00:05:20,580
a team getting to the level where they have some formal security

80
00:05:20,950 --> 00:05:24,434
engineering to really put these practices into

81
00:05:24,472 --> 00:05:28,710
place. Sometimes when I talk to more senior developers,

82
00:05:29,050 --> 00:05:32,370
they tell me that they feel like they are mostly writing

83
00:05:32,450 --> 00:05:36,454
secure code. And I understand where that

84
00:05:36,572 --> 00:05:40,026
thought process comes from because it's more likely for a

85
00:05:40,048 --> 00:05:43,386
senior developer that they're going to correctly parameterize their

86
00:05:43,408 --> 00:05:47,094
SQL queries and they're going to validate

87
00:05:47,142 --> 00:05:50,006
user input before it gets rendered into HTML.

88
00:05:50,118 --> 00:05:54,014
They're not going to put hard coded credentials in their code. But the fact

89
00:05:54,052 --> 00:05:57,454
remains that there's still an awful lot of code out there that

90
00:05:57,492 --> 00:06:01,230
has security issues and these issues aren't getting fixed.

91
00:06:01,890 --> 00:06:05,982
So what are we going to do about it? The obvious solution

92
00:06:06,126 --> 00:06:10,020
is that we need to fix and harden our code,

93
00:06:10,550 --> 00:06:14,242
but I think the less obvious solution, but that the industry is starting

94
00:06:14,296 --> 00:06:18,070
to arrive at, is that we need to do this automatically.

95
00:06:18,410 --> 00:06:22,230
And this is going to do a couple of different things. First of all,

96
00:06:22,380 --> 00:06:25,958
we're going to enable developers to

97
00:06:26,044 --> 00:06:30,186
merge secure code. So they're going to be able to merge fixes to

98
00:06:30,208 --> 00:06:33,898
their outstanding security problems. And then we're going

99
00:06:33,904 --> 00:06:37,834
to be able to guarantee that any new code that gets added is

100
00:06:37,872 --> 00:06:41,606
also secure because it's being validated and it's being fixed

101
00:06:41,638 --> 00:06:45,680
if there's any problems before it gets merged and deployed in the first place.

102
00:06:46,130 --> 00:06:49,998
We're also going to enable teams to work down their security

103
00:06:50,084 --> 00:06:53,226
backlogs. So if you are using one of these tools

104
00:06:53,258 --> 00:06:57,358
already, then we're going to be able to take the results of those tools

105
00:06:57,454 --> 00:07:01,266
and automatically fix a large proportion of them. So that

106
00:07:01,288 --> 00:07:04,434
that takes away distractions from the developers and gives

107
00:07:04,472 --> 00:07:08,518
people more bandwidth. And the result of all of that is that

108
00:07:08,604 --> 00:07:12,386
developers get to spend more time actually writing features

109
00:07:12,418 --> 00:07:16,230
and focusing on the things that matter to them. They get to ship features without

110
00:07:16,300 --> 00:07:19,180
feeling distracted by security problems.

111
00:07:20,590 --> 00:07:24,266
That is the goal here. And that's what leads us

112
00:07:24,288 --> 00:07:27,820
to this code code framework that I'm going to be talking to you about today.

113
00:07:28,190 --> 00:07:32,154
So just in a one sentence summary of Codemodder,

114
00:07:32,282 --> 00:07:36,062
it is an opensource code mod framework that is

115
00:07:36,116 --> 00:07:38,974
designed for fixing security issues.

116
00:07:39,172 --> 00:07:42,878
So I've already covered the open source part of this. I mentioned this is

117
00:07:42,884 --> 00:07:46,454
an opensource project that's being maintained by Pixee.

118
00:07:46,602 --> 00:07:50,466
But the rest of my talk is going to focus on what it means to

119
00:07:50,488 --> 00:07:54,690
be a code mod framework, and then how we go about using that

120
00:07:54,760 --> 00:07:56,580
to fix security issues.

121
00:07:58,390 --> 00:08:01,734
So I've used this term code mod a couple of times now,

122
00:08:01,772 --> 00:08:05,106
and I just want to make sure we define this for everybody. In case you're

123
00:08:05,138 --> 00:08:08,842
not familiar with this concept. But the word code mod has a simple

124
00:08:08,896 --> 00:08:12,890
etymology. It's just from a shortened form of code plus

125
00:08:12,960 --> 00:08:17,034
modification. And what we really mean is that a code mod is

126
00:08:17,152 --> 00:08:21,162
code that is capable of changing or updating other

127
00:08:21,216 --> 00:08:24,766
code. So codemodder is not

128
00:08:24,788 --> 00:08:28,446
the first code mod framework out there. There's some other prior art that I

129
00:08:28,468 --> 00:08:32,174
just want to mention. So the first thing to mention is

130
00:08:32,212 --> 00:08:35,250
this framework from Facebook that's actually

131
00:08:35,320 --> 00:08:38,734
called code mod, and this was intended

132
00:08:38,782 --> 00:08:42,354
to enable large scale refactoring with some level

133
00:08:42,392 --> 00:08:46,538
of human intervention. So if you imagine that you're doing big structural

134
00:08:46,574 --> 00:08:50,066
changes to your code, this is a framework that's

135
00:08:50,098 --> 00:08:53,990
going to help you with this. It was implemented in Python, and I believe

136
00:08:54,060 --> 00:08:57,750
that it's not actually actively maintained anymore.

137
00:08:59,550 --> 00:09:03,414
If you're in the JavaScript or typescript ecosystem, you might already be familiar

138
00:09:03,462 --> 00:09:07,334
with this framework called JS code shift, which is designed

139
00:09:07,382 --> 00:09:11,194
to quickly apply updates and framework migrations

140
00:09:11,242 --> 00:09:14,894
and version updates and things like that to a large number

141
00:09:14,932 --> 00:09:18,298
of fixes automatically. So this is quite popular,

142
00:09:18,394 --> 00:09:22,614
quite actively used, but this only applies to JavaScript

143
00:09:22,682 --> 00:09:26,174
and typescript code. And also there's

144
00:09:26,222 --> 00:09:30,770
really not any emphasis on security in this particular framework.

145
00:09:31,990 --> 00:09:36,162
And then there's also this project, also from meta, from Instagram

146
00:09:36,226 --> 00:09:39,990
I believe, called Libcst, which is

147
00:09:40,060 --> 00:09:43,702
a framework for parsing and transforming Python code,

148
00:09:43,836 --> 00:09:48,082
but it also provides an API for developing code mods,

149
00:09:48,226 --> 00:09:51,942
and they also include some

150
00:09:52,076 --> 00:09:55,674
pre built code mods as part of this framework, which include things like

151
00:09:55,792 --> 00:09:59,386
removing unused imports or ordering your imports or

152
00:09:59,408 --> 00:10:03,070
things of that nature. So we're going to talk a lot more

153
00:10:03,140 --> 00:10:06,286
about Libcst going forward, just to place a

154
00:10:06,308 --> 00:10:09,790
bookmark on that one. But the question

155
00:10:09,860 --> 00:10:13,026
is, if there's already all of this prior art for

156
00:10:13,048 --> 00:10:16,642
code mods, why did we need to design and develop

157
00:10:16,776 --> 00:10:20,366
a new code mod framework? And so that leads

158
00:10:20,398 --> 00:10:24,114
us to the code moderate philosophy. So the

159
00:10:24,152 --> 00:10:27,654
fundamental idea of Codemodder is that we want to

160
00:10:27,692 --> 00:10:31,590
fix problems that are found by other tools and

161
00:10:31,660 --> 00:10:34,402
specifically by other security tools.

162
00:10:34,546 --> 00:10:37,814
So the whole idea of Codemodder is that we want to be able to

163
00:10:37,852 --> 00:10:41,494
take the results of those security tools that I showed you a few slides

164
00:10:41,542 --> 00:10:45,478
back, and use that to drive fixes

165
00:10:45,654 --> 00:10:49,466
for problems that are identified. So we

166
00:10:49,488 --> 00:10:53,262
want to use those tools to identify problems and

167
00:10:53,316 --> 00:10:55,120
then fix them.

168
00:10:56,370 --> 00:11:00,014
Another big part of the code moderate philosophy is that we want our code

169
00:11:00,052 --> 00:11:03,398
mods to tell a story and to educate users.

170
00:11:03,514 --> 00:11:07,170
So if we're fixing security problems, we want

171
00:11:07,320 --> 00:11:10,290
users and developers to understand, first of all,

172
00:11:10,360 --> 00:11:14,322
what is the problem that is being fixed, and why is the new

173
00:11:14,376 --> 00:11:18,706
code a safer solution? And this is going to enable developers

174
00:11:18,818 --> 00:11:22,230
to write better code. It's going to teach them about security,

175
00:11:22,380 --> 00:11:25,720
and it's going to help them write more secure code going forward.

176
00:11:27,050 --> 00:11:30,826
And it's also very important for Codemodder to make changes that

177
00:11:30,848 --> 00:11:34,646
are simple to understand and approve. So good storytelling

178
00:11:34,678 --> 00:11:38,234
is part of this, but we

179
00:11:38,272 --> 00:11:42,362
want to make changes that a developer can look at and understand that

180
00:11:42,416 --> 00:11:46,206
yes, this is a good change. I want to make this change to my

181
00:11:46,228 --> 00:11:49,822
code, and I'm going to go ahead and accept it and now have

182
00:11:49,876 --> 00:11:53,650
more secure code. So it doesn't really matter if we propose changes

183
00:11:53,720 --> 00:11:57,074
that nobody wants. We need to propose changes that are

184
00:11:57,112 --> 00:12:00,674
understandable and that developers are willing to

185
00:12:00,712 --> 00:12:04,226
accept. And so in

186
00:12:04,248 --> 00:12:08,514
order to do this, we've decided that we can leverage existing

187
00:12:08,642 --> 00:12:12,290
Opensource tools in order to build a solution

188
00:12:12,370 --> 00:12:16,006
here. So we've got tools out there like Opensource tools out there

189
00:12:16,028 --> 00:12:19,894
like Semgrep, which are very good at identifying

190
00:12:20,022 --> 00:12:23,754
security problems and other code quality issues.

191
00:12:23,952 --> 00:12:27,690
And then on the other hand, we have this framework I mentioned before,

192
00:12:27,760 --> 00:12:31,950
Libcst, which is very good at transforming code

193
00:12:32,020 --> 00:12:36,014
and making changes to code. And so we

194
00:12:36,052 --> 00:12:39,374
feel like these two things belong together. If we can

195
00:12:39,412 --> 00:12:43,038
put these open source technologies together and orchestrate

196
00:12:43,054 --> 00:12:46,670
them, then we can build a tool that's very useful for developers

197
00:12:46,750 --> 00:12:50,546
and that can help automating fix security

198
00:12:50,648 --> 00:12:54,302
problems in their code. So one aspect

199
00:12:54,366 --> 00:12:58,594
of this is we want to be able to process results

200
00:12:58,642 --> 00:13:02,006
that are identified by other tools. So what

201
00:13:02,028 --> 00:13:05,314
this means is if you're using tools like sonar or CodeqL

202
00:13:05,362 --> 00:13:09,354
or Semgrep, we want to be able to process the output of those

203
00:13:09,392 --> 00:13:12,726
tools, which is often in the standardized file format

204
00:13:12,758 --> 00:13:16,774
called Serif. But we want to process the results of those tools

205
00:13:16,902 --> 00:13:20,266
and then feed it to the code moderate in such

206
00:13:20,288 --> 00:13:24,830
a way that we can use LibcSt to make transformations.

207
00:13:25,330 --> 00:13:29,454
So these tools, we expect, are in some cases already being used by

208
00:13:29,492 --> 00:13:33,210
developers, and we're going to identify the locations

209
00:13:33,370 --> 00:13:36,446
that are insecure, that are pointed

210
00:13:36,478 --> 00:13:40,446
out by these security tools, and then take that and make fixes

211
00:13:40,478 --> 00:13:44,066
to those locations in the code. But the other thing that

212
00:13:44,088 --> 00:13:48,050
we want to do is sometimes we want to be able to invoke

213
00:13:48,130 --> 00:13:51,574
the opensource tools ourselves. Sometimes we

214
00:13:51,612 --> 00:13:55,702
want to be able to find problems ourselves and

215
00:13:55,836 --> 00:13:59,190
use that to fix

216
00:13:59,260 --> 00:14:02,822
code. So in this case, we've written code

217
00:14:02,876 --> 00:14:07,218
mods that leverage Semgrap using custom rules that we've written,

218
00:14:07,394 --> 00:14:10,890
and we feed those rules to CST

219
00:14:11,050 --> 00:14:15,150
and use the results that we've actually generated with Semgrap

220
00:14:17,330 --> 00:14:20,922
to fix problems in code. And now this is very useful

221
00:14:20,986 --> 00:14:24,878
for the development teams that haven't really adopted formalized security

222
00:14:24,964 --> 00:14:28,562
practices yet, is that code moderator can give

223
00:14:28,616 --> 00:14:32,642
these teams a tool that will both find and

224
00:14:32,696 --> 00:14:35,826
fix problems. So we call this kind

225
00:14:35,848 --> 00:14:39,654
of code mod, find and fix problem, find and fix code

226
00:14:39,692 --> 00:14:43,106
mods. Whereas the previous kind of code mod that I showed

227
00:14:43,138 --> 00:14:46,450
you where we're consuming the results of external tools,

228
00:14:46,610 --> 00:14:50,090
those code mods are going to be called fix only code mods because

229
00:14:50,160 --> 00:14:52,650
we're taking results that have already been generated.

230
00:14:55,710 --> 00:14:59,530
So I mentioned that it's very important for us to educate users.

231
00:15:00,110 --> 00:15:04,000
And what this means is that we want our code mods to tell a story.

232
00:15:04,530 --> 00:15:07,934
So we believe that every fix the code modder provides is

233
00:15:07,972 --> 00:15:11,934
an opportunity to educate developers, both about security

234
00:15:12,052 --> 00:15:15,780
problems, but also about writing more secure code.

235
00:15:16,470 --> 00:15:20,354
We also believe that the fixes we provide should be comprehensible to

236
00:15:20,392 --> 00:15:23,522
developers and compelling. So if we

237
00:15:23,576 --> 00:15:26,786
tell the story right, it should be very easy for a

238
00:15:26,808 --> 00:15:30,226
developer to understand why the change is being made, what the original

239
00:15:30,258 --> 00:15:33,798
problem was, and that should make it compelling in

240
00:15:33,804 --> 00:15:37,110
terms of a fix from the perspective of a developer.

241
00:15:38,010 --> 00:15:41,114
And the result of that is that it makes fixes easy to

242
00:15:41,152 --> 00:15:44,198
merge. So when a developer sees a fix from Codemodder,

243
00:15:44,294 --> 00:15:47,994
it should be very easy to accept that into their

244
00:15:48,032 --> 00:15:51,098
upstream code base and say, yes, that is a change that I want to

245
00:15:51,104 --> 00:15:54,110
make. We want these fixes to be easy to merge.

246
00:15:55,250 --> 00:15:58,446
So at this point in the talk, after we've learned a bit about

247
00:15:58,548 --> 00:16:02,398
the code code framework, you're probably asking, how can I use it?

248
00:16:02,564 --> 00:16:05,954
So Python Codemodder is available

249
00:16:06,072 --> 00:16:10,078
as a package on Pypy. It's listed under the name Codemodder.

250
00:16:10,254 --> 00:16:13,886
And so you can just run pip install codemodder.

251
00:16:14,078 --> 00:16:17,554
And when you do that by default, you get this

252
00:16:17,592 --> 00:16:21,046
new executable called Codemodder on your path. You can run

253
00:16:21,068 --> 00:16:23,800
it with the h option.

254
00:16:24,410 --> 00:16:27,606
And what I'm showing you here is the output of

255
00:16:27,628 --> 00:16:31,450
the help message to the terminal. We're not going to go through all these options

256
00:16:31,520 --> 00:16:34,998
today, but I just want to give you the sense that there's

257
00:16:35,014 --> 00:16:38,314
a lot of different knobs to turn here, and Codemodder is very

258
00:16:38,352 --> 00:16:41,402
configurable. So that's the first step

259
00:16:41,456 --> 00:16:44,640
to getting it installed and seeing what it can do.

260
00:16:45,250 --> 00:16:49,360
And so then the next question you're asking is what does it actually do?

261
00:16:49,730 --> 00:16:53,534
And so if we invoke this codemodder executable with

262
00:16:53,572 --> 00:16:57,114
a path to your project. So a project that contains Python

263
00:16:57,162 --> 00:17:00,946
codemods is going to do a couple of different things.

264
00:17:01,128 --> 00:17:04,818
The first thing it's going to do is it's going to use

265
00:17:04,904 --> 00:17:08,494
the find and fix code mods that I mentioned earlier

266
00:17:08,622 --> 00:17:12,086
that are using semgrap rules in many cases, and it's going

267
00:17:12,108 --> 00:17:16,134
to identify problems in your code, and then it's going to apply

268
00:17:16,252 --> 00:17:19,634
fixes for the problems that it identifies.

269
00:17:19,762 --> 00:17:23,274
And those fixes are going to be applied directly to your

270
00:17:23,312 --> 00:17:26,506
files on disk by default. So it's going to make changes to

271
00:17:26,528 --> 00:17:30,382
your code. The other thing that code monitor does is

272
00:17:30,436 --> 00:17:33,950
it generates output files in this

273
00:17:34,020 --> 00:17:37,678
format that we've called code TF, which is designed as

274
00:17:37,684 --> 00:17:40,926
an interchange format for representing the

275
00:17:40,948 --> 00:17:44,238
results of code monitor runs. So I'm not going to get into a lot

276
00:17:44,244 --> 00:17:47,906
of details about what code TF looks like today.

277
00:17:48,008 --> 00:17:51,298
It's not really important to this talk, but I will mention

278
00:17:51,384 --> 00:17:54,898
code TF at least one more time towards the end of this talk.

279
00:17:55,064 --> 00:17:58,514
The general idea is that code TF can be consumed by upstream

280
00:17:58,562 --> 00:18:01,878
tools and it can be used to do interesting

281
00:18:01,964 --> 00:18:02,600
things.

282
00:18:04,810 --> 00:18:08,098
Okay, so at this point I'd like to show you a couple of

283
00:18:08,124 --> 00:18:12,006
examples of the kinds of security problems that Codemodder

284
00:18:12,038 --> 00:18:15,882
is capable of fixing. We have a pretty large catalog of

285
00:18:15,936 --> 00:18:19,766
code mods that we currently support. I think it's

286
00:18:19,798 --> 00:18:23,034
on the order of 40, 45, maybe close

287
00:18:23,072 --> 00:18:27,086
to 50 code mods that are currently supported. We're always developing more,

288
00:18:27,188 --> 00:18:30,238
but I'm just going to show you a couple of examples so you get a

289
00:18:30,244 --> 00:18:32,640
sense of what this framework can do.

290
00:18:34,070 --> 00:18:37,278
All right, so this first example is to replace

291
00:18:37,374 --> 00:18:41,054
unsafe Pyaml loader. So if you're familiar

292
00:18:41,102 --> 00:18:45,634
at all with the Pyaml module

293
00:18:45,762 --> 00:18:48,390
Pyaml library in Python,

294
00:18:48,970 --> 00:18:52,962
you might be aware that the default loader in Pyaml

295
00:18:53,026 --> 00:18:56,354
is actually insecure. It potentially enables

296
00:18:56,402 --> 00:18:59,734
arbitrary code execution if you load a yaml

297
00:18:59,782 --> 00:19:03,866
file from a opensource that you don't trust. And so this change is

298
00:19:03,968 --> 00:19:07,558
relatively simple. What we do is identify locations

299
00:19:07,654 --> 00:19:11,386
where that unsafe loader is being used, and we replace it with

300
00:19:11,408 --> 00:19:15,354
a safe loader which is not susceptible to arbitrary

301
00:19:15,402 --> 00:19:18,446
code execution in the same way. So you can

302
00:19:18,468 --> 00:19:21,886
see this is a pretty simple change that's being made. Should be pretty simple for

303
00:19:21,908 --> 00:19:25,170
a developer to understand the reasons for this,

304
00:19:25,320 --> 00:19:28,770
and we think it's a good code. It makes your code more secure.

305
00:19:31,110 --> 00:19:35,050
The next one I'm going to show you is a personal favorite of mine.

306
00:19:35,230 --> 00:19:39,122
This is one that uses diffused XML for parsing

307
00:19:39,186 --> 00:19:43,350
XML. So if you're familiar at all with the standard

308
00:19:43,500 --> 00:19:47,062
library XML parsers in Python, so the ones that are

309
00:19:47,116 --> 00:19:49,930
provided out of the box with Python,

310
00:19:50,430 --> 00:19:54,410
these are actually insecure for

311
00:19:54,560 --> 00:19:58,538
different kinds of XML parsing vulnerabilities. And if you

312
00:19:58,544 --> 00:20:02,506
go to the documentation for these modules on the Python docs,

313
00:20:02,618 --> 00:20:06,458
you will see a big warning right at the top that says that these XML

314
00:20:06,554 --> 00:20:10,522
libraries should not be used for parsing

315
00:20:10,586 --> 00:20:14,430
untrusted XML data. And what the documentation

316
00:20:14,510 --> 00:20:18,222
actually does recommend is the use of this third party

317
00:20:18,366 --> 00:20:22,338
module called diffused XML. And because that has

318
00:20:22,424 --> 00:20:28,658
secured against many of these different types of XML attacks.

319
00:20:28,834 --> 00:20:32,454
And so what this code mod does is it identifies places in your

320
00:20:32,492 --> 00:20:36,322
code where you're using the standard library XML parsers

321
00:20:36,466 --> 00:20:40,002
and it replaces them with parsers from diffused XML.

322
00:20:40,146 --> 00:20:43,274
And so you can see in this diff here that we're adding some

323
00:20:43,312 --> 00:20:46,746
imports and we're changing the parsers so that

324
00:20:46,768 --> 00:20:50,486
they use diffused XML instead of the ones from the standard library.

325
00:20:50,678 --> 00:20:54,094
Now the interesting thing about this code mod which we'll come back

326
00:20:54,132 --> 00:20:57,242
to, is that in order for this to work properly,

327
00:20:57,306 --> 00:21:00,766
it actually needs to add the diffused XML dependency to your

328
00:21:00,788 --> 00:21:05,006
project if it's not already present. So again in a couple of slides we'll

329
00:21:05,038 --> 00:21:08,994
talk a little more about that. Here's another code mod

330
00:21:09,032 --> 00:21:12,514
that automating closes resources. If you open

331
00:21:12,552 --> 00:21:16,590
a file handle and you forget to close that in certain cases

332
00:21:16,750 --> 00:21:20,026
that can lead to resource overconsumption.

333
00:21:20,158 --> 00:21:23,926
It can make you susceptible to denial of service attacks and in

334
00:21:23,948 --> 00:21:27,480
certain cases can be quite catastrophic depending on the application.

335
00:21:28,010 --> 00:21:31,418
And so what this code mod does is it identifies any cases where the

336
00:21:31,424 --> 00:21:35,562
file handle wasn't closed and it rewrites those

337
00:21:35,616 --> 00:21:39,606
usages in terms of a context manager, which is the recommended

338
00:21:39,638 --> 00:21:42,510
way for handling these kinds of I O resources.

339
00:21:43,250 --> 00:21:46,206
The interesting thing to me about this code mod is that when you look at

340
00:21:46,228 --> 00:21:49,838
the change, it's actually a very simple diff

341
00:21:50,004 --> 00:21:53,834
here. But the code that

342
00:21:53,892 --> 00:21:58,020
implements this code mod is actually very sophisticated and

343
00:21:58,390 --> 00:22:01,954
it's really quite impressive. So I think that this is a cool

344
00:22:01,992 --> 00:22:04,980
code mod and a very useful one as well.

345
00:22:07,450 --> 00:22:10,870
In a similar vein, this is another code mod where the change

346
00:22:10,940 --> 00:22:14,662
looks pretty simple, but the logic behind it is very

347
00:22:14,716 --> 00:22:18,418
sophisticated. This is one that parameterizes

348
00:22:18,514 --> 00:22:22,506
SQL queries to make them safe against SQL injection. So if

349
00:22:22,528 --> 00:22:26,042
you look on line 147 here of the old code

350
00:22:26,096 --> 00:22:29,906
in the diff, you can see that string formatting

351
00:22:30,038 --> 00:22:33,502
using f string is being used to generate this

352
00:22:33,636 --> 00:22:37,630
SQL query which is then executed and that's potentially

353
00:22:38,130 --> 00:22:42,094
insecure against SQL injection depending on where that token string came

354
00:22:42,132 --> 00:22:46,258
from. So this code mod rewrites that query in terms of

355
00:22:46,344 --> 00:22:50,078
a parameterized query, which secures it against potential

356
00:22:50,174 --> 00:22:53,330
SQL injection. Again, I think this is a very cool,

357
00:22:53,400 --> 00:22:57,480
very valuable code mod and a very impressive one too.

358
00:22:58,890 --> 00:23:02,514
And this last one I'm going to show you is called use generator

359
00:23:02,562 --> 00:23:05,974
expressions. I like this one because it's not actually a

360
00:23:06,012 --> 00:23:09,642
security fix per se, and it also looks

361
00:23:09,696 --> 00:23:13,370
very simple just based on the diff. But it's a really interesting

362
00:23:13,440 --> 00:23:17,242
one because it identifies places where list

363
00:23:17,296 --> 00:23:20,538
comprehensions or other kinds of comprehensions have been used

364
00:23:20,704 --> 00:23:25,040
and rewrites them in terms of generator expressions where possible.

365
00:23:25,730 --> 00:23:29,226
And the reason for this is that you can have, in some cases,

366
00:23:29,258 --> 00:23:33,358
a very large performance benefit from doing this, especially if you're working with

367
00:23:33,444 --> 00:23:36,290
very large data sets and you need a lot of memory.

368
00:23:38,390 --> 00:23:42,110
This changes these data sets so that they're now lazily evaluated

369
00:23:42,190 --> 00:23:45,534
instead of having to load all of them in memory. I guess in some cases

370
00:23:45,582 --> 00:23:48,790
this could lead to denial of service. So there is a bit of a security

371
00:23:48,860 --> 00:23:52,662
impact here. But this is another case where it would be very

372
00:23:52,716 --> 00:23:55,926
hard to make this kind of change without the

373
00:23:55,948 --> 00:23:59,830
kind of syntactic and semantic analysis

374
00:23:59,990 --> 00:24:03,974
that we perform with these security tools and this transformation

375
00:24:04,022 --> 00:24:08,154
library. So I like this code mod because it's simple to understand, but still

376
00:24:08,192 --> 00:24:11,614
very interesting. So now that we've talked

377
00:24:11,652 --> 00:24:14,810
about some of the code mods, I want to dive a little bit deeper

378
00:24:14,890 --> 00:24:17,870
into the architecture of this framework.

379
00:24:19,170 --> 00:24:23,086
So when we designed this

380
00:24:23,108 --> 00:24:26,638
architecture, we realized that a code mod really consists

381
00:24:26,734 --> 00:24:29,906
of three different components. The first of these is called the

382
00:24:29,928 --> 00:24:34,370
detector. The second is called the transformer,

383
00:24:34,710 --> 00:24:38,486
and the third is called metadata. So the

384
00:24:38,508 --> 00:24:41,686
detector is responsible for finding problems.

385
00:24:41,788 --> 00:24:45,702
These are the security tools that go out and find problems with your

386
00:24:45,756 --> 00:24:49,618
code. In the case of Codemodder, this can be one

387
00:24:49,644 --> 00:24:53,190
of two different things. It can be problems that were identified

388
00:24:53,270 --> 00:24:56,742
by external tools, in which case the detector

389
00:24:56,886 --> 00:25:00,726
is really a parser for the results of those tools and transforms

390
00:25:00,758 --> 00:25:04,480
them into something that codemodder can use to fix.

391
00:25:04,930 --> 00:25:09,114
But in other cases, it's us running Semgrep directly. So codemodder

392
00:25:09,162 --> 00:25:12,430
is directly invoking Semgrep with custom

393
00:25:12,500 --> 00:25:16,550
rules and using that to drive the fixes. The transformer

394
00:25:16,570 --> 00:25:20,180
is what's actually responsible for changing the code and making the fix.

395
00:25:20,870 --> 00:25:24,226
And then the metadata is the part of the code mod that actually tells a

396
00:25:24,248 --> 00:25:28,454
story and helps the developer to understand the code mod and what

397
00:25:28,492 --> 00:25:31,686
kind of change is being made. So if I

398
00:25:31,708 --> 00:25:35,846
show you this diagram, this schematic of our base code mod class,

399
00:25:35,948 --> 00:25:39,878
you can see on the left hand side, we've got the detector,

400
00:25:40,054 --> 00:25:43,466
and that detector is feeding into what we've called a

401
00:25:43,488 --> 00:25:47,078
transformer pipeline, which can potentially be multiple

402
00:25:47,174 --> 00:25:50,746
transformers that are chained together. And then we

403
00:25:50,768 --> 00:25:53,786
also have this box up top, which is metadata,

404
00:25:53,978 --> 00:25:57,486
which includes some fields that I'll talk about on an

405
00:25:57,508 --> 00:26:00,858
upcoming slide. But in practice, what this ends

406
00:26:00,874 --> 00:26:04,526
up looking like is a little bit like this, where our detector

407
00:26:04,558 --> 00:26:07,806
is something like sonar or codeql or Semgrap.

408
00:26:07,918 --> 00:26:11,534
Again, sometimes the detector is parsing the results of these tools.

409
00:26:11,662 --> 00:26:15,106
Sometimes the detector is running Semgrap itself. In our find and

410
00:26:15,128 --> 00:26:18,886
fix code mods and then it's being fed into transformers that

411
00:26:18,908 --> 00:26:21,350
are implemented in terms of lib CST.

412
00:26:22,250 --> 00:26:25,954
And that transformer is what's responsible for actually changing

413
00:26:26,002 --> 00:26:30,062
the code. So I mentioned metadata on the last slide

414
00:26:30,226 --> 00:26:33,194
and I want to take a minute to talk about what that looks like.

415
00:26:33,392 --> 00:26:37,034
So metadata consists of a name which

416
00:26:37,072 --> 00:26:40,460
is really a unique identifier for a code mod.

417
00:26:40,910 --> 00:26:44,794
You can see here in this example that this name has three different parts.

418
00:26:44,922 --> 00:26:48,638
The first part is Pixie, which is telling you the origin of

419
00:26:48,644 --> 00:26:51,790
this code mod. It means that we wrote this at Pixie.

420
00:26:52,210 --> 00:26:55,834
The second component of this is the language that it applies

421
00:26:55,882 --> 00:26:59,554
to. So we're talking about Python codemods, but we

422
00:26:59,592 --> 00:27:02,898
do support another code mod framework for Java and

423
00:27:02,904 --> 00:27:05,380
we intend to build some others going forward.

424
00:27:05,750 --> 00:27:09,046
And then the third component after the slash is the actual name of

425
00:27:09,068 --> 00:27:12,630
the code mod itself, which is use diffused XML.

426
00:27:14,250 --> 00:27:17,542
The next part of code mod metadata that's interesting is

427
00:27:17,596 --> 00:27:21,526
a summary which is a short human readable description

428
00:27:21,558 --> 00:27:25,446
of the change being made. In this case, it's used diffused XML for parsing

429
00:27:25,478 --> 00:27:30,506
XML. This tools the developer what the code mod is doing and

430
00:27:30,528 --> 00:27:33,690
then we've got a description. And remember,

431
00:27:33,760 --> 00:27:36,206
we want to be able to tell a good story about a code mod.

432
00:27:36,308 --> 00:27:40,350
So we want to be able to support a reasonably large long form

433
00:27:40,420 --> 00:27:43,774
description. In this case, we've decided to

434
00:27:43,812 --> 00:27:47,554
represent this as a separate markdown file which

435
00:27:47,592 --> 00:27:51,506
is automatically associated with the code mod code. And that allows us

436
00:27:51,528 --> 00:27:55,186
to use markdown rendering and write a nice long form description about

437
00:27:55,208 --> 00:27:59,174
this code mod. And it also enables us

438
00:27:59,212 --> 00:28:02,742
to have this without cluttering up the code itself so that

439
00:28:02,796 --> 00:28:06,920
the description doesn't live right next to the code, it lives in a separate place.

440
00:28:07,450 --> 00:28:11,414
Okay, so I mentioned with the diffused XML code

441
00:28:11,452 --> 00:28:15,606
mod. Sometimes a code mod needs to add a dependency.

442
00:28:15,798 --> 00:28:19,434
Sometimes the right thing to do to fix a security problem is

443
00:28:19,472 --> 00:28:23,134
to use a different library that either has

444
00:28:23,172 --> 00:28:26,542
a more secure implementation or sometimes even to

445
00:28:26,596 --> 00:28:30,254
introduce a security package that is

446
00:28:30,292 --> 00:28:33,994
capable of hardening certain operations that tend to be insecure.

447
00:28:34,122 --> 00:28:37,474
So to do that we need to be able to add dependencies to our

448
00:28:37,512 --> 00:28:41,346
project, to the project being modified. And if

449
00:28:41,368 --> 00:28:45,266
you're familiar at all with the Python packaging ecosystem, you know that doing this

450
00:28:45,288 --> 00:28:48,570
in Python is not that easy of a problem to solve.

451
00:28:48,750 --> 00:28:52,258
In the simplest case, if you're using a requirements TxT file,

452
00:28:52,354 --> 00:28:56,338
we can generally just add that dependency to the requirements text file

453
00:28:56,434 --> 00:29:00,058
if it's not already present there. But in

454
00:29:00,064 --> 00:29:03,210
the Python packaging ecosystem there's a bunch of different places where

455
00:29:03,280 --> 00:29:06,810
packages can be, where dependencies can be expressed.

456
00:29:07,150 --> 00:29:11,594
This includes Pyproject tumult, which is currently recommended

457
00:29:11,722 --> 00:29:15,402
for setup tools. It's also used by poetry,

458
00:29:15,466 --> 00:29:18,240
which we don't currently support, but we may going forward.

459
00:29:18,930 --> 00:29:22,718
But some older projects might be using setup config if they're

460
00:29:22,734 --> 00:29:26,350
using setup tools. And then there's also setup

461
00:29:26,430 --> 00:29:30,430
pY, which can express dependencies,

462
00:29:30,590 --> 00:29:34,162
and that's sort of the older, less recommended way of doing things

463
00:29:34,216 --> 00:29:37,746
now. But we need to be able to figure out which of

464
00:29:37,768 --> 00:29:40,886
these is being used in a project and where the right place to add

465
00:29:40,908 --> 00:29:44,438
the dependency is. This is a pretty tricky problem.

466
00:29:44,604 --> 00:29:47,894
It's actually a bit harder to solve than the problem that

467
00:29:47,932 --> 00:29:51,158
dependabot has because they can just identify

468
00:29:51,254 --> 00:29:54,634
existing dependencies and update them. But we need to find the right

469
00:29:54,672 --> 00:29:58,234
place to add a new dependency. So I think that this is really

470
00:29:58,272 --> 00:30:01,422
useful and it's cool. And it's also

471
00:30:01,476 --> 00:30:04,942
something that definitely differentiates ourselves from other code mod

472
00:30:04,996 --> 00:30:08,874
frameworks. I don't think many other frameworks are necessarily

473
00:30:08,922 --> 00:30:10,560
thinking about this kind of thing.

474
00:30:12,290 --> 00:30:16,542
All right, so we've covered a lot of ground about the codemodder philosophy.

475
00:30:16,686 --> 00:30:20,242
We've talked about some examples and then

476
00:30:20,296 --> 00:30:23,586
the underlying codemodder architecture. So it's time for

477
00:30:23,608 --> 00:30:26,680
us to dive right in and write a code mod.

478
00:30:27,290 --> 00:30:31,218
So first of all, I want to mention that the code moderate

479
00:30:31,234 --> 00:30:34,422
framework supports a plugin infrastructure for

480
00:30:34,476 --> 00:30:38,034
loading custom code mods. So if you write a custom

481
00:30:38,092 --> 00:30:41,930
code mod, our framework is capable of automatically

482
00:30:42,990 --> 00:30:47,146
loading that custom code mod and making it available to

483
00:30:47,168 --> 00:30:50,886
the framework for use. I'm not going to get into a lot of detail about

484
00:30:50,928 --> 00:30:54,654
how that plugin infrastructure works. That's probably better

485
00:30:54,692 --> 00:30:58,590
covered in our documentation. But I will say that if you are interested

486
00:30:58,660 --> 00:31:02,746
in following along and writing your own custom plugin,

487
00:31:02,858 --> 00:31:06,290
your own custom code mod plugin, then you should start

488
00:31:06,360 --> 00:31:10,238
with this code mod plugin template, which is a cookie cutter template

489
00:31:10,334 --> 00:31:13,682
that you can use to generate your own custom

490
00:31:13,736 --> 00:31:17,218
code mod project. And what that's going to do is enable you to have a

491
00:31:17,224 --> 00:31:20,598
project that if you pip install it, it's automatically going to be

492
00:31:20,604 --> 00:31:24,280
picked up by Codemodder, and that custom code mod is going to be available.

493
00:31:24,650 --> 00:31:28,166
So if you're interested in doing this yourself, go ahead and get started with

494
00:31:28,188 --> 00:31:31,466
this cookie cutter template. And for the sake of

495
00:31:31,488 --> 00:31:34,186
the examples I'm going to show, we're going to assume that all of this is

496
00:31:34,208 --> 00:31:38,006
within the context of this particular cookie

497
00:31:38,038 --> 00:31:40,974
cutter template. Okay,

498
00:31:41,092 --> 00:31:44,366
so here's an example. Code mod that we're going to

499
00:31:44,388 --> 00:31:47,690
write, we're going to write a code mod called secure random,

500
00:31:47,850 --> 00:31:52,126
which is going to find places where the

501
00:31:52,228 --> 00:31:56,206
standard import random module is used in Python

502
00:31:56,318 --> 00:32:00,338
and we're going to replace it with a more secure and safer system,

503
00:32:00,424 --> 00:32:04,114
random module from secrets. And the reason for

504
00:32:04,152 --> 00:32:08,466
this is because if you're generating cryptographic primitives

505
00:32:08,498 --> 00:32:11,958
or using this to generate passwords or other kinds of

506
00:32:11,964 --> 00:32:15,686
keys, the standard random module is

507
00:32:15,708 --> 00:32:19,100
not secure enough for those purposes. So we think that this is

508
00:32:20,510 --> 00:32:23,946
a good hardening step to make really has no downsides and

509
00:32:23,968 --> 00:32:27,402
we recommend it. So for this code

510
00:32:27,456 --> 00:32:31,340
mod, first notice that we're importing this core code mod,

511
00:32:32,030 --> 00:32:35,866
this core code mod class which we're then using to define

512
00:32:35,978 --> 00:32:39,326
a secure random code mod. And remember when

513
00:32:39,348 --> 00:32:43,178
I talked about code mod architecture and it having three different components?

514
00:32:43,354 --> 00:32:46,786
We had metadata, we had a detector and

515
00:32:46,808 --> 00:32:50,642
we had a transformer. So you can see that the secure random code mod

516
00:32:50,696 --> 00:32:54,562
is defining each of those things. But the interesting thing

517
00:32:54,616 --> 00:32:58,294
that we're going to get into is what the definition of each of these different

518
00:32:58,332 --> 00:33:02,054
components looks like. So first of all, we're going to talk

519
00:33:02,092 --> 00:33:05,782
about metadata. You can see here

520
00:33:05,916 --> 00:33:09,078
we're defining this new object using the

521
00:33:09,084 --> 00:33:13,414
metadata class and it has a name which we're calling secure random.

522
00:33:13,542 --> 00:33:17,494
Now notice that this doesn't have the origin or the language component

523
00:33:17,542 --> 00:33:21,210
that I pointed out previously. That's because our framework

524
00:33:21,290 --> 00:33:24,830
is automatically going to add those based on the plugin.

525
00:33:25,410 --> 00:33:28,858
We know that this is a python plugin

526
00:33:28,954 --> 00:33:32,526
so it doesn't have to be provided here. Python code mod.

527
00:33:32,708 --> 00:33:36,900
And we also encode the actual origin name

528
00:33:37,590 --> 00:33:40,958
at the plugin itself. So ours would be pixie,

529
00:33:40,974 --> 00:33:44,494
but yours would have a different name for your project. So we're calling this secure

530
00:33:44,542 --> 00:33:47,954
random and the summary that we're providing

531
00:33:48,002 --> 00:33:51,334
is secure source of randomness. Now there's also

532
00:33:51,372 --> 00:33:55,442
this other field here called review guidance, which just sort of gives developers

533
00:33:55,506 --> 00:33:58,790
an idea of how much attention they need to pay to this

534
00:33:58,860 --> 00:34:02,266
particular change before they merge it. And then recall that

535
00:34:02,288 --> 00:34:05,594
I mentioned that the long form description is actually stored in a

536
00:34:05,632 --> 00:34:09,734
separate markdown file which I'm not showing here, but that's automatically

537
00:34:09,782 --> 00:34:13,550
going to get associated with the code mod that we're writing.

538
00:34:15,010 --> 00:34:19,614
All right, so the next part that we need to implement is the detector for

539
00:34:19,652 --> 00:34:23,294
this particular code mod. We're implementing it as a find and fix code

540
00:34:23,332 --> 00:34:26,706
mod, which means we're going to find the problem and we're going to

541
00:34:26,728 --> 00:34:29,918
do that by writing our own custom Semgrep rule.

542
00:34:30,094 --> 00:34:33,620
So we're using the Semgrep rule detector class here

543
00:34:34,150 --> 00:34:37,686
to define the detector, and what we provide to

544
00:34:37,708 --> 00:34:40,498
that is a Semgrep pattern.

545
00:34:40,674 --> 00:34:44,006
So I'm not giving a tutorial on Semgrep here. I'm not

546
00:34:44,028 --> 00:34:48,162
going to get too far into the weeds about what this pattern

547
00:34:48,226 --> 00:34:51,546
means. But suffice it to say that we're identifying all the

548
00:34:51,568 --> 00:34:54,300
cases where the random module is being used,

549
00:34:54,830 --> 00:34:58,650
but we're also making sure to exclude the system random, which is already

550
00:34:58,720 --> 00:35:02,718
secure. So this pattern is going to find all the locations in the code

551
00:35:02,804 --> 00:35:06,366
that look insecure and then the results of that are going

552
00:35:06,388 --> 00:35:10,400
to be fed to the transformer, which is what we show here.

553
00:35:11,010 --> 00:35:14,426
So first of all, note that we are creating a transformer

554
00:35:14,458 --> 00:35:18,942
class using the Libcst result transformer

555
00:35:19,086 --> 00:35:23,054
as the base class. So we're explicitly

556
00:35:23,102 --> 00:35:26,222
saying here that we're using lib CST for the transformation.

557
00:35:26,366 --> 00:35:29,878
We've added this layer of abstraction because we expect we might want to

558
00:35:29,884 --> 00:35:33,078
have other kinds of transformers in the future. So right now you

559
00:35:33,084 --> 00:35:37,270
have to define explicitly that you're using a webcst transformer.

560
00:35:37,610 --> 00:35:41,402
Okay, so I'm going to jump to this method called on

561
00:35:41,456 --> 00:35:45,100
results found. So this is where all the magic is happening.

562
00:35:45,470 --> 00:35:49,766
This is a callback that the transformer class defines that's

563
00:35:49,798 --> 00:35:52,938
going to get automatically called by the framework

564
00:35:53,114 --> 00:35:57,166
in response to any of the results, in response to any

565
00:35:57,188 --> 00:36:00,906
of the locations that are identified by the detector.

566
00:36:01,018 --> 00:36:05,022
So remember we're using a Semgrep detector and it's going to find locations

567
00:36:05,086 --> 00:36:09,102
in the code that look secure. And the framework is going to automatically

568
00:36:09,166 --> 00:36:12,866
call this method on the transformer anytime it sees one

569
00:36:12,888 --> 00:36:16,566
of those locations. So what

570
00:36:16,588 --> 00:36:20,054
we're really doing here is we're updating the call

571
00:36:20,092 --> 00:36:23,894
target of this operation. So originally the call

572
00:36:23,932 --> 00:36:28,194
target was random. Maybe we had a call to random Randint.

573
00:36:28,322 --> 00:36:32,102
So the call target there was the random module, but we want to replace

574
00:36:32,166 --> 00:36:35,562
that with this secrets system random. So the new

575
00:36:35,616 --> 00:36:39,462
call is going to look like secrets system random random.

576
00:36:39,526 --> 00:36:42,810
So that means that we're able to take advantage of this API

577
00:36:42,970 --> 00:36:46,974
call called update call target and use

578
00:36:47,012 --> 00:36:50,942
that to implement our transformation. Now this is a pretty common

579
00:36:50,996 --> 00:36:54,094
use case. If you recall back to our diffused XML code

580
00:36:54,132 --> 00:36:58,174
mod. This would actually be doing the same thing. It would be replacing

581
00:36:58,222 --> 00:37:01,566
the original call target, which is the standard library XML

582
00:37:01,598 --> 00:37:05,214
module, and it would be replacing it with diffused XML.

583
00:37:05,262 --> 00:37:08,050
So this method shows up in a bunch of different places.

584
00:37:08,810 --> 00:37:12,066
The other interesting thing to call out here is that if we're

585
00:37:12,098 --> 00:37:15,266
using the secrets module now, we need to make sure that it's

586
00:37:15,298 --> 00:37:19,222
imported. And so we call this method called add needed import

587
00:37:19,356 --> 00:37:23,082
which for each file is going to check is that secrets module already

588
00:37:23,136 --> 00:37:26,602
imported? And if it's not, go ahead and add it.

589
00:37:26,736 --> 00:37:30,118
And then on line ten above that you can see we're also calling remove

590
00:37:30,214 --> 00:37:33,854
unused import which just cleans up after ourselves and

591
00:37:33,892 --> 00:37:37,566
makes sure that if there's any unused imports after this they

592
00:37:37,588 --> 00:37:41,200
get cleaned up. So it makes the linters happy and keeps the code clean.

593
00:37:41,730 --> 00:37:45,394
Okay, so that defines the transformer class, but we also need to

594
00:37:45,432 --> 00:37:49,234
define the transformer pipeline, which for this

595
00:37:49,272 --> 00:37:52,850
particular case only consists of a single transformer.

596
00:37:54,310 --> 00:37:56,520
Okay? And if we go back to this example,

597
00:37:57,210 --> 00:38:00,070
we've defined the metadata class,

598
00:38:00,220 --> 00:38:04,354
we've defined the detector and we've defined the transformer.

599
00:38:04,482 --> 00:38:08,054
And so we've actually written a code mod that's capable of making a change

600
00:38:08,092 --> 00:38:11,514
and making your code more secure. And if we look at

601
00:38:11,552 --> 00:38:15,562
the diff that is generated by this code mod, if we apply this code mod

602
00:38:15,616 --> 00:38:19,590
to pygote, which is a deliberately vulnerable

603
00:38:19,670 --> 00:38:23,402
Python web application, you can see that the uses of

604
00:38:23,456 --> 00:38:26,862
random have been replaced with secret stat system

605
00:38:26,916 --> 00:38:30,366
random. And you can see on line nine up there that we've removed the

606
00:38:30,388 --> 00:38:34,046
random import which is no longer used. You can see on line 40 that

607
00:38:34,068 --> 00:38:37,666
we added the secrets import. And so this is

608
00:38:37,688 --> 00:38:40,690
a change that we hope a developer would be willing to accept.

609
00:38:41,510 --> 00:38:45,106
A big part of our philosophy with the code mod API is that

610
00:38:45,128 --> 00:38:48,486
we want to make the easy things as easy as possible. And I think that

611
00:38:48,508 --> 00:38:52,070
you saw some of that with the on result

612
00:38:52,140 --> 00:38:55,174
found method and the methods that are being called there that are

613
00:38:55,212 --> 00:38:58,454
intended to handle the most common use cases in a pretty

614
00:38:58,492 --> 00:39:02,090
straightforward way. But I also think in that example

615
00:39:02,160 --> 00:39:04,886
that I showed you that there was a lot of boilerplate, we had to define

616
00:39:04,918 --> 00:39:08,394
a couple of different classes and we had

617
00:39:08,432 --> 00:39:11,886
to put it all together. So to make the easy cases as

618
00:39:11,908 --> 00:39:15,230
easy as possible, we've defined the simple

619
00:39:15,300 --> 00:39:19,262
code mod API. And a simple code mod is one

620
00:39:19,316 --> 00:39:23,166
that has a single detector and it has a single

621
00:39:23,268 --> 00:39:26,938
transformer and specifically a single lib CST transformer.

622
00:39:27,034 --> 00:39:30,482
And if those two things are true, then we can use this simple code mod

623
00:39:30,536 --> 00:39:34,226
base class to implement our code mod. So this is the same code mod that

624
00:39:34,248 --> 00:39:38,034
I showed you before, except it's rewritten in terms of the simpler API.

625
00:39:38,162 --> 00:39:42,066
And you can see each of the components here. We define the metadata,

626
00:39:42,258 --> 00:39:45,320
we define our Semgrep detector pattern here.

627
00:39:45,690 --> 00:39:49,366
And then we define this on results found method. And so this

628
00:39:49,388 --> 00:39:53,066
is all in 20, maybe 25 lines of code. It's easy to

629
00:39:53,088 --> 00:39:56,794
read, and this, we believe makes for a very nice interface for

630
00:39:56,832 --> 00:39:58,970
defining some of the simpler code mods.

631
00:39:59,950 --> 00:40:03,214
However, we also want to make sure that the hard things are still possible.

632
00:40:03,332 --> 00:40:06,766
We don't want to lose any expressive power by having a

633
00:40:06,788 --> 00:40:10,654
simplified code mod API. And so I'm going to show you just a slightly more

634
00:40:10,692 --> 00:40:14,214
complicated example. This one is called subprocess shell

635
00:40:14,282 --> 00:40:17,634
false. It identifies any subprocess calls where

636
00:40:17,672 --> 00:40:21,026
shell is set to true, and it flips it to false, which is

637
00:40:21,048 --> 00:40:24,962
a safer default. And I'm not going to get too

638
00:40:25,016 --> 00:40:27,906
into the details of this code mod, you don't need to understand it all.

639
00:40:28,008 --> 00:40:31,382
But what I do want to point out is that instead of that on

640
00:40:31,436 --> 00:40:34,360
result found method that we saw in the previous example,

641
00:40:34,730 --> 00:40:38,262
we have this leave call method, and this actually

642
00:40:38,396 --> 00:40:42,246
directly exposes the underlying lib CST transformer

643
00:40:42,278 --> 00:40:45,626
interface. So we have the full expressive power of

644
00:40:45,648 --> 00:40:49,686
Libcst here and can leverage that to do some fairly

645
00:40:49,718 --> 00:40:53,430
sophisticated transformations for certain code mods.

646
00:40:53,590 --> 00:40:57,066
Now there's also come other things that we had to do here that we didn't

647
00:40:57,098 --> 00:41:00,702
have to do in the previous example because we're using a lower level

648
00:41:00,756 --> 00:41:04,226
API. One of these in the first box is we

649
00:41:04,248 --> 00:41:08,194
need to filter our file name by the path and

650
00:41:08,232 --> 00:41:12,034
the line number. So this is something that can be given

651
00:41:12,072 --> 00:41:15,540
on the command line to include or exclude certain

652
00:41:16,070 --> 00:41:19,426
files or lines from analysis. So we need to explicitly

653
00:41:19,458 --> 00:41:22,694
call that here, whereas an on results found that's already

654
00:41:22,732 --> 00:41:26,166
being handled by the callback. And then down at the bottom in this

655
00:41:26,188 --> 00:41:29,218
other box, we're calling this report change method,

656
00:41:29,394 --> 00:41:33,210
which is what's helping us generate that code tf file that I mentioned before.

657
00:41:33,360 --> 00:41:37,094
And again, that's already automating handled by the unresolved found method

658
00:41:37,142 --> 00:41:40,746
as well. So we didn't have to do that in that previous case, but we

659
00:41:40,768 --> 00:41:43,726
do have to do it here. So that's just giving you a sense of what

660
00:41:43,748 --> 00:41:47,200
a more complicated code mod might look like.

661
00:41:48,530 --> 00:41:51,822
All right, so here, getting to the end of my talk, I want to take

662
00:41:51,876 --> 00:41:55,362
just a minute to talk about some future directions and where we're looking

663
00:41:55,416 --> 00:41:59,026
ahead for this framework. So I showed you this

664
00:41:59,048 --> 00:42:02,466
diagram before where we have our detector can be a

665
00:42:02,488 --> 00:42:05,762
variety of different security tools as input, and then our

666
00:42:05,816 --> 00:42:09,606
transformers are implemented in terms of lib CST. Now,

667
00:42:09,628 --> 00:42:13,798
I think the elephant in the room in 2024 is

668
00:42:13,964 --> 00:42:17,426
where do large language models or llms fit into

669
00:42:17,468 --> 00:42:21,290
this? And should we be using those to implement some of our transformations.

670
00:42:21,790 --> 00:42:23,740
So looking forward,

671
00:42:25,790 --> 00:42:29,882
some of our transformations might look more like this, where we're using

672
00:42:30,016 --> 00:42:33,242
an LLM provider. I've used OpenAI here is

673
00:42:33,296 --> 00:42:36,746
probably the most well known, most popular one. But this could be a variety

674
00:42:36,778 --> 00:42:39,600
of different models. It could be llama, it could be something else.

675
00:42:40,290 --> 00:42:43,918
But should we be using llms to

676
00:42:44,004 --> 00:42:48,286
perform our transformations? There's a

677
00:42:48,308 --> 00:42:50,580
couple considerations here. First of all,

678
00:42:51,990 --> 00:42:55,426
do developers trust llms to make security changes to

679
00:42:55,448 --> 00:42:59,446
their code? I think that's an open question. Another thing

680
00:42:59,468 --> 00:43:03,202
is that right now we have the advantage of having an open source framework.

681
00:43:03,346 --> 00:43:06,978
People can see exactly the kinds of changes that we're

682
00:43:06,994 --> 00:43:10,906
making. They can understand them in terms of code and they can make

683
00:43:10,928 --> 00:43:14,154
a pull request or open an issue. And when you use

684
00:43:14,192 --> 00:43:17,562
llms you lose some of that transparency. On the other hand,

685
00:43:17,616 --> 00:43:21,638
there's definitely some code mods I've seen that would require some more context

686
00:43:21,814 --> 00:43:25,466
than just the kind of syntactic and semantic analysis we're

687
00:43:25,498 --> 00:43:28,574
doing can provide. And that's where an LLM could really help

688
00:43:28,612 --> 00:43:32,206
us make some even more sophisticated and clever kinds of

689
00:43:32,228 --> 00:43:35,460
changes. So it's something we're considering going forward.

690
00:43:36,230 --> 00:43:39,906
The other thing we're thinking about is of course I'm talking to you about

691
00:43:39,928 --> 00:43:43,486
the Python code moderator framework. All of this is currently implemented

692
00:43:43,518 --> 00:43:47,640
in terms of Python and it's also being applied to Python code.

693
00:43:48,650 --> 00:43:52,818
But the question we have is that could you have a framework that's implemented

694
00:43:52,834 --> 00:43:56,482
in Python? So the detection, all of this orchestration

695
00:43:56,546 --> 00:44:00,538
is implemented in terms of Python, but could we apply

696
00:44:00,624 --> 00:44:03,994
transformations to other kinds of code? And now

697
00:44:04,032 --> 00:44:07,626
of course in this case we wouldn't be using Libcst because that's only for

698
00:44:07,648 --> 00:44:10,778
Python. But maybe llms could help us here,

699
00:44:10,864 --> 00:44:13,660
or maybe there's some other frameworks that could help us out.

700
00:44:14,030 --> 00:44:17,646
So this is just something we've been thinking about. All right,

701
00:44:17,668 --> 00:44:20,798
so I'm just going to shamelessly say we'd love to have your feedback. This is

702
00:44:20,804 --> 00:44:24,178
an open source project. We'd love for you to open GitHub issues

703
00:44:24,264 --> 00:44:27,730
with suggestions or bug reports.

704
00:44:28,150 --> 00:44:31,538
We'd love for you to clone or fork the repo and try it out yourself.

705
00:44:31,704 --> 00:44:35,586
We'd love to earn your stars. And more than anything

706
00:44:35,688 --> 00:44:39,506
we would love to hear ideas from you about code mods

707
00:44:39,538 --> 00:44:43,906
you want to see. And even if you would like to contribute directly

708
00:44:43,938 --> 00:44:47,638
upstream, contribute your own code mod to our project,

709
00:44:47,724 --> 00:44:49,880
that would be awesome. We would love to see it.

710
00:44:51,290 --> 00:44:54,362
One thing I do want to mention right before the end of my talk

711
00:44:54,416 --> 00:44:58,134
here is when I talked about code TF in this interchange

712
00:44:58,182 --> 00:45:01,454
format. The way that we're using this at Pixie is we've built

713
00:45:01,492 --> 00:45:04,654
a GitHub application that you can install for

714
00:45:04,692 --> 00:45:08,270
free and that consumes the results of Codemodder.

715
00:45:09,090 --> 00:45:12,414
And you can see here in this box. This is

716
00:45:12,452 --> 00:45:15,410
where the summary field of that code mod is being used,

717
00:45:15,560 --> 00:45:18,754
and then down here is where the description is being used.

718
00:45:18,952 --> 00:45:22,786
So Pixiebot automatically applies Codemodder to your

719
00:45:22,808 --> 00:45:27,110
code base, and it orchestrates all this together and opens pull requests

720
00:45:29,370 --> 00:45:33,046
with suggested changes for your code. It's really cool. Again, it's free

721
00:45:33,068 --> 00:45:36,374
to install. We'd love for you to try it out. The other thing

722
00:45:36,412 --> 00:45:40,086
Python codemods helps with is our pixie

723
00:45:40,118 --> 00:45:43,386
command line interface, or the CLI. This is sort of a

724
00:45:43,408 --> 00:45:47,606
higher level user interface around both our Python and Java code modders

725
00:45:47,718 --> 00:45:50,940
provides a bit of a nicer user experience,

726
00:45:51,310 --> 00:45:55,162
but Codemodder is the

727
00:45:55,216 --> 00:45:57,680
results of Codemodder are being used by this tool,

728
00:45:58,130 --> 00:46:01,454
and this is also free to use. It's installable from

729
00:46:01,492 --> 00:46:04,862
homebrew and we'd love for you to try it out and

730
00:46:04,916 --> 00:46:08,414
give us feedback. So that's my talk.

731
00:46:08,532 --> 00:46:11,694
Thank you so much for spending a bit of time with me and learning about

732
00:46:11,732 --> 00:46:15,310
Python codemods. You can find me here on GitHub

733
00:46:15,690 --> 00:46:18,920
can. Here's my email address. I'd love to get feedback from you.

734
00:46:19,530 --> 00:46:23,526
Check us out at Pixie AI and look

735
00:46:23,548 --> 00:46:26,514
me up on LinkedIn. I'd love to hear your feedback, love to see your GitHub

736
00:46:26,562 --> 00:46:29,780
issues or get an email from you. And thanks again.

