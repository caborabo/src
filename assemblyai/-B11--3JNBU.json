{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/c8d60e54-30ad-450f-9e17-b1331bbbc0e7", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["codes", "conf fourty two", "dmitrii ivashchenko", "features", "improved", "latest features", "mygames", "python", "removals", "software engineer", "typing"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "speech_model": null, "id": "4f075f34-b13b-42e0-b45a-26e9ef9a8977", "status": "completed", "error": null, "text": "My name is Mitri Vaishinka. I am a software engineer at my games. In this talk, we will look at the latest features of Python 312. Today we are diving into four key areas, typing, syntax performance, and debugging. Let's dive into these enhancements one by one. So Python 312 brings exciting typing improvements. First, we have generics with a new, cleaner syst syntax. It makes writing generic classes and functions simpler. Next, typed dixed allows for precise type annotations of dictionary keys and values. The override creator ensures methods overrides those in superclass accurately. Advanced type parameters cater to more complex typing scenarios. Type lss are now easier to declare and use. They make code more readable and maintainable. And lastly, we will talk about lazy evaluation and scope rules. New syntax changes how we declare generics it's now more straightforward. Before, we used typefar for type parameters and classes needed generic t. To use generics, write the type in square brackets, look at the max function, and list class examples. The new way is clearer and simpler. No more extra steps or wrapping needed. This makes our code cleaner and easier to understand. Web 692 has transformed how we use quarks. It brings typed dict into function signatures. This means we can be precise with keyword arguments. Before, we had to use broad types, this didn't tell us much about the expected keywords. Now, with type dict, everything changes. We define exact keys and their types. This makes our function clear and safer. No more guessing what quarks should contain. It's a big leap for Python's type system, and it's great for functions that depend on keywords arguments. This clearly reduces aurora and proves readability. Pep 698 introduces typing override. It's new decorator for static typing. It marks methods that should override superclass methods. This helps catch discrepancies earlier, before method mismatches could slip through typers and method names went unnoticed. Typing override acts as a safeguard. It features our overrides are intentional and correct. This boots quadrability and main attainability. Web 695 marks a big step towards the Python's type system. It now supports type for a tuple and param specs directly in type LSS. This means we can define more complex types with this. For example, we can create a type for functions returning integers, or a tuple type that starts with a string followed by any number of elements. We can also restrict sequence elements to be hashable, and even define sequences that only contains integers or strings. This update simplifies the creation of generic types. It makes our code more expressive and easier to understand. With these tools, we can write more robust and type save Python code. Pep 695 brings a latest features type aliases now we can declare type aliases more easily, even with generic using the type statement. It makes our code hints cleaner and enhances their expressiveness. Before this update, defining LSS was more complex. We used typevar or dialect assigning types. This new syntax simplifies the process, making our code more readable. Python 312 introduces lazy evaluation for types. Types are evaluated only when needed. It's a big change, especially for complex types. Let's look at an example. We define a type alias that should cause an error, but the error only comes when we access a specific attribute. This allows for more complex type definitions, including immutably recursive type aliases. Before, such constructs were cumbersome. Now they are straightforward and elegant. Let's dive into syntax improvements. Python 212 has made app strings even better. Now we can reuse quotes inside appstrings without hassle. Nesting f strings is straightforward with no limits. You can spread app strings with multiple lines, even add comments. Backslashes and Unicode work smoothly in fstrings. Error messages got an upgrade. They are cleaner now, and there is inner tools batched. It's a handsy new addition. These changes make coding in Python simpler and more powerful. So let's look at these syntax improvements. Python 312 simplifies f strings. Now you can reuse quotes inside them. This change makes string formatting more intuitive. Here is an example with a reading list. Notice how the quotes are consistent throughout. Before, we would have caused a syntax error. Now the same quotes flow inside and out seamlessly. This update streamlines string composition in Python. Now you can nest f strings with each other as deep as needed. This makes complex string constructions easier. Here is an example to illustrate. We nest several f strings together. This was not as straightforward before Python 212 introduced multiline f strings. You can now include comments right inside them. This makes complex strings clearer and easier to maintain. Here is how you can format a movie list with comments. Each movie is annotated with its unique attribute with this feature enhances code reliability significantly, especially when dealing with intricate string constructions. The new update expands f strings to include backslashes and Unicode. Now special characters and Unicode symbols fit right into f strings. Here is how you can separate items with new lines in an f string, or join them using Unicode character like a black heart. With Python 312, f strings get better at showing where errors are. Debugging f strings is now quicker, thanks to clearer error messages. Here's an example of an error in an app string. The message points exactly to where the mistake is. It even suggests you might have forgotten a comma. This precise feedback makes fixing errors faster. The new release introduces a handy tool iter tool batched. This function breaks down data into fixed size pieces. It's perfect for working with big data or streaming in parts. Here's how it works in a new version. Just a few lines of code and you are patching data easily. Before this, you had to write your own function for batching. Python 312 brings exciting performance boosts. First up, async I O is faster. That's great for async programming. Inspect and typing models are quicker. Now we have immortal objects too. They streamline memory management. There is a new guild strategy. It's unique pair interpreter comprehension in lining speeds up your list and dict creations, and more and more enhancements under the hood, Python 312 boosts async speed significantly. Benchmarks show up to 75 increase in speed. Socket writing is now more efficient. Creating async tasks is faster than before. Current task is now implemented in C. This change along speeds things up by four to six times. These improvements make asyncular slicker and faster. And for I o bound tasks, this means better responsiveness. The inspect and typing modules are now faster. Inspect get ultra static sees speed increase by up to six times, as instance checks against protocols are much quicker. Some checks are now 20 times faster than before. However, protocols with over 14 members might be slower. This tradeoff targets efficiency for most common use cases. These enhancements aid in better code analysis and typing. Overall, Python's introspection and typing are more efficient. Pep 684 brings a game changing update to Python. Each Python interpreter now gets its own global interpreter lock. This allows true parallelism across multiple cpu cores. Currently, it's accessible through the C API. A Python API is expected in version 3.13. This feature opens a new door for high performance Python applications. It's a significant step towards optimizing Python concurrency. Model 709 marks a pivotal shift in Python comprehensions. It introduces inlining for lists, dictionaries, and sets. This eliminates the need for creating temporary function. Objects comprehensions are now up to twice as fast. They also keep variables isolated, enhancing code safety tracebacks and profiling. See some changes due to this. The SIM table module adapts along with locals behavior in comprehensions. Notable quark involves iterating over locals during tracing. There is a straightforward workaround for that. Pep 683 talks about a new idea called immortal objects. These are special because they don't need tracking how many times they are used. This is good for big apps like Django codes with lot of users to run smoother in Python, using an object normally means it gets counted, which can slow things down. But with immortal objects, this counting doesn't happen, keeping things fast. Still, this cool feature is only useful for a few Python projects. Pep 688 makes a buffer protocol accessible from Python. Now classes with a buffer method works as buffers. It introduces two new magic methods, buffer and release buffer. There's a new standard way to talk about buffer objects in Python, a new set of options for making buffers just right. Two new special methods make buffers easier to use in Python. This is great for sharing data, especially with C extensions, but most Python users might not found this very useful. Python 312 brings a mix of performance boosts. The vault optimizer is now in experimental phase. It promises a noticeable increase in speed. Regex substitutions are quicker by two or three times, comprehensions for common collections are more efficient and calls to the super method are now faster. Debugging in Python 312 got a big upgrade. Name error suggestions are sharper now. They got you better. Syntax and import errors messages are clearer. They are more helpful now. New API for monitoring Python execution events these changes make debugging less of headache and more of breeze. Python 312 makes error messages more helpful. Name errors now offer suggestions for fixes. It can hint at missing standard library inputs. It also suggests correct instances attributes. For example, it might recommend using self attribute. These changes make debugging much easier and new release improved syntax error messages errors like import x from Y now have clearer guidance. Import error now suggests correct names from the module. These changes simplify debugging. They help quickly identify and fix import errors, especially useful with unfamiliar libraries. Pep 669 transforms how we monitor Python execution. It introduces a new low impact monitoring API. This is perfect for profilers, debuggers and monitoring tools. The API covers a broad range of events with little overhead. Debugging and coverage can now be nearly overhead free. Here is how to use the new capabilities in Python 312. Previously, tracing calls had a higher performance cost. With Pep 669, monitoring is more efficient and less intrusive. So we've covered the updates in Python 312. Improvements touch on typing, syntax, debugging, and performance. These changes significantly simplify development. They make code more reliable and understandable. So thank you for your attention and see you next time.", "words": [], "utterances": null, "confidence": 0.914498735177868, "audio_duration": 906.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Python 312 brings exciting typing improvements. Web 692 brings typed dict into function signatures. Type lss are now easier to declare and use. They make code more readable and maintainable. And lastly, we will talk about lazy evaluation and scope rules.\n- Python 212 has made app strings even better. You can reuse quotes inside appstrings without hassle. Nesting f strings is straightforward with no limits. Backslashes and Unicode work smoothly in fstrings. Error messages got an upgrade. These changes make coding in Python simpler and more powerful.\n- Python 312 simplifies f strings. Now you can reuse quotes inside them. This makes complex strings clearer and easier to maintain. With Python 312, f strings get better at showing where errors are. Debugging f strings is now quicker. Pep 684 brings a game changing update to Python.\n- Pep 688 makes a buffer protocol accessible from Python. Python 312 makes error messages more helpful. New API for monitoring Python execution events. Debugging and coverage can now be nearly overhead free.\n-  Improvements touch on typing, syntax, debugging, and performance. These changes significantly simplify development. They make code more reliable and understandable. So thank you for your attention and see you next time.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.08, "text": "Python code", "timestamps": [{"start": 236796, "end": 237800}]}, {"count": 1, "rank": 0.07, "text": "Python comprehensions", "timestamps": [{"start": 630588, "end": 632070}]}, {"count": 1, "rank": 0.07, "text": "improved syntax error messages errors", "timestamps": [{"start": 824766, "end": 827746}]}, {"count": 2, "rank": 0.07, "text": "complex types", "timestamps": [{"start": 204532, "end": 205306}, {"start": 278140, "end": 279282}]}, {"count": 1, "rank": 0.07, "text": "more complex types", "timestamps": [{"start": 204298, "end": 205306}]}, {"count": 2, "rank": 0.07, "text": "Python execution", "timestamps": [{"start": 789222, "end": 790422}, {"start": 851322, "end": 852670}]}, {"count": 2, "rank": 0.07, "text": "New syntax", "timestamps": [{"start": 81210, "end": 81954}, {"start": 264152, "end": 264766}]}, {"count": 1, "rank": 0.07, "text": "Python concurrency", "timestamps": [{"start": 624158, "end": 625454}]}, {"count": 1, "rank": 0.07, "text": "high performance Python applications", "timestamps": [{"start": 619496, "end": 621438}]}, {"count": 1, "rank": 0.07, "text": "complex strings", "timestamps": [{"start": 401540, "end": 402506}]}, {"count": 1, "rank": 0.07, "text": "generic types", "timestamps": [{"start": 228428, "end": 229538}]}, {"count": 3, "rank": 0.06, "text": "type aliases", "timestamps": [{"start": 241970, "end": 243346}, {"start": 244706, "end": 245486}, {"start": 295078, "end": 296486}]}, {"count": 1, "rank": 0.06, "text": "type dict", "timestamps": [{"start": 134316, "end": 135138}]}, {"count": 2, "rank": 0.06, "text": "type parameters", "timestamps": [{"start": 65406, "end": 66414}, {"start": 89632, "end": 90730}]}, {"count": 1, "rank": 0.06, "text": "broad types", "timestamps": [{"start": 127212, "end": 128390}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}