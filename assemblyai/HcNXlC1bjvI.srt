1
00:00:20,640 --> 00:00:24,094
Hello everyone, welcome to my talk about reproducible and ephemeral development

2
00:00:24,174 --> 00:00:27,800
environments with Nix for our Golang projects.

3
00:00:27,982 --> 00:00:31,308
A little bit about myself my name is Haseeb Marjid. I'm a backend

4
00:00:31,436 --> 00:00:34,756
software engineer at Fintech called Curve. There's a link to my

5
00:00:34,780 --> 00:00:38,156
blog, a few fun facts about myself, very like cats, and I'm an

6
00:00:38,180 --> 00:00:41,916
avid village cricketer, bold and underlined on the

7
00:00:41,940 --> 00:00:45,476
village part there. But I'm looking forward to the cricket seasons dying in the next

8
00:00:45,500 --> 00:00:47,904
couple of weeks or so. It'll be good to get outside.

9
00:00:48,964 --> 00:00:52,384
So who is this talk aimed at? It's aimed at few groups of people,

10
00:00:52,724 --> 00:00:55,652
the first group being those who are kind of interested in Knicks and want to

11
00:00:55,668 --> 00:00:58,970
learn a bit more. And for sure we'll cover that. It's also

12
00:00:59,002 --> 00:01:02,490
aimed at those people who are looking to improve the developer experience, particularly around

13
00:01:02,522 --> 00:01:06,706
the consistency of the development environments. So things like

14
00:01:06,850 --> 00:01:10,210
going back to an old project like six months ago that you haven't touched and

15
00:01:10,242 --> 00:01:13,186
you're worried that you're going to spend a half a day yak shaving getting the

16
00:01:13,210 --> 00:01:17,178
development environment working, you're going to want to want

17
00:01:17,186 --> 00:01:20,650
to faff around with that. You want to just get on building features, bug fixes,

18
00:01:20,682 --> 00:01:24,106
adding tests, whatever you want to do, work on actual code.

19
00:01:24,290 --> 00:01:26,994
And so we'll take a look at how we can use nics to help with

20
00:01:27,034 --> 00:01:30,954
that. We'll also look at how we can make it easier to onboard

21
00:01:30,994 --> 00:01:34,402
new developers. So they have to type one or two commands just to

22
00:01:34,418 --> 00:01:37,522
get set up on a project. And especially if we can have consistency across lots

23
00:01:37,538 --> 00:01:41,466
of our projects, imagine at work then

24
00:01:41,490 --> 00:01:44,722
it means that developers kind of know they have one or two commands to write

25
00:01:44,738 --> 00:01:48,122
and they can jump between projects really easily and again get coding as

26
00:01:48,138 --> 00:01:51,626
fast as possible. Then also we don't just want things to

27
00:01:51,650 --> 00:01:55,514
work on our machine, we want them to work across everywhere

28
00:01:55,554 --> 00:01:59,050
we run this. So whether that be locally CI or

29
00:01:59,122 --> 00:02:03,060
even say like your various environments

30
00:02:03,172 --> 00:02:06,024
that you have production dev, etcetera, etcetera.

31
00:02:07,364 --> 00:02:10,380
And we don't want to annoy Samuel Jackson, do we want it to work everywhere?

32
00:02:10,412 --> 00:02:13,892
We don't want it to just work on our machine. So some of

33
00:02:13,908 --> 00:02:17,164
you probably wondering what's Nix? Nix is a declarative package

34
00:02:17,204 --> 00:02:20,492
manager, and we'll cover what declarative means in a second. But package manager

35
00:02:20,508 --> 00:02:23,812
in the sense it's a tool for installing packages on our

36
00:02:23,828 --> 00:02:27,668
machine, which is kind of, especially as a software developer, kind of a

37
00:02:27,716 --> 00:02:30,704
fundamental thing we need to do on our machines is install packages.

38
00:02:31,604 --> 00:02:35,036
It's similar to tools like ApT, Pac man or brew that

39
00:02:35,060 --> 00:02:38,404
you may be familiar with. It's powered by this thing that I'm going to call

40
00:02:38,444 --> 00:02:41,868
Nixlang. You may hear it called the Nix

41
00:02:41,916 --> 00:02:46,020
programming language and it's this pure, functional and

42
00:02:46,052 --> 00:02:49,692
lazily evaluated language. And what we mean by pure

43
00:02:49,708 --> 00:02:53,212
and functional is that it doesn't have really side

44
00:02:53,268 --> 00:02:57,044
effects. It does have like one or two, but basically for the same input,

45
00:02:57,084 --> 00:03:00,012
has the same output. It doesn't really depend on the state of your machine.

46
00:03:00,108 --> 00:03:03,540
So it means if we have these like NICs configuration files, we can kind of

47
00:03:03,612 --> 00:03:07,544
easily move them between devices and people because,

48
00:03:08,124 --> 00:03:10,964
you know, it's not really relying on the state of your machine, which is quite

49
00:03:11,004 --> 00:03:14,132
nice and lazily evaluated in the sense that it just works out

50
00:03:14,148 --> 00:03:17,340
kind of the bare minimum it needs. It's lazy, it's just like, okay,

51
00:03:17,412 --> 00:03:20,444
I have enough information to go build this package, I don't need any more.

52
00:03:20,604 --> 00:03:23,764
And that's particularly useful. You know, we have 80,000 packages in the Nix

53
00:03:23,804 --> 00:03:27,196
packages repository. We don't want to build all of them,

54
00:03:27,220 --> 00:03:30,956
for example. We just want to build the ones that we need for the packages

55
00:03:31,020 --> 00:03:35,138
we want, right? There's also this thing called Nixos Linux

56
00:03:35,186 --> 00:03:39,234
distribution that's powered by Nixlang and can be configured

57
00:03:39,394 --> 00:03:42,458
using Nixlang. And it's also powered by the Nix package manager.

58
00:03:42,506 --> 00:03:45,522
We're not really going to talk much about that. I do daily drive it,

59
00:03:45,538 --> 00:03:48,682
it's pretty cool. But just know it's separate from Nix. You could have like say

60
00:03:48,698 --> 00:03:51,894
an Ubuntu machine that's running the Nix package manager.

61
00:03:52,914 --> 00:03:56,250
So when we say something is declarative, what we mean is

62
00:03:56,282 --> 00:04:01,090
that we kind of just care about the final state of things. Whereas typically

63
00:04:01,242 --> 00:04:05,154
package managers are imperative where we're giving it like step by step instructions.

64
00:04:05,314 --> 00:04:08,522
So for example, if I was to say make me a cup of tea and

65
00:04:08,538 --> 00:04:11,826
then I gave you instructions like, you know,

66
00:04:11,850 --> 00:04:15,162
get the teabag, turn on the kettle, etc. Etcetera, that would

67
00:04:15,178 --> 00:04:18,642
be what you might classify as imperative. Whereas declarative is just me saying can you

68
00:04:18,658 --> 00:04:21,986
make me a cup of tea with milk and sugar? And then you kind of

69
00:04:22,010 --> 00:04:25,050
work out how to get to that final state. And it's very much the same

70
00:04:25,082 --> 00:04:28,522
with nics. In this case we have the sway tiling window manager

71
00:04:28,538 --> 00:04:31,346
that we want to turn on and we want to turn off the I three

72
00:04:31,490 --> 00:04:34,842
window manager. We're not telling Nix how to do that. We just say this

73
00:04:34,858 --> 00:04:38,586
is the final state and mix goes off, runs off and does that.

74
00:04:38,730 --> 00:04:42,106
One of the other cool things about generally

75
00:04:42,130 --> 00:04:45,186
when things are declarative is we often put them into code and then we

76
00:04:45,210 --> 00:04:48,694
get other benefits, like version control, easier for people to review,

77
00:04:49,474 --> 00:04:53,770
easier to reproduce as well, because again, it's not really caring

78
00:04:53,802 --> 00:04:56,934
about the state of our system. If I don't have I three installed, for example,

79
00:04:57,674 --> 00:05:01,318
Nix will just work this out fine, it just won't uninstall I three.

80
00:05:01,466 --> 00:05:05,118
It's pretty cool. Then I think, I think it's definitely

81
00:05:05,166 --> 00:05:08,838
a really useful feature of Nix. And then once

82
00:05:08,966 --> 00:05:12,254
I definitely will have converted you to Nix, you can start busting this out into

83
00:05:12,294 --> 00:05:15,634
conversation. By the way, I use Nix to your friends and just

84
00:05:15,934 --> 00:05:19,190
doesn't matter what the conversations, you can always change it and I'm sure

85
00:05:19,222 --> 00:05:21,754
they won't mind at all.

86
00:05:22,614 --> 00:05:26,686
What's the problem we're solving? Well, imagine like typically when

87
00:05:26,710 --> 00:05:30,310
we have binaries installed, we might have them in user local bin, like go

88
00:05:30,342 --> 00:05:33,526
Lang ci lint. There are a few problems that

89
00:05:33,630 --> 00:05:36,274
the typical package managers have. It's like,

90
00:05:36,854 --> 00:05:40,766
what dependencies does this need? Like runtime and a

91
00:05:40,790 --> 00:05:44,126
build time? Like how easy is it to discover that? What configuration

92
00:05:44,190 --> 00:05:47,310
flags was this tool built with an environment? Variables,

93
00:05:47,342 --> 00:05:50,502
right? If you wanted to like build the same version yourself, how'd you

94
00:05:50,518 --> 00:05:53,870
do that? And then how do we have two versions of this package? What if

95
00:05:53,902 --> 00:05:56,654
we need to have version two, for example, in version one?

96
00:05:56,734 --> 00:06:00,126
Now as far as I'm aware, Go Lang Ci lint doesn't have a version two,

97
00:06:00,150 --> 00:06:03,990
but it might. And for some projects, you might want to use version until

98
00:06:04,102 --> 00:06:07,006
you've upgraded it. And for some projects, you might want to use version two.

99
00:06:07,110 --> 00:06:10,718
How do you do that? Because typically our package managers replace the binaries

100
00:06:10,766 --> 00:06:14,190
in place, right? So we replace this with version two. So how do we

101
00:06:14,302 --> 00:06:17,686
maintain multiple versions? And there's various packaging solutions that kind of

102
00:06:17,710 --> 00:06:20,846
solve some of these problems. You have like snaps and flat packs which create these

103
00:06:20,870 --> 00:06:24,190
sandbox environments, and they have their dependencies, I believe,

104
00:06:24,302 --> 00:06:27,198
in these kind of sandbox environments, and they don't really interact with the rest of

105
00:06:27,206 --> 00:06:30,494
the system. We have ASDF for managing like

106
00:06:30,534 --> 00:06:33,862
multiple versions of some of our tooling, like Go node,

107
00:06:33,918 --> 00:06:37,158
Python, et cetera, et cetera. We have virtual environments and to a

108
00:06:37,166 --> 00:06:40,366
certain degree go modules, so we can have per project

109
00:06:40,430 --> 00:06:43,554
dependencies and we don't need them globally installed.

110
00:06:44,014 --> 00:06:48,030
More so for virtual environments than go modules, but yeah, virtual environments

111
00:06:48,102 --> 00:06:50,634
used in python. For those of you who may not know,

112
00:06:51,374 --> 00:06:54,526
to summarize this section, we want to have reproducible and

113
00:06:54,550 --> 00:06:57,958
ephemeral environments. NICS is an ecosystem of tools. So we

114
00:06:57,966 --> 00:07:01,414
have NICs, Nixos, Nix packages, the Nix programming language,

115
00:07:01,574 --> 00:07:05,582
the main thing, of course, being the package manager. And then our current packaging

116
00:07:05,638 --> 00:07:09,502
systems all have various flaws. There's nothing in software engineering that's

117
00:07:09,518 --> 00:07:13,118
a silver bullet, Nics included. It can be a bit complicated. Nics,

118
00:07:13,166 --> 00:07:16,394
you kind of have to learn this programming language, which puts people off.

119
00:07:17,414 --> 00:07:21,086
But I think the upsides beat the

120
00:07:21,110 --> 00:07:24,382
downsides of Nics, in my opinion. So if we take a look at this demo,

121
00:07:24,438 --> 00:07:27,934
we look for this go lang ci lint binary, can't find

122
00:07:27,974 --> 00:07:31,342
it. We go into this project, we load this dev environment, and then when we

123
00:07:31,358 --> 00:07:34,630
look for this binary, we can find it. And when we leave this

124
00:07:34,822 --> 00:07:37,806
project, we will no longer have this. And this is kind of the state we

125
00:07:37,830 --> 00:07:40,094
want to get to. This is kind of what we want for our developers.

126
00:07:40,134 --> 00:07:43,982
And we want to make sure that people are getting the same versions of tooling

127
00:07:44,078 --> 00:07:47,854
as everyone else. In this case, I think it's version 1.56.2.

128
00:07:47,934 --> 00:07:51,374
We want to make sure all the developers are getting that same versioning.

129
00:07:51,454 --> 00:07:54,846
And when I say ephemeral development environments, what I

130
00:07:54,870 --> 00:07:58,158
mean is short lived, temporary in the sense that just

131
00:07:58,246 --> 00:08:01,902
existing for the lifecycle of this project. And when we leave it, the environment's kind

132
00:08:01,918 --> 00:08:04,394
of gone or not loaded.

133
00:08:05,134 --> 00:08:08,442
But yeah, so that's kind of what we're going to achieve and we're going to

134
00:08:08,538 --> 00:08:11,494
take a look throughout this talk how we can achieve that.

135
00:08:12,194 --> 00:08:15,274
So how does this relate to go lang? Well,

136
00:08:15,434 --> 00:08:18,930
with go, we need tooling to aid development, right?

137
00:08:18,962 --> 00:08:22,994
Like we might need binaries to generate code coverage reports. We may

138
00:08:23,034 --> 00:08:26,330
have tools to vet our code. Static code analysis,

139
00:08:26,402 --> 00:08:29,970
container code analysis, all these things that go into development,

140
00:08:30,042 --> 00:08:33,282
you know, Docker and Docker compose. We have,

141
00:08:33,298 --> 00:08:36,490
you know, dependencies for our projects and we're not really going to worry about those,

142
00:08:36,522 --> 00:08:40,026
you know, that we manage viago, but the other tooling

143
00:08:40,050 --> 00:08:43,402
we need to aid our development, maybe we have a task runner, like we have

144
00:08:43,418 --> 00:08:46,454
makefiles, right? Like we might do make lint or make test.

145
00:08:47,554 --> 00:08:51,146
And we want to make sure developers have similar versions or the same versions if

146
00:08:51,170 --> 00:08:53,746
we can. And we want to make sure the same versions are running in CI,

147
00:08:53,810 --> 00:08:57,922
they're running locally, because I'm sure we've all been bit by the

148
00:08:57,938 --> 00:09:01,514
bug where it fails in CI is working

149
00:09:01,554 --> 00:09:05,432
locally and it's just because of a version mismatch. Couldn't see our

150
00:09:05,448 --> 00:09:09,088
word for a second. So one way we can kind of do this is,

151
00:09:09,176 --> 00:09:11,520
and we do the set curve for some of our projects is we have this

152
00:09:11,552 --> 00:09:14,696
tools go file. And essentially what we're going to do here

153
00:09:14,760 --> 00:09:19,720
is we're going to manage our dependencies using go module. So we install these

154
00:09:19,752 --> 00:09:23,312
various packages using go modules and

155
00:09:23,328 --> 00:09:26,936
then we add these underscores here to trick go modules into thinking

156
00:09:26,960 --> 00:09:30,240
it's important. So if you do a go mod tidy, it doesn't remove these.

157
00:09:30,432 --> 00:09:34,262
And the cool thing is then they're all kind of managed Vigo modules and

158
00:09:34,278 --> 00:09:38,086
we can do an update. We just update one file and it will update

159
00:09:38,110 --> 00:09:41,270
our dependencies and etc etcetera. It's quite

160
00:09:41,302 --> 00:09:44,274
nice. And we have this build flag so it doesn't get built with our binary

161
00:09:45,174 --> 00:09:48,734
and that works for go dependencies. And we maybe have a make target like this

162
00:09:48,774 --> 00:09:52,862
which installs these dependencies in our go path bin folder,

163
00:09:52,918 --> 00:09:56,862
which is not which works. But then we encounter similar

164
00:09:56,918 --> 00:10:00,430
problems as what we're talking about before. What if between projects we

165
00:10:00,462 --> 00:10:04,048
have version one of one tool and version two of another tool. We kind

166
00:10:04,056 --> 00:10:06,736
of have to remember then to run this tool which is going to overwrite the

167
00:10:06,760 --> 00:10:10,488
binary in that go path bin folder. There's something else we have

168
00:10:10,496 --> 00:10:13,920
to remember to do when we're jumping between projects. And then what if we want

169
00:10:13,952 --> 00:10:17,016
to manage tooling not related to go? What if we wanted to make sure that

170
00:10:17,040 --> 00:10:20,560
the user has GNU make or GNU

171
00:10:20,592 --> 00:10:24,512
parallels or some other CLI tools and

172
00:10:24,528 --> 00:10:27,104
maybe we have some bash scripts or something. And we want to make sure certain

173
00:10:27,144 --> 00:10:30,216
tooling is available in that. And so I think this is where Nix can come

174
00:10:30,240 --> 00:10:32,432
in and fix a few of our problems. So let's take a look at how

175
00:10:32,448 --> 00:10:35,444
we can create a development environment in Nixon.

176
00:10:36,134 --> 00:10:39,754
So imagine we have a project like this, really simple go project.

177
00:10:40,574 --> 00:10:43,806
How are we going to create this Nix environment? Don't worry about the syntax of

178
00:10:43,830 --> 00:10:45,998
nics and what's kind of happening behind the scenes. We're going to take a look

179
00:10:46,006 --> 00:10:49,422
at that just later in this talk in a couple of minutes. But first we're

180
00:10:49,438 --> 00:10:52,718
going to take a look at how we can create this development environment.

181
00:10:52,846 --> 00:10:56,062
So we have this flake Nix file. Think of it as a main go file,

182
00:10:56,078 --> 00:10:58,554
as the entry point to our Nix configuration.

183
00:10:59,974 --> 00:11:02,758
It has a bunch of inputs and a bunch of outputs. In this case,

184
00:11:02,846 --> 00:11:06,518
our inputs are all basically going to be git repositories. So one of them being

185
00:11:06,566 --> 00:11:10,366
Nix packages, which is this repository that has 80,000 packages.

186
00:11:10,430 --> 00:11:14,182
So this is where we're going to install our packages from, has a bunch

187
00:11:14,198 --> 00:11:17,478
of outputs. Nix flakes can output a lot of stuff.

188
00:11:17,566 --> 00:11:21,274
They can output build a docker image they can build an ISO, they can

189
00:11:21,734 --> 00:11:25,286
create a development shell, which is what we're going to do, Dev Shell.

190
00:11:25,470 --> 00:11:28,870
They can build a package, they can do lots of various different things, but we're

191
00:11:28,902 --> 00:11:31,414
really just going to focus on dev shells today. But it's just good to know

192
00:11:31,494 --> 00:11:36,062
generally speaking. So we have this helper library called flake utils,

193
00:11:36,238 --> 00:11:39,974
which basically just reduces some boilerplate in our flake where

194
00:11:40,134 --> 00:11:43,774
obviously packages have to be built for specific architecture.

195
00:11:43,814 --> 00:11:47,486
So you know, like x 86 64 Linux or Arch

196
00:11:47,550 --> 00:11:51,166
Darwin, you know, it's like AMD and intel versus

197
00:11:51,230 --> 00:11:54,742
arm based chips, different architecture. So we have to build the binaries

198
00:11:54,798 --> 00:11:59,074
differently and so packages are built, we have different slight packages.

199
00:12:00,854 --> 00:12:04,342
So we're here basically what we're doing is we're just specifying that we want to

200
00:12:04,358 --> 00:12:08,270
just get the packages for our system architecture and flake

201
00:12:08,302 --> 00:12:11,870
utils. Lib is this library that helps us reduce the boilerplate to do that.

202
00:12:11,902 --> 00:12:15,686
But that's basically all we're doing here. So don't necessarily worry about that here.

203
00:12:15,710 --> 00:12:19,190
What we're doing is we're creating a default dev shell. We have this

204
00:12:19,222 --> 00:12:23,086
packages make shell function. So between the kind of curly braces is

205
00:12:23,110 --> 00:12:26,214
this function and we're passing a parameter called packages,

206
00:12:26,374 --> 00:12:30,110
and these are all the packages we want to make available to the user of

207
00:12:30,142 --> 00:12:33,222
this dev shell. The details

208
00:12:33,238 --> 00:12:36,470
again don't matter too much that I just took that from a project I had

209
00:12:36,582 --> 00:12:39,652
called Optinx, which I've linked later on. You can take a look at that.

210
00:12:39,798 --> 00:12:42,696
So we take a look at, so how do we use this? Well,

211
00:12:42,720 --> 00:12:45,484
if we kind of look for the binary, we won't find it,

212
00:12:45,824 --> 00:12:49,760
it's fine. Then we do nixdevelop, which will load our development shell that we just

213
00:12:49,792 --> 00:12:53,080
created there. And then when we look for our go lang ci link binary,

214
00:12:53,112 --> 00:12:57,164
we can kind of see at this funny path next door, some funny

215
00:12:57,464 --> 00:13:01,000
characters hash maybe, and then yeah, cool.

216
00:13:01,072 --> 00:13:04,840
So we've created a development environment. So if we kind of summarize what we've done

217
00:13:04,872 --> 00:13:08,580
so far, well, we can leverage flakes and dev shells for installing

218
00:13:08,612 --> 00:13:12,900
packages. We can load into those shells or that shell using nixdevelop.

219
00:13:13,092 --> 00:13:16,956
We can make sure each developer gets the same package. We have this concept

220
00:13:16,980 --> 00:13:20,612
of this flake lock file which locks our inputs, and we'll take

221
00:13:20,628 --> 00:13:23,580
a look at the syntax of that and how that works a little bit later

222
00:13:23,612 --> 00:13:27,764
in this talk, but just keep that in mind and

223
00:13:27,844 --> 00:13:31,264
we can update this lock file, but we have to kind of manually do it.

224
00:13:32,864 --> 00:13:36,192
So one other thing that's quite cool is we can

225
00:13:36,208 --> 00:13:39,564
use this again nix agnostic tool called diranv.

226
00:13:40,064 --> 00:13:43,720
And with Diram what we do is create an MVC file,

227
00:13:43,832 --> 00:13:47,776
and what we put in this MVC file will get executed when

228
00:13:47,800 --> 00:13:50,888
we load into this directory automatically. So what we can do here

229
00:13:50,896 --> 00:13:54,560
is do this useflake, which is kind of this helper function for

230
00:13:54,592 --> 00:13:58,856
running Nix developer automatically. The very first time we load into a

231
00:13:58,880 --> 00:14:02,240
directory that has deriv, we do have to has this MVC

232
00:14:02,272 --> 00:14:05,880
file with Dirham, we do have to approve it so we don't just run

233
00:14:05,912 --> 00:14:09,364
arbitrary code on our machine. So let's take a look at what that looks like.

234
00:14:09,744 --> 00:14:13,624
So imagine I'm at work and I need to add a feature to a project.

235
00:14:13,744 --> 00:14:17,856
I clone this example project, I try and find this linter.

236
00:14:17,880 --> 00:14:21,484
I want to lint the code right, can't find it? Fine,

237
00:14:22,424 --> 00:14:25,312
I load in. I do Durin Valalau, because remember that first time we have to

238
00:14:25,328 --> 00:14:29,184
do Durin Valalau which has this useflake. It will load in this dev

239
00:14:29,224 --> 00:14:32,860
shell. In this case it's ready cached.

240
00:14:33,012 --> 00:14:35,884
It doesn't need to do anything. It can just load in one that I already

241
00:14:35,924 --> 00:14:39,316
had. Then in my case, because I'm

242
00:14:39,340 --> 00:14:42,532
using starship prompt, and I'm sure other prompts do this as well, it will let

243
00:14:42,548 --> 00:14:45,956
me know that I'm in a development environment here with the viya, and it has

244
00:14:45,980 --> 00:14:49,644
that little flake, which is quite nice. Just a good reminder that you're

245
00:14:49,724 --> 00:14:53,420
in this dev shell. Then when we look for this binary, we can

246
00:14:53,452 --> 00:14:57,644
find it. When we leave this folder, we can't find anymore.

247
00:14:58,144 --> 00:15:01,968
And so that's again that ephemeral nature I was talking about. And one

248
00:15:01,976 --> 00:15:05,232
of the cool things about Dirham is the first time you go into a directory,

249
00:15:05,248 --> 00:15:07,808
it'll tell you you have to do Durham Valao, so it's not something that you

250
00:15:07,816 --> 00:15:10,696
have to remember, it will tell you. And again, you only have to do it

251
00:15:10,720 --> 00:15:14,376
once. Next time I go to that directory, you won't have to run that again.

252
00:15:14,560 --> 00:15:18,104
One other thing we can do with Durham, the Nix flakes,

253
00:15:18,144 --> 00:15:21,616
is we can point to a dev shell or

254
00:15:21,640 --> 00:15:25,442
some Nix configuration that has a dev shell in

255
00:15:25,458 --> 00:15:28,650
a remote repository. In this case it's on GitHub, and we can use

256
00:15:28,682 --> 00:15:32,174
that if we want. So we can share configuration, and we could

257
00:15:32,514 --> 00:15:35,698
use multiple flakes as well if we wanted to. But we're not really going to

258
00:15:35,706 --> 00:15:38,746
get into that for this talk. But just to know if you want to have

259
00:15:38,770 --> 00:15:42,450
a remote development environment, you can as well, or the

260
00:15:42,482 --> 00:15:46,306
config remote, you can use that. One other

261
00:15:46,330 --> 00:15:49,658
thing that I think can really improve the developer experience and something we can manage

262
00:15:49,706 --> 00:15:52,826
with NICs is pre commit. So you know,

263
00:15:52,890 --> 00:15:56,322
we have these things called githooks, which is these scripts we can run at various

264
00:15:56,378 --> 00:16:00,466
stages of the git process, like pre commit, post commit, pre push,

265
00:16:00,530 --> 00:16:04,034
post push, etc. Etcetera. Then there's this tool which can be a bit

266
00:16:04,074 --> 00:16:07,514
confusing, as in this bit confusingly named called pre commit,

267
00:16:07,594 --> 00:16:11,298
which will basically help us create these pre commit git hooks for us.

268
00:16:11,466 --> 00:16:15,474
So we can create this using nics. So if we do pre commit hooks,

269
00:16:15,514 --> 00:16:18,642
add that as input. Again, you can name these inputs wherever you

270
00:16:18,658 --> 00:16:22,190
want, just helps to kind of make them somewhat related.

271
00:16:22,382 --> 00:16:25,950
We add that into our output section here and say we want to create these

272
00:16:26,062 --> 00:16:29,190
pre commit hooks. It has some built in hooks for go that we can use.

273
00:16:29,222 --> 00:16:32,614
So we use golangs. We're going to enable the linter and we're going

274
00:16:33,114 --> 00:16:36,502
to enable tests. The cool thing is it will only lint

275
00:16:36,558 --> 00:16:39,502
and run tests on the files that have changed, as in the ones we're trying

276
00:16:39,518 --> 00:16:43,166
to commit. And so yeah, we get some really fast feedback when

277
00:16:43,190 --> 00:16:46,622
these run. Saves us time waiting for CI and save some

278
00:16:46,758 --> 00:16:50,262
credits as well, build time that could go

279
00:16:50,318 --> 00:16:54,078
used for somewhere else. Then we can add the to our make shell

280
00:16:54,166 --> 00:16:57,822
function that we had. And the shell hook is just a command that

281
00:16:57,838 --> 00:17:01,326
will run automatically. When we do nix develop, I will load into the shell,

282
00:17:01,350 --> 00:17:04,518
which is going to happen automatically when we're using Diran. So essentially when we go

283
00:17:04,526 --> 00:17:07,726
into the folder it's going to install our pre commit hooks for us.

284
00:17:07,750 --> 00:17:11,030
Whereas normally the developer would have to remember to run the pre commit

285
00:17:11,062 --> 00:17:14,302
install like it's another command they have to do and now they don't have to

286
00:17:14,318 --> 00:17:17,566
think about, which I think is pretty cool. And with these pre

287
00:17:17,590 --> 00:17:20,992
commit hooks you can get some again really fast feedback. So it closes that kind

288
00:17:21,008 --> 00:17:24,400
of feedback loop and lets the developer know something's going

289
00:17:24,432 --> 00:17:27,632
wrong or not. To kind of summarize this bit, what we've done, we can

290
00:17:27,648 --> 00:17:30,720
use Durham to further reduce cognitive load on our developers.

291
00:17:30,912 --> 00:17:34,832
We can use flakes from remote git repositories, share them between multiple projects

292
00:17:34,848 --> 00:17:38,416
if we want. We can also manage precommit in nics. Just something to

293
00:17:38,440 --> 00:17:41,520
note that pre commit is usually managed using a YAML file,

294
00:17:41,632 --> 00:17:45,000
and now we're using a nIcs. And some people do have an issue with

295
00:17:45,032 --> 00:17:48,716
abstracting away from the original the way we configure

296
00:17:48,740 --> 00:17:52,064
a tool. I don't mind it, but just something to consider.

297
00:17:52,924 --> 00:17:56,300
It's kind of the next section I want to cover is how does Nix work?

298
00:17:56,332 --> 00:18:00,084
Like what's happening behind the, behind the scenes. So everything in Nics is

299
00:18:00,124 --> 00:18:03,624
an expression which I believe is quite common for functional programming languages.

300
00:18:04,204 --> 00:18:07,588
Remember, this is powered by Nixlang. And so what we have is we

301
00:18:07,596 --> 00:18:11,476
have a file, maybe it's called shell Nix, and this will get imported somewhere.

302
00:18:11,660 --> 00:18:15,416
And we have this function essentially here in this file that takes in

303
00:18:15,480 --> 00:18:18,880
one parameter called packages, and then we have these triple dots which

304
00:18:18,912 --> 00:18:21,044
ignore any other parameters passed.

305
00:18:22,864 --> 00:18:26,792
Then we have this function call called packages make shell,

306
00:18:26,968 --> 00:18:30,160
and we pass a bunch of packages we want to install. So in this case,

307
00:18:30,192 --> 00:18:33,640
this nix expression, we return one nics expression from

308
00:18:33,672 --> 00:18:37,472
the file, which can be a compound of

309
00:18:37,528 --> 00:18:41,554
other Nics expressions put together, but we always return one.

310
00:18:42,054 --> 00:18:45,662
So in this case we're returning this function, and again this, this file

311
00:18:45,678 --> 00:18:48,726
will get imported and during the import that you'll

312
00:18:48,750 --> 00:18:52,070
have to pass packages. And yeah, we were kind of doing

313
00:18:52,102 --> 00:18:55,534
this with our flake dot nix file, but it was a little bit more

314
00:18:55,574 --> 00:18:58,686
hidden, I guess, what was

315
00:18:58,710 --> 00:19:02,262
going on. But that's kind of what nix is and kind of what we're doing

316
00:19:02,318 --> 00:19:05,758
here. So you might be wondering like, okay, we're, what's this

317
00:19:05,806 --> 00:19:08,550
go Lang ci lint? I get it's coming from Nics packages,

318
00:19:08,622 --> 00:19:12,422
but what, what does that mean? Well, on nix packages, the GitHub repository,

319
00:19:12,478 --> 00:19:15,790
we can go find the go Lang ci Linux expression, and it has this function

320
00:19:15,822 --> 00:19:19,494
called build gomodule, which is a helper function

321
00:19:19,614 --> 00:19:23,166
for building go modules. And you can see as like a name a version where

322
00:19:23,190 --> 00:19:26,950
to fetch it from. GitHub has a bunch of other information about

323
00:19:26,982 --> 00:19:30,566
how to build it and if it has any dependencies, et cetera, et cetera.

324
00:19:30,590 --> 00:19:33,982
So we have this nix expression there. Cool. If we dive

325
00:19:33,998 --> 00:19:37,486
a bit deeper and look at what's behind the build go module, it abstracts

326
00:19:37,510 --> 00:19:41,342
away the standard env derivation, where this derivation

327
00:19:41,398 --> 00:19:46,244
function is the most important built in Nics function.

328
00:19:47,304 --> 00:19:50,600
So when we're building packages, what's actually happening? It's a two step

329
00:19:50,632 --> 00:19:54,648
process. So when we do nix develop behind the scenes it'll be calling like Nix

330
00:19:54,696 --> 00:19:57,952
build of some kind. And behind the scenes we'll be doing this,

331
00:19:58,128 --> 00:20:01,352
this in two steps. And you'll see why we

332
00:20:01,368 --> 00:20:04,880
do this in two steps. So the first step is evaluation time. We take

333
00:20:04,952 --> 00:20:08,664
the nix expressions and the Golang Ci lint expression, and we return

334
00:20:08,704 --> 00:20:12,176
a derivation set. This DRV file where a derivation

335
00:20:12,240 --> 00:20:15,904
set or derivation is just a set of instructions how to build a package,

336
00:20:15,944 --> 00:20:19,328
kind of like a recipe. Then we have this build time.

337
00:20:19,416 --> 00:20:23,192
The derivation is built into a package, and that is what has a

338
00:20:23,208 --> 00:20:26,444
side effect on our machine where stuff is actually getting installed.

339
00:20:26,984 --> 00:20:30,936
So let's take a look at derivation. So derivations are put into

340
00:20:31,000 --> 00:20:34,240
our next store folder. They have the format hash name

341
00:20:34,312 --> 00:20:37,496
version dRv, where a hash is a cryptographic hash

342
00:20:37,520 --> 00:20:41,848
of all the inputs to that derivation. So let's say we have this go 121

343
00:20:41,896 --> 00:20:45,480
eight derivation, even if we're building go 121 eight, let's say

344
00:20:45,512 --> 00:20:48,568
we change an environment variable. We are

345
00:20:48,576 --> 00:20:51,232
going to get a different cryptographic hash there, and so we're going to get a

346
00:20:51,248 --> 00:20:54,792
different derivation, and for all intents and purposes it's a different package as

347
00:20:54,808 --> 00:20:58,848
far as Nix is concerned. So derivations

348
00:20:58,976 --> 00:21:02,296
and also packages are mutable. I mean, you can obviously

349
00:21:02,320 --> 00:21:05,416
go change them if you wanted to. Nix discourages you from doing that.

350
00:21:05,440 --> 00:21:08,160
You probably shouldn't, but you can if you really want to.

351
00:21:08,352 --> 00:21:10,896
Let's take a look at what this derivation looks like, and we can run this

352
00:21:10,920 --> 00:21:14,008
command at the top there. Don't worry if some of

353
00:21:14,016 --> 00:21:17,576
this is cut off. Doesn't really matter, it's more just high level what's

354
00:21:17,600 --> 00:21:21,928
going on. So we have a builder, how we're going to build it bash

355
00:21:22,056 --> 00:21:25,736
we have a bunch of environment variables. These are the only environment variables made

356
00:21:25,760 --> 00:21:29,672
available during the build. We have a bunch of input derivations,

357
00:21:29,728 --> 00:21:33,512
so other derivations this depends on, and Nix will make sure these

358
00:21:33,648 --> 00:21:37,352
derivations are built into packages before then we have a

359
00:21:37,368 --> 00:21:40,920
bunch of metadata where this package is going to get installed, what system it's

360
00:21:40,952 --> 00:21:44,502
for, name of the package. Then we have this package, which again is

361
00:21:44,518 --> 00:21:47,606
immutable. So if we wanted a different version of this package,

362
00:21:47,670 --> 00:21:49,754
let's say environment variable changes,

363
00:21:50,614 --> 00:21:54,006
it would be at a different path. And you can think of the

364
00:21:54,030 --> 00:21:57,794
path as a unique identifier, as far as Nix is concerned, of a package.

365
00:21:58,614 --> 00:22:01,990
Then there's some sim linking done later, which will determine which

366
00:22:02,022 --> 00:22:05,150
binary we end up using. Even if you think they're basically

367
00:22:05,182 --> 00:22:08,814
the same. Then within Nixdor we have everything we need. We have the binary,

368
00:22:08,974 --> 00:22:12,916
we have Sharego and has a bunch of other stuff, which is quite nice because

369
00:22:12,980 --> 00:22:16,892
our packages are immutable and we

370
00:22:16,908 --> 00:22:21,104
can kind of pre compute them. So Nix

371
00:22:21,884 --> 00:22:25,156
has a bunch of servers available to it

372
00:22:25,180 --> 00:22:28,452
that are kind of pre building these binaries and packages.

373
00:22:28,588 --> 00:22:31,316
And so what that means if a derivation says we need to build a package

374
00:22:31,340 --> 00:22:34,836
at this path, we can check if that package exists in our path. If it

375
00:22:34,860 --> 00:22:38,020
doesn't. We can go fetch from various different caches. In this

376
00:22:38,052 --> 00:22:41,332
case I'm fetching from the official Nixos cache.

377
00:22:41,428 --> 00:22:45,076
And the cool thing about that is often because these are being pre built and

378
00:22:45,100 --> 00:22:47,596
you can pre build them yourself as well if you want, and you can pre

379
00:22:47,620 --> 00:22:50,972
build your own packages if you wanted. It just means we just have to

380
00:22:50,988 --> 00:22:54,716
fetch them and download them. We don't actually have to build them ourselves on

381
00:22:54,740 --> 00:22:58,732
our machine, which is really cool. So often we're just downloading stuff we're

382
00:22:58,748 --> 00:23:02,460
not actually building because lots of these packages are pre built.

383
00:23:02,652 --> 00:23:06,108
Another advantage that this kind of approach gives us

384
00:23:06,196 --> 00:23:09,644
is that the dependency tree is explicit

385
00:23:09,804 --> 00:23:13,216
and we can see what go depends on and then what those tools

386
00:23:13,240 --> 00:23:16,792
depend on. So like it depends on bash, and then bash depends

387
00:23:16,808 --> 00:23:20,160
on glib C. And every anyone with this exact same

388
00:23:20,232 --> 00:23:23,924
unique identifiers and you know, starts with k, seven, ch,

389
00:23:24,344 --> 00:23:28,544
et cetera, et cetera will have the exact same dependencies

390
00:23:28,584 --> 00:23:31,764
as us if we print out this dependency tree

391
00:23:32,144 --> 00:23:35,984
and nextore basically becomes this kind of graph database of our

392
00:23:36,024 --> 00:23:39,616
dependencies. One other thing that doesn't matter so

393
00:23:39,680 --> 00:23:42,200
much for dev,

394
00:23:42,352 --> 00:23:45,744
specifically for dev environments, but it's kind of useful to know because of this approach

395
00:23:45,784 --> 00:23:49,304
of we're not updating stuff in place. We can kind of have this concept of

396
00:23:49,344 --> 00:23:53,724
generations and profiles and we can roll back to earlier versions of generations.

397
00:23:54,624 --> 00:23:57,604
We can also then have atomic updates if we want.

398
00:23:58,944 --> 00:24:02,784
Sorry, we do have atomic updates, and that basically means that

399
00:24:02,944 --> 00:24:06,318
if something fails during the update we

400
00:24:06,326 --> 00:24:10,294
can go back to an older version. Or we don't even end up updating

401
00:24:10,334 --> 00:24:13,542
the NICs profile at all because these binaries just end up getting

402
00:24:13,598 --> 00:24:17,630
mapped to stuff in Nick store. And yeah, unless we garbage

403
00:24:17,662 --> 00:24:21,074
collecting cleanup stuff it's kind of going to be there.

404
00:24:21,894 --> 00:24:25,638
One other thing to note is you'll notice that we use an epoch time of

405
00:24:25,686 --> 00:24:29,646
one, that is 1 January 1970. The reason for that

406
00:24:29,750 --> 00:24:33,758
is because the timestamp date time can be a form of non determinism,

407
00:24:33,806 --> 00:24:37,622
because sometimes that gets injected into the binary. What we want to make sure

408
00:24:37,758 --> 00:24:41,142
is that we build the exact same binary. Otherwise every time you built

409
00:24:41,158 --> 00:24:44,674
a package you get a different binary and so wouldn't, you know,

410
00:24:46,614 --> 00:24:50,686
we don't want that. So we set this to 1970 and we make

411
00:24:50,710 --> 00:24:53,886
it a deterministic timestamp. Then in the Nix world this

412
00:24:53,910 --> 00:24:56,878
is what bincat looks like, not user bincat,

413
00:24:56,926 --> 00:25:00,246
but in NICs store. Just to kind of

414
00:25:00,270 --> 00:25:04,166
summarize, NICs derivations allow us to have immutable packages, require us

415
00:25:04,190 --> 00:25:07,582
to make our dependencies explicit. One thing to kind of note is if

416
00:25:07,598 --> 00:25:11,262
a package is not nix packages, you will likely have to package it yourself.

417
00:25:11,398 --> 00:25:15,270
But because Nix packages has 80,000 other packages, often or

418
00:25:15,302 --> 00:25:18,286
always, I found if I need to package something, it's just that one thing.

419
00:25:18,390 --> 00:25:22,038
The dependencies it needs is almost always in nix packages

420
00:25:22,086 --> 00:25:25,222
itself. The next bit we're going to cover is nix flakes.

421
00:25:25,318 --> 00:25:28,074
So how does Nix flakes relate to stuff?

422
00:25:28,574 --> 00:25:32,350
So nixflakes basically take state on our system and

423
00:25:32,422 --> 00:25:35,830
kind of put them into code in the sense that we have these things called

424
00:25:35,862 --> 00:25:39,926
nix channels which would refer to what version

425
00:25:39,950 --> 00:25:43,766
of nics packages were pointing to. And what

426
00:25:43,790 --> 00:25:46,518
we do is we just take that and make that kind of more explicit and

427
00:25:46,526 --> 00:25:50,334
we'll see exactly what that looks like. With this flake lock file,

428
00:25:50,454 --> 00:25:53,966
we lock our stuff to specific revisions, and that means other, because we can put

429
00:25:53,990 --> 00:25:57,470
that lock file in code, other developers can then point to the same inputs.

430
00:25:57,582 --> 00:26:00,782
We can also use other git repositories, non nix related,

431
00:26:00,878 --> 00:26:04,880
and manage them using our flake nix file if we want.

432
00:26:04,952 --> 00:26:08,864
They also define some basic structure, because now our flake Nix file becomes the entry

433
00:26:08,904 --> 00:26:11,832
point for our Nix configuration. So you know, that's kind of the first file you

434
00:26:11,848 --> 00:26:15,456
can go to to look for that Nix configuration. So as we said before,

435
00:26:15,520 --> 00:26:18,984
we have a bunch of inputs, a bunch of outputs, the main input being

436
00:26:19,024 --> 00:26:22,764
nix packages, or the default input we get when we

437
00:26:24,264 --> 00:26:28,552
initialize our flake. Then we

438
00:26:28,608 --> 00:26:31,688
also generate this flake lock file, which has this kind of

439
00:26:31,776 --> 00:26:35,198
concept. So this is the lock for the next packages input.

440
00:26:35,376 --> 00:26:38,894
We have this null hash, which is just a hash of the contents

441
00:26:40,754 --> 00:26:43,938
of that input. Less important because

442
00:26:43,986 --> 00:26:47,374
it's a git repository, but we could have non git related inputs.

443
00:26:47,954 --> 00:26:51,306
In this case, we also have a revision. So anyone using this flake

444
00:26:51,410 --> 00:26:54,954
Nixonflake lock file combination will be locked to this

445
00:26:54,994 --> 00:26:58,386
revision until we update that lock file. And that means if we're using this

446
00:26:58,410 --> 00:27:01,362
in CI or other developers using this will be point to the same version of

447
00:27:01,378 --> 00:27:05,226
Nix packages, which is really cool. We can also use like

448
00:27:05,250 --> 00:27:08,786
say a GitHub action or CI to update this flake lock file for

449
00:27:08,810 --> 00:27:13,194
us if we want to think a bit like dependable style

450
00:27:13,234 --> 00:27:17,706
stuff, if you want to do that. To kind of summarize nics, flakes improve reproducibility

451
00:27:17,770 --> 00:27:21,610
across our system by locking our dependencies. They provide a more standard

452
00:27:21,642 --> 00:27:24,906
way to configure our system. But do note they are an experimental feature,

453
00:27:24,970 --> 00:27:28,210
nics, and they could break in terms of

454
00:27:28,242 --> 00:27:31,134
like they could be breaking changes, so just keep that in mind.

455
00:27:31,594 --> 00:27:34,562
But I think they're great and I use them in all my projects and my

456
00:27:34,578 --> 00:27:38,146
own Nix configuration. So kind of one of the

457
00:27:38,170 --> 00:27:41,730
final topics we're going to touch on is CI. We've spoken about we want consistent

458
00:27:41,762 --> 00:27:45,290
environments between what's running locally and what's running in CI. How can we do

459
00:27:45,322 --> 00:27:48,938
that? And definitely we want to kind of leverage Nix's cacheability

460
00:27:49,106 --> 00:27:52,666
and sharing dependencies. GitHub Actions has

461
00:27:52,690 --> 00:27:56,770
some great stuff, especially from I think determinant systems for

462
00:27:56,802 --> 00:27:59,978
leveraging caches and various things to speed up your

463
00:28:00,146 --> 00:28:03,586
pipeline. I use GitLab CI and I found this great project by

464
00:28:03,610 --> 00:28:07,082
this user called Cynerd and it has this

465
00:28:07,178 --> 00:28:10,874
next job. And what it does by default is leverages the GitLab

466
00:28:10,914 --> 00:28:14,346
cache, but we could use a cache from an SSh machine as

467
00:28:14,370 --> 00:28:18,314
well, or ssh to a machine and

468
00:28:18,354 --> 00:28:21,490
copy from there. But essentially what it does is before and after the job,

469
00:28:21,522 --> 00:28:24,762
it will just copy from the cache to the next door of the

470
00:28:24,778 --> 00:28:28,466
job and then from the next door to the cache. So it shares dependencies

471
00:28:28,530 --> 00:28:32,240
between different stages and different jobs. So in our GitLab Ci file

472
00:28:32,322 --> 00:28:35,988
we include this GitLab Ci file, the GitLab project

473
00:28:36,036 --> 00:28:40,092
we just saw. Then I have a stage called pre

474
00:28:40,188 --> 00:28:43,860
that extends this nix job and we just do nix develop to install

475
00:28:43,892 --> 00:28:47,820
our dependencies. Then at future stage dependencies

476
00:28:47,852 --> 00:28:51,180
have been cached, they'll be copied over to this job and we can do nix

477
00:28:51,212 --> 00:28:54,940
develop C Go Lang ci lint run, whereas normally we'd be in that NaICs

478
00:28:54,972 --> 00:28:58,556
development environment and we could just do Golang Cilantro and we should be running

479
00:28:58,580 --> 00:29:01,972
the exact same versions because of the nature of Flake Nix

480
00:29:02,028 --> 00:29:05,204
and the various things we've talked about with Nix. So that's really cool.

481
00:29:05,364 --> 00:29:09,084
And this is kind of what it looks like, eleven and a half minutes total

482
00:29:09,164 --> 00:29:12,508
runtime. I think before I did this change it was 22 minutes,

483
00:29:12,676 --> 00:29:16,108
rather anecdotal, but something to note. Kind of just taking

484
00:29:16,156 --> 00:29:19,780
a look at Ci logs again, we can see it's copying from that

485
00:29:19,812 --> 00:29:22,744
cache, which is really nice as well.

486
00:29:23,404 --> 00:29:26,852
And this was definitely me with Nix when

487
00:29:26,868 --> 00:29:30,484
I first heard about it, I didn't really get it,

488
00:29:30,524 --> 00:29:33,692
and then eventually it clicked and I think it's really, really cool. And hopefully you

489
00:29:33,708 --> 00:29:36,796
guys either think that at the end of this talk, which means I've done an

490
00:29:36,820 --> 00:29:40,092
amazing job. Unlikely, but I'd recommend just giving it

491
00:29:40,108 --> 00:29:43,756
a go and seeing what you think. But before we close out this talk,

492
00:29:43,860 --> 00:29:47,636
I'm sure some of you have been thinking, or maybe even screaming at your

493
00:29:47,820 --> 00:29:51,220
computer, why not Docker? And I definitely was confused, like how does this

494
00:29:51,252 --> 00:29:54,556
relate to Docker? So remember, we're talking specifically

495
00:29:54,620 --> 00:29:58,024
for Docker in terms of like as a development environment.

496
00:29:58,564 --> 00:30:02,476
I think Docker is still great for building and packaging and

497
00:30:02,500 --> 00:30:06,378
deploying our stuff, especially on the cloud. And specifically what

498
00:30:06,386 --> 00:30:10,050
I'm talking about is Docker files to build docker images. And one of the problems

499
00:30:10,082 --> 00:30:13,914
Docker has, I think by being imperative, you'll often hear the term it's repeatable,

500
00:30:13,994 --> 00:30:17,266
not reproducible, often because of the package managers we're

501
00:30:17,290 --> 00:30:20,898
using. But imagine you have a Docker file. If two people try and build it

502
00:30:20,906 --> 00:30:23,938
like six months apart, you're probably going to get a different docker image and therefore

503
00:30:23,986 --> 00:30:27,170
it's not reproducible. One other problem I have with, say,

504
00:30:27,202 --> 00:30:30,378
Docker dev containers, which versus code plugin,

505
00:30:30,426 --> 00:30:33,650
which I think now works with jetbrains as well to try and

506
00:30:33,682 --> 00:30:37,138
make it easier to develop within a container, is what if I

507
00:30:37,146 --> 00:30:40,210
have specific tooling that I want, I now need to make that available, like say

508
00:30:40,242 --> 00:30:43,574
fzf z oxide. I have a specific shell,

509
00:30:43,874 --> 00:30:46,906
I have to make that available in the Docker image, and I'm potentially bloating that

510
00:30:46,930 --> 00:30:49,762
Docker image as well. I did find a way to personalize it. You can kind

511
00:30:49,778 --> 00:30:53,186
of run this startup script, but that was a bit slow and

512
00:30:53,210 --> 00:30:57,154
a bit more cumbersome than I found comparing it with nics dev

513
00:30:57,194 --> 00:31:01,254
containers. Sorry, Nick's dev shells. So just something to note there.

514
00:31:02,114 --> 00:31:05,402
Give both a go, see which one you prefer. But I think I found nics

515
00:31:05,458 --> 00:31:09,874
a lot easier. A few things you can look at in your own time to

516
00:31:09,914 --> 00:31:13,666
further use nics even more like nics. All the things

517
00:31:13,810 --> 00:31:17,002
here's a link to my slides. I'm going to have a bunch of other links,

518
00:31:17,098 --> 00:31:20,626
just go through them in your own time. Just a bunch

519
00:31:20,650 --> 00:31:24,626
of lots of literature and articles and YouTube

520
00:31:24,730 --> 00:31:28,682
videos. I want to give a shout out to Vimjoyer specifically.

521
00:31:28,778 --> 00:31:32,242
They do really great videos on YouTube. Highly recommend checking them out.

522
00:31:32,338 --> 00:31:36,090
And just a thanks to everyone who gave me feedback on this talk and improved

523
00:31:36,122 --> 00:31:39,904
a lot better than it was, I think version one. And thanks

524
00:31:39,944 --> 00:31:43,104
to comp 42 for giving me the chance to talk about

525
00:31:43,144 --> 00:31:46,712
this. I really like talking

526
00:31:46,728 --> 00:31:49,968
about Nix and want to share it with other people to see let them know

527
00:31:49,976 --> 00:31:52,712
what they can do. And thanks to you of course,

528
00:31:52,768 --> 00:31:56,200
for seeing through this talk and listening to me ramble on

529
00:31:56,232 --> 00:31:59,844
about NyX. Hopefully you found that useful and

530
00:32:01,344 --> 00:32:04,784
you'll give Nick's a try. Thank you very much. Have a lovely day

531
00:32:04,864 --> 00:32:06,024
and enjoy the rest of the conference.

