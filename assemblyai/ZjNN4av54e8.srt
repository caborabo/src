1
00:00:27,534 --> 00:00:31,550
Hey everyone, welcome to my session on stress testing Azure resources

2
00:00:31,662 --> 00:00:34,074
using Azure Chaos Studio.

3
00:00:34,614 --> 00:00:37,454
To share a bit about myself, I'm Peter Detender,

4
00:00:37,534 --> 00:00:40,966
originally from Belgium but moved to Redmond, Washington about two

5
00:00:41,030 --> 00:00:45,438
years ago. I'm a Microsoft technical trainer at Microsoft providing

6
00:00:45,566 --> 00:00:49,238
technical training. How hard can it be to come up with a job description

7
00:00:49,286 --> 00:00:52,422
right to our top customers and partners across the

8
00:00:52,438 --> 00:00:55,826
globe? In the bit of free time that I have, I still like

9
00:00:55,850 --> 00:00:59,442
to go back to Azure. But sharing knowledge presenting at virtual

10
00:00:59,498 --> 00:01:03,330
conferences like this one or in person on any

11
00:01:03,362 --> 00:01:06,898
topic that's Azure related Azure DevOps site reliability

12
00:01:06,986 --> 00:01:10,906
engineering or app modernization. I also like to

13
00:01:10,930 --> 00:01:15,762
write articles on my blog website zero zero seven ffflearning.com

14
00:01:15,938 --> 00:01:19,474
or publishing books where the latest one was a bit more than

15
00:01:19,514 --> 00:01:23,664
two years ago on the art of site reliability engineering.

16
00:01:24,044 --> 00:01:27,684
Feel free to reach out on Twitter, by email or

17
00:01:27,844 --> 00:01:31,964
LinkedIn. Now, with the personal marketing out of the way, let's jump

18
00:01:32,044 --> 00:01:35,860
straight into the technical piece of the session and starting with describing what

19
00:01:35,892 --> 00:01:39,692
site reliability engineering is about. Now in short

20
00:01:39,748 --> 00:01:43,780
side reliability engineering stands for site reliability

21
00:01:43,892 --> 00:01:48,264
engineer or engineering. And initially it's from Google,

22
00:01:48,764 --> 00:01:52,556
actually pointed to running main application,

23
00:01:52,660 --> 00:01:56,076
the www.google.com search website and

24
00:01:56,100 --> 00:01:59,452
it should have been available all the times. Now when the practice

25
00:01:59,508 --> 00:02:03,252
moved out of Google and became like public

26
00:02:03,388 --> 00:02:06,868
practice. Right. We refer to site as any possible

27
00:02:06,956 --> 00:02:10,740
workload that should run business critical and running

28
00:02:10,772 --> 00:02:14,976
24/7 now the other part is the reliability piece,

29
00:02:15,100 --> 00:02:18,552
where reliability means that you want to guarantee as

30
00:02:18,568 --> 00:02:21,760
a team that any running application you need to support is

31
00:02:21,792 --> 00:02:25,280
available no matter what's happening or maybe even better

32
00:02:25,352 --> 00:02:29,064
according business requirements. And the engineering piece is

33
00:02:29,144 --> 00:02:32,480
applying to the principles of computer science and using

34
00:02:32,552 --> 00:02:36,952
engineering concepts to build and maintain your systems applications

35
00:02:37,088 --> 00:02:40,480
all the way from developing into the monitoring. Now,

36
00:02:40,512 --> 00:02:44,000
drilling down a bit more on the specific, I think it would probably take me,

37
00:02:44,032 --> 00:02:48,320
I don't know, two or three days, maybe more. But you could simplified

38
00:02:48,392 --> 00:02:52,256
a little bit in these core responsibilities. First of

39
00:02:52,280 --> 00:02:55,856
all, when you're wearing your developer hat, it means that you're

40
00:02:55,920 --> 00:02:59,744
working on writing software for typically larger scaled

41
00:02:59,904 --> 00:03:03,584
workloads. Now, sometimes you also take the responsibility

42
00:03:03,704 --> 00:03:06,952
for side pieces of running your application

43
00:03:07,048 --> 00:03:10,752
like backup, monitoring, load balancing, and even if you

44
00:03:10,768 --> 00:03:13,912
like moving into the operations and then last,

45
00:03:14,008 --> 00:03:17,528
it could also mean figuring out how to apply existing

46
00:03:17,576 --> 00:03:20,656
solutions to new problems. Good.

47
00:03:20,760 --> 00:03:24,480
Now with that, I need to move a little bit more away from site reliability

48
00:03:24,552 --> 00:03:27,004
engineering into chaos engineering.

49
00:03:27,544 --> 00:03:31,096
Now, what is chaos engineering? More specifically, I could summarize

50
00:03:31,120 --> 00:03:34,792
it as the discipline of experimenting on a system in order

51
00:03:34,848 --> 00:03:38,728
to build confidence in the systems capability and withstanding

52
00:03:38,776 --> 00:03:42,114
turbulent conditions in production. Now this is the official

53
00:03:42,194 --> 00:03:45,386
definition coming from the principles of chaos, which if

54
00:03:45,410 --> 00:03:48,882
you ask me could be the name of a rock band. Now there's

55
00:03:48,938 --> 00:03:51,770
three core key words I want to emphasize.

56
00:03:51,922 --> 00:03:55,258
First of all, it's experimenting, which means if you know a

57
00:03:55,266 --> 00:03:58,134
bit about DevOps, it also means failing fast,

58
00:03:58,674 --> 00:04:02,842
because the faster you fail, the faster you're forced to recover. You're going

59
00:04:02,898 --> 00:04:06,346
to learn how to make your systems more

60
00:04:06,370 --> 00:04:10,414
reliable, more resilient. So I call experimenting

61
00:04:10,534 --> 00:04:13,662
like licking a fuse as a kid, right where your hair would

62
00:04:13,678 --> 00:04:16,742
spike, or maybe even again as

63
00:04:16,758 --> 00:04:20,238
a kid, don't ask me how I know, but going downhill with your bike,

64
00:04:20,286 --> 00:04:23,566
you're not super experienced in it yet, and you go like

65
00:04:23,630 --> 00:04:27,022
super downhill, super fast, and maybe you're falling

66
00:04:27,078 --> 00:04:29,846
and you break your arm and then you go, oh my God, this was so

67
00:04:29,870 --> 00:04:33,270
cool, I'm gonna do this again. Now, the more loopholes we can

68
00:04:33,302 --> 00:04:36,710
identify up front, the more confidence, which is the next part

69
00:04:36,742 --> 00:04:40,154
in the definition we can have in the systems reliability.

70
00:04:40,614 --> 00:04:44,374
By introducing a series of event simulations based on

71
00:04:44,414 --> 00:04:48,094
real incidents or based on imaginary outages that could

72
00:04:48,134 --> 00:04:51,834
happen, you can target your workloads and learn from the impact.

73
00:04:52,374 --> 00:04:56,158
And then the last piece is overall withstanding any

74
00:04:56,206 --> 00:04:59,518
possible turbulent conditions. Think of it as cpu

75
00:04:59,566 --> 00:05:03,110
pressure or unplanned load, or maybe an unplanned

76
00:05:03,142 --> 00:05:06,490
outage that could qualify as chaos engineering

77
00:05:06,562 --> 00:05:09,810
issues. Now one example I would like to use here

78
00:05:09,842 --> 00:05:13,690
to start is what I call the curious case of cpu pressure.

79
00:05:13,802 --> 00:05:17,210
Now what does it mean? Imagine you have a workload,

80
00:05:17,322 --> 00:05:20,594
could be anything, could run in cloud, could run on Prem, could be hybrid,

81
00:05:20,674 --> 00:05:24,210
it's been running fine for months. And the average cpu load,

82
00:05:24,362 --> 00:05:27,562
now why do you know that? Because if it's running in Azure, you're going to

83
00:05:27,578 --> 00:05:31,010
use Azure monitoring. If it's running on Prem, you're going to use on prem monitoring

84
00:05:31,042 --> 00:05:34,388
tools. And in the end it's not too important as long as you integrate

85
00:05:34,436 --> 00:05:38,556
monitoring. But then suddenly there is a spike and

86
00:05:38,580 --> 00:05:42,900
eventually when you hammer your system, it probably goes

87
00:05:42,932 --> 00:05:46,804
down or it crashes. Right now it's stopping the application, the database

88
00:05:46,844 --> 00:05:50,584
goes down, the web app is not longer available, and so on.

89
00:05:50,884 --> 00:05:54,264
Now apart from troubleshooting the data piece, you also

90
00:05:54,964 --> 00:05:58,084
going hand in hand with testing your engineering

91
00:05:58,124 --> 00:06:01,792
team. Like how can we rebuild the system, how can we get

92
00:06:01,808 --> 00:06:05,648
it up and running again as fast as possible? Now it might also

93
00:06:05,776 --> 00:06:09,016
be that you don't even know the reason why,

94
00:06:09,120 --> 00:06:12,840
and that's why you want to use chaos engineering because

95
00:06:12,872 --> 00:06:16,784
what you're going to do is integrating functional testing to make sure

96
00:06:16,824 --> 00:06:20,176
that any possible outage, planned or unplanned, is not

97
00:06:20,200 --> 00:06:24,064
going to happen anymore. Or at least I would say trying to minimize

98
00:06:24,104 --> 00:06:27,588
the risk. That's the main thing. You can see here that

99
00:06:27,636 --> 00:06:31,324
I'm using a couple of examples like a virtual machine, a Kubernetes cluster

100
00:06:31,404 --> 00:06:35,116
key, vault network security groups. Why? Because all these are

101
00:06:35,220 --> 00:06:39,624
supported in my Azure Chaos studio service that I'll talk about later.

102
00:06:40,204 --> 00:06:43,492
The last part I included here is the DevOps engineer.

103
00:06:43,588 --> 00:06:47,276
Why? Because human beings are still important, right? There's still

104
00:06:47,300 --> 00:06:50,988
a huge amount of issues, unfortunately, when running environments because

105
00:06:51,036 --> 00:06:54,588
of human interaction. And don't forget we're mainly talking about

106
00:06:54,636 --> 00:06:57,772
production environments here. Now you might go, wait a minute, Peter,

107
00:06:57,908 --> 00:07:01,212
why are you not that happy with human beings? Or do you

108
00:07:01,228 --> 00:07:04,836
don't like, like DevOps engineers? Now I provide training

109
00:07:04,940 --> 00:07:09,020
and DevOps is one of my main technologies I'm providing training on.

110
00:07:09,172 --> 00:07:12,420
Now why is it so important to integrate

111
00:07:12,452 --> 00:07:16,100
this DevOps engineer as the curious case of cpu pressure?

112
00:07:16,252 --> 00:07:19,732
Because we all know what happens. We publish applications maybe on a

113
00:07:19,748 --> 00:07:23,340
Friday afternoon. Why? Because we have the whole weekend to recover in case

114
00:07:23,372 --> 00:07:27,108
of something going down. But then again going back to production

115
00:07:27,156 --> 00:07:30,676
environments. It also means that we need to make sure that everything keeps

116
00:07:30,700 --> 00:07:34,108
up and running. And if it's not because of the platform, if it's not because

117
00:07:34,156 --> 00:07:37,508
of the load of the platform, in some cases, unfortunately,

118
00:07:37,596 --> 00:07:41,492
it's still the human being. Now we still are in the curious

119
00:07:41,548 --> 00:07:45,132
case of cpu pressure. Now what's important here is

120
00:07:45,148 --> 00:07:49,076
that we're actually trying to step away from one individual

121
00:07:49,140 --> 00:07:53,224
component. Why is that? Because if you think about the virtual

122
00:07:53,264 --> 00:07:56,656
machines, Kubernetes, clusters, then yes, we look at

123
00:07:56,720 --> 00:08:00,056
CPU, but typically reusing CPU as the

124
00:08:00,080 --> 00:08:03,432
example. It's not the main root cause. Why not? Because there's a

125
00:08:03,448 --> 00:08:07,384
lot more going on in keeping your systems up and running besides monitoring

126
00:08:07,424 --> 00:08:11,364
cpu load. So it might be that cpu is biting

127
00:08:11,744 --> 00:08:15,512
because of latency in your database operations running, I don't

128
00:08:15,528 --> 00:08:19,496
know, some complex, oh sorry, running some complex calculation

129
00:08:19,640 --> 00:08:23,316
or running a database update. Or it might be that there are

130
00:08:23,340 --> 00:08:27,004
network connectivity issue by which now the operation cannot write

131
00:08:27,044 --> 00:08:30,436
to the database. And because the fact that it cannot write to the database,

132
00:08:30,540 --> 00:08:34,028
that's actually causing cpu pressure. So my

133
00:08:34,076 --> 00:08:38,236
analogy here is explaining that systems are complex

134
00:08:38,380 --> 00:08:41,420
virtual machine scale sets. Yes it's running a virtual machine,

135
00:08:41,492 --> 00:08:44,996
but it's running a few more than just a single one or a

136
00:08:45,020 --> 00:08:47,878
more complex architecture like kubernetes.

137
00:08:48,076 --> 00:08:51,610
Overall validating your IaaS, PaaS and serverless workloads

138
00:08:51,642 --> 00:08:56,370
like Azure functions, or maybe even the latest one service bus as

139
00:08:56,402 --> 00:08:59,642
part of your architecture Cosmos database. And again, so many other

140
00:08:59,698 --> 00:09:03,034
examples. And then to add even more complexity on this,

141
00:09:03,114 --> 00:09:06,514
it's like all of those in one single scenario

142
00:09:06,634 --> 00:09:09,506
where you're running virtual machines for part of the workload.

143
00:09:09,570 --> 00:09:13,210
Next to that, you're running short running container tasks

144
00:09:13,282 --> 00:09:16,464
inside kubernetes clusters, maybe kubernetes clusters

145
00:09:16,544 --> 00:09:19,912
across a hybrid scenario, partly Azure AWS,

146
00:09:20,048 --> 00:09:23,600
Google Cloud, and why not Umpra? And again, bringing all

147
00:09:23,632 --> 00:09:27,000
that together and then still having the human being as a

148
00:09:27,032 --> 00:09:30,672
potential weak spot. Imagine you need to manage

149
00:09:30,768 --> 00:09:34,504
your DevOps teams and they're active all over the globe, different time zones,

150
00:09:34,624 --> 00:09:38,200
managing the permissions and so on. Now you might think that

151
00:09:38,232 --> 00:09:41,900
chaos engineering is the next big thing, and maybe

152
00:09:41,932 --> 00:09:45,516
it's even following side reliability engineering, which you could

153
00:09:45,540 --> 00:09:49,468
say was following DevOps, but yet it's maybe too revolutionary

154
00:09:49,556 --> 00:09:53,284
for your cloud environments. I think nothing is more wrong.

155
00:09:53,444 --> 00:09:57,204
In fact, chaos engineering has been around for more than ten years now.

156
00:09:57,284 --> 00:10:02,108
Initially developed by software engineers from Netflix already 2008

157
00:10:02,276 --> 00:10:05,892
when they started migrating from on prem data centers into public

158
00:10:05,948 --> 00:10:09,224
cloud data centers. While there are a lot of similarities

159
00:10:09,304 --> 00:10:12,888
across managing your own data center or using public cloud,

160
00:10:13,016 --> 00:10:16,384
theres also quite some big differences. And it was mainly those

161
00:10:16,424 --> 00:10:19,744
differences that forced Netflix engineers to create service

162
00:10:19,864 --> 00:10:23,084
architectures using higher reliability.

163
00:10:23,704 --> 00:10:27,128
Now to be clear, I think that Chaos engineering is

164
00:10:27,176 --> 00:10:30,536
not DevOps 3.0, but I definitely should be part of

165
00:10:30,600 --> 00:10:34,322
DevOps teamed Arsenal of tools to meet your business requirements

166
00:10:34,448 --> 00:10:38,222
to validate how your applications are running. So with

167
00:10:38,238 --> 00:10:41,926
that, I would say let's make it a little bit more technology focused

168
00:10:41,990 --> 00:10:45,314
on one specific service called Azure Chaos Studio.

169
00:10:45,814 --> 00:10:49,102
Now Azure Chaos Studio is, as you can probably figure out,

170
00:10:49,158 --> 00:10:52,406
an Azure service offering chaos engineering as a

171
00:10:52,430 --> 00:10:55,742
service, which means that you can inject faults into

172
00:10:55,798 --> 00:10:59,366
your Azure workloads. Now, thinking back about the definition,

173
00:10:59,470 --> 00:11:02,814
preferably you're going to use chaos engineering against your

174
00:11:02,854 --> 00:11:06,728
production environment. But honestly, trust me, you can do this against test

175
00:11:06,776 --> 00:11:10,544
and development environment as well. Now, whether you're testing

176
00:11:10,584 --> 00:11:14,456
how applications will run in Azure, or you're migrating applications to

177
00:11:14,480 --> 00:11:18,364
Azure, or maybe you're already running production workloads in Azure,

178
00:11:18,664 --> 00:11:22,216
Chaos studio allows you to bring in a full set of

179
00:11:22,240 --> 00:11:25,728
faults into your scenario, ranging from virtual

180
00:11:25,776 --> 00:11:29,568
machines which we call agent based chaos testing,

181
00:11:29,696 --> 00:11:33,038
or serverless if you have Kubernetes

182
00:11:33,086 --> 00:11:36,638
clusters targeting Azure, key vault targeting network security

183
00:11:36,726 --> 00:11:40,094
groups, and one of the latest services we actually added

184
00:11:40,214 --> 00:11:43,870
is service bus. Now the core of Chaos studio

185
00:11:43,982 --> 00:11:47,350
is Chaos experiments. So a chaos experiment

186
00:11:47,422 --> 00:11:50,942
is an Azure resource that describes the faults that should be run

187
00:11:51,078 --> 00:11:54,114
and the resources those faults should be run against.

188
00:11:54,694 --> 00:11:58,046
Now faults can be organized to run in parallel or in

189
00:11:58,070 --> 00:12:01,900
sequence, and I'll show you in an upcoming demo depending on the needs.

190
00:12:02,052 --> 00:12:05,660
Now, chaos supports two types of faults. I already talked

191
00:12:05,692 --> 00:12:08,932
about service direct, which means you're

192
00:12:08,948 --> 00:12:12,428
gonna a service which doesn't require

193
00:12:12,476 --> 00:12:15,876
an agent. Next to that you got agent based faults and

194
00:12:15,900 --> 00:12:19,756
that means you're gonna target a virtual machine workload which could be

195
00:12:19,820 --> 00:12:23,304
windows, Linux and Kubernetes clusters as well.

196
00:12:23,604 --> 00:12:27,230
Now the core is a chaos experiment. Now when you build

197
00:12:27,262 --> 00:12:30,590
a chaos experiment, what you're doing is defining one

198
00:12:30,622 --> 00:12:34,606
or more steps that execute sequentially, each step

199
00:12:34,710 --> 00:12:38,190
containing one or more branches, as we call it, that run

200
00:12:38,222 --> 00:12:41,462
in parallel within the step, and each branch

201
00:12:41,518 --> 00:12:45,374
containing one or more actions, such as injecting a fault,

202
00:12:45,454 --> 00:12:49,214
waiting for a certain duration, or anything else you could come up with.

203
00:12:49,374 --> 00:12:53,510
Now finally you organize the resources which we call targets

204
00:12:53,622 --> 00:12:57,134
that each fault will be run against. You can move them into

205
00:12:57,174 --> 00:13:00,502
a group scenario called a selector, and that's where

206
00:13:00,558 --> 00:13:03,714
you can easily reference a group of resources.

207
00:13:04,334 --> 00:13:08,406
So in short you would start with experimenting. You're going to create an

208
00:13:08,430 --> 00:13:11,958
experiment. You define the step by step process.

209
00:13:12,126 --> 00:13:15,262
For example hammering cpu load. Next to that I'm going to

210
00:13:15,278 --> 00:13:18,734
simulate latency. Next to that I'm going to fire off a crash

211
00:13:18,774 --> 00:13:22,774
of a web server or maybe running some heavy loaded database

212
00:13:22,814 --> 00:13:26,406
task or anything. Again that's running inside a virtual machine

213
00:13:26,550 --> 00:13:29,806
or inside a Kubernetes cluster or targeting

214
00:13:29,990 --> 00:13:33,590
network security group, or simulating an outage, or not having

215
00:13:33,622 --> 00:13:37,270
the correct permissions to connect to key vault and app services

216
00:13:37,382 --> 00:13:40,194
and functions and so many other examples.

217
00:13:40,854 --> 00:13:44,510
And then in the next step you're going to define the actual actions.

218
00:13:44,662 --> 00:13:47,654
So reflecting on this is what I want you to do.

219
00:13:47,814 --> 00:13:51,606
I want you to simulate an action called cpu pressure. Now think back

220
00:13:51,630 --> 00:13:55,398
about one of the examples I shared before. Within the cpu pressure

221
00:13:55,486 --> 00:13:59,342
I want to run a 99% cpu load, maybe 20,

222
00:13:59,398 --> 00:14:02,894
maybe 50, whatever number that could work and is relevant for your

223
00:14:02,934 --> 00:14:06,590
outage testing. And then what you want to run is the x

224
00:14:06,622 --> 00:14:10,054
amount of time. I want to run this for five minutes, ten minutes,

225
00:14:10,174 --> 00:14:12,954
and I want you to repeat it for the next hour,

226
00:14:13,494 --> 00:14:17,114
although that would be an actually pretty long test. Now most

227
00:14:17,154 --> 00:14:20,866
probably you don't need the full 3 hours or 1 hour or maybe even

228
00:14:20,890 --> 00:14:24,906
a couple of minutes to validate and figure out if your virtual machine can handle

229
00:14:24,930 --> 00:14:28,694
the load or any of the other services. I already mentioned.

230
00:14:29,154 --> 00:14:32,314
Now those two previous slides is technically

231
00:14:32,394 --> 00:14:35,974
all you really need to know about managing Azure Chaos studio.

232
00:14:36,554 --> 00:14:39,962
You deploy resources, you create experiments and you're going to run

233
00:14:39,978 --> 00:14:44,056
them. So with that, let's have a look at a couple of demo scenarios

234
00:14:44,170 --> 00:14:46,904
and what it actually looks like in a real life scenario.

235
00:14:47,404 --> 00:14:51,332
So this is my Azure environment where I already enabled

236
00:14:51,388 --> 00:14:54,636
Chaos studio. And again, if you don't really know how to do

237
00:14:54,660 --> 00:14:58,660
that, you go into your subscriptions and

238
00:14:58,692 --> 00:15:02,904
within your subscriptions you're going to search for resource providers.

239
00:15:03,244 --> 00:15:07,164
So go a little bit down here into the resource

240
00:15:07,204 --> 00:15:10,340
provider section and that's where you literally

241
00:15:10,412 --> 00:15:14,086
enable the Azure fabric features of

242
00:15:14,110 --> 00:15:17,354
the platform where you're going to search for chaos.

243
00:15:18,014 --> 00:15:22,366
And in my case obviously because otherwise I could not really demo anything.

244
00:15:22,550 --> 00:15:25,674
You're going to click that register option here on top,

245
00:15:26,294 --> 00:15:29,894
giving it a couple of seconds, worst case a few minutes.

246
00:15:29,974 --> 00:15:33,254
And from there, once it's a green registered option, it means

247
00:15:33,294 --> 00:15:36,862
you can start using your chaos environment or

248
00:15:36,878 --> 00:15:40,354
the Chaos studio service, I should say. So let's jump

249
00:15:40,394 --> 00:15:43,866
back to Chaos Studio and the first thing we're going to do

250
00:15:43,890 --> 00:15:47,346
is defining a target. Now a target is again

251
00:15:47,410 --> 00:15:51,002
anything that's already running in your environment quite important.

252
00:15:51,098 --> 00:15:54,450
It needs to be up and running. The reason why is because you

253
00:15:54,482 --> 00:15:57,534
need to define how you're going to manage your target.

254
00:15:58,274 --> 00:16:01,410
As you can see here, I got two scenarios

255
00:16:01,482 --> 00:16:05,338
already enabled. I have my Ubuntu Linux virtual

256
00:16:05,386 --> 00:16:09,234
machine where I can manage actions. And the second scenario

257
00:16:09,274 --> 00:16:12,890
I got is my AKS cluster. Now you can see

258
00:16:12,922 --> 00:16:16,386
that there are a lot of other scenarios available. I can literally

259
00:16:16,450 --> 00:16:20,458
target my virtual machine scale set over

260
00:16:20,506 --> 00:16:24,122
here. I can test against an NSG. I don't have an example

261
00:16:24,178 --> 00:16:28,186
for app services, although technically you can actually stop the app service

262
00:16:28,250 --> 00:16:31,438
itself. The virtual machine is pretty obvious,

263
00:16:31,586 --> 00:16:35,310
but also validating interactions against like a key vault

264
00:16:35,342 --> 00:16:38,966
in this case. So it's not just about virtual machines, it's not

265
00:16:38,990 --> 00:16:43,154
just about kubernetes, but it's expanding the target environment.

266
00:16:43,614 --> 00:16:46,510
How do we install that agent?

267
00:16:46,542 --> 00:16:50,358
Right, that would be the next step where again you got service direct and

268
00:16:50,406 --> 00:16:53,782
you have agent based. So for a virtual machine you probably

269
00:16:53,838 --> 00:16:57,678
gonna go for agent based. So it's nothing harder than selecting

270
00:16:57,766 --> 00:17:00,928
your target. Virtual machine going up here,

271
00:17:01,016 --> 00:17:04,768
enable target. And since again it's a vm, we gonna

272
00:17:04,816 --> 00:17:08,136
install that package. The next step what you

273
00:17:08,160 --> 00:17:11,472
need is a managed identity. Now what is a managed identity?

274
00:17:11,528 --> 00:17:15,056
Right. Cael Studio, for the first time you need

275
00:17:15,080 --> 00:17:18,576
to create that managed identity. If you don't really know the details

276
00:17:18,680 --> 00:17:22,480
a managed identity is an Azure ad service principle,

277
00:17:22,552 --> 00:17:26,403
like a security object interaction from one Azure

278
00:17:26,443 --> 00:17:30,427
service, Azure Chaos studio, in this case to interact

279
00:17:30,475 --> 00:17:33,667
with other parts of the platform, virtual machines, nsgs,

280
00:17:33,715 --> 00:17:37,283
kubernetes, clusters, app services, redis, cache,

281
00:17:37,403 --> 00:17:40,147
Cosmos, DB, and so many other services.

282
00:17:40,315 --> 00:17:44,243
So that would be step one. I already created my managed

283
00:17:44,283 --> 00:17:48,075
identity, very important. It's a managed identity for the Chaos

284
00:17:48,219 --> 00:17:52,288
studio service. It's not a managed identity for the virtual

285
00:17:52,336 --> 00:17:56,360
machine that you're going to use as a target. Second dependency

286
00:17:56,432 --> 00:18:00,032
component is application insights. So again, you already

287
00:18:00,088 --> 00:18:03,800
know we need application insights for our observability,

288
00:18:03,912 --> 00:18:07,520
like providing the metrics sharing you the output where

289
00:18:07,552 --> 00:18:11,296
you need to dive in your Azure portal or again using some automation

290
00:18:11,360 --> 00:18:15,448
engine, terraform, Powershell, Azure Cli doesn't really

291
00:18:15,496 --> 00:18:19,244
matter and you're going to deploy our application inside service.

292
00:18:19,664 --> 00:18:23,444
From there you just need to define which one you want to use.

293
00:18:24,064 --> 00:18:27,560
As you can see, I got quite a lot of them because I'm taking monitoring

294
00:18:27,592 --> 00:18:30,680
quite serious and we're going to enable it as well.

295
00:18:30,832 --> 00:18:34,448
And that's all it takes. Where from here it's going to install

296
00:18:34,496 --> 00:18:37,600
that agent. Now to speed up my demo a little bit.

297
00:18:37,712 --> 00:18:41,520
I already have this for my Ubuntu via and

298
00:18:41,552 --> 00:18:45,284
you can validate your deployment. You don't really

299
00:18:45,324 --> 00:18:49,364
have to wait in the portal to just validate what's going on, but it's

300
00:18:49,404 --> 00:18:52,820
nothing more than any traditional extension. So maybe you're already

301
00:18:52,892 --> 00:18:56,924
familiar with using chef puppet, some anti malware scenario

302
00:18:56,964 --> 00:19:00,428
like Microsoft Defender, and installing it as an

303
00:19:00,516 --> 00:19:04,212
extension, like adding a little piece of software like an agent

304
00:19:04,348 --> 00:19:07,972
inside your virtual machine where my portal

305
00:19:08,028 --> 00:19:11,894
seems to not to be refreshing. Let's try that again.

306
00:19:12,594 --> 00:19:16,354
So I got my chaos engineering and provisioning succeeded again,

307
00:19:16,394 --> 00:19:19,626
this takes just a couple of minutes, but I didn't really want to wait

308
00:19:19,690 --> 00:19:22,658
to show you how it works on the web VM itself.

309
00:19:22,826 --> 00:19:26,546
Keep in mind if it's a Linux backend, you need to install that chaos

310
00:19:26,610 --> 00:19:29,834
ng package inside your cluster as well. And again,

311
00:19:29,874 --> 00:19:33,730
you could probably find out how to do that using the traditional

312
00:19:33,762 --> 00:19:37,060
virtual machine approach for for your Linux like apt

313
00:19:37,092 --> 00:19:40,852
get depending a bit on the Linux flavor you're using would be

314
00:19:40,868 --> 00:19:43,956
a good option. So what we have right now is

315
00:19:44,020 --> 00:19:47,700
our target. We have the virtual machines defined and if you

316
00:19:47,732 --> 00:19:51,564
want we could also go back where the deployment is still running

317
00:19:51,604 --> 00:19:55,052
totally fine. Taking a little step back to my chaos

318
00:19:55,108 --> 00:19:58,824
studio where now I could target the

319
00:19:59,164 --> 00:20:02,824
similar concept but using a different service.

320
00:20:03,584 --> 00:20:08,136
So I'm going to give it a couple of seconds before it's pulling up the

321
00:20:08,240 --> 00:20:11,832
capable or compatible resources and

322
00:20:11,888 --> 00:20:15,256
maybe using my Cosmos database,

323
00:20:15,440 --> 00:20:19,120
where this time I'm going to enable it for a direct service model,

324
00:20:19,152 --> 00:20:22,392
which means I don't need to deploy an agent. That's really how easy

325
00:20:22,408 --> 00:20:25,800
it is. It's going to flip back, but we're not going to wait

326
00:20:25,832 --> 00:20:28,284
for it. You probably get the idea how to do that,

327
00:20:28,844 --> 00:20:32,944
where the next step is defining an experiment.

328
00:20:33,364 --> 00:20:36,476
I already have a few experiments up and running that I'm going to

329
00:20:36,500 --> 00:20:40,244
reuse just to again, keep it a little bit entertaining, not wasting time

330
00:20:40,284 --> 00:20:43,996
on a lot of stuff happening in the backend. Nothing blocks

331
00:20:44,020 --> 00:20:47,584
me from showing you how to create a new experiment.

332
00:20:48,044 --> 00:20:52,028
So once you have this, it's opening up an experiments configuration.

333
00:20:52,116 --> 00:20:55,544
So, interesting enough, an experiment by itself is nothing

334
00:20:55,584 --> 00:20:59,264
more than a standalone azure resource. It also means that you can

335
00:20:59,344 --> 00:21:02,520
automate the deployment using arm templates, bicep to just

336
00:21:02,552 --> 00:21:06,884
give you an example. And we're going to call this the lord chaos.

337
00:21:07,584 --> 00:21:11,280
My targets are running in central us, but in the end it's not

338
00:21:11,312 --> 00:21:15,304
really that important. But I typically like deploying my

339
00:21:15,424 --> 00:21:19,496
experiments in the same region where I'm going to run my testing or

340
00:21:19,600 --> 00:21:23,534
gonna run my engineering experiment itself from

341
00:21:23,574 --> 00:21:26,822
here. As I outlined in the presentation, the highest level is

342
00:21:26,838 --> 00:21:31,054
a step within the step you got a branch and out of the branch

343
00:21:31,094 --> 00:21:34,910
you're going to define a fault where a fault can be multiple actions.

344
00:21:35,022 --> 00:21:38,430
You can totally customize the step one branch name and adding

345
00:21:38,502 --> 00:21:42,182
multiple branches. I'm going to keep it a little bit easy for now because I

346
00:21:42,198 --> 00:21:45,686
don't want to run overtime and just focusing on creating a

347
00:21:45,710 --> 00:21:49,234
new folder where a fault is, I would say

348
00:21:49,354 --> 00:21:53,498
based on a library of fault injections where

349
00:21:53,546 --> 00:21:57,386
a lot of them are already available and if needed you

350
00:21:57,410 --> 00:22:01,394
can insert some custom ones out of a fault library that I'll show

351
00:22:01,434 --> 00:22:05,194
you in a minute. Now, since we have different target

352
00:22:05,274 --> 00:22:08,738
endpoints, it means that we can go for different fault

353
00:22:08,826 --> 00:22:12,746
scenarios. A couple of obvious ones, like validating

354
00:22:12,850 --> 00:22:16,388
the shutdown of a virtual machine or shutting down the full scale set

355
00:22:16,436 --> 00:22:20,944
and finding out what's the impact for my application workload,

356
00:22:21,644 --> 00:22:24,884
specifically targeting Cosmos DB, where again I didn't need to deploy

357
00:22:24,924 --> 00:22:28,412
an agent. It's that direct service direct model. And I

358
00:22:28,428 --> 00:22:31,644
can start hammering my Cosmos DB, running a failover from

359
00:22:31,684 --> 00:22:35,500
one region to another, shutting down, moving down to the rus that

360
00:22:35,532 --> 00:22:38,860
the request units and causing some kind of latency

361
00:22:38,892 --> 00:22:42,116
and again, testing how my web front end is responding

362
00:22:42,140 --> 00:22:45,130
to that. Right, a nice list of aks,

363
00:22:45,282 --> 00:22:49,066
specific scenarios where again all of them are based

364
00:22:49,090 --> 00:22:52,882
on that open source chaos mesh scenario and

365
00:22:52,898 --> 00:22:56,506
then from there a whole collection of standalone ones.

366
00:22:56,570 --> 00:22:59,730
Let me change the color to just highlight that it's slightly different,

367
00:22:59,922 --> 00:23:03,658
interacting with key vaults like not giving you access to find your

368
00:23:03,706 --> 00:23:07,818
secrets certificates anymore. Cpu pressure,

369
00:23:07,986 --> 00:23:10,514
physical memory testing, virtual memory,

370
00:23:10,674 --> 00:23:14,314
cpu load stopping a service killing a process,

371
00:23:14,474 --> 00:23:17,454
and so many other scenarios available.

372
00:23:17,994 --> 00:23:21,174
So let's check out what that fault library is about.

373
00:23:21,674 --> 00:23:25,282
So in the official Microsoft Docs there's a pretty long

374
00:23:25,338 --> 00:23:28,730
list of potential faults and specific actions

375
00:23:28,762 --> 00:23:32,610
that you can use. Now the way it works for like the easier tasks

376
00:23:32,642 --> 00:23:36,490
or the easier fault validations that I talked about, you can just select

377
00:23:36,522 --> 00:23:39,796
it and you don't really have to do anything. But you might also end up

378
00:23:39,820 --> 00:23:43,268
in a more complex scenario like for example cpu

379
00:23:43,316 --> 00:23:47,164
pressure. Quite easy to understand what it's going to do and it doesn't

380
00:23:47,204 --> 00:23:51,412
really require a lot of settings. Now what you need is a JSon file.

381
00:23:51,548 --> 00:23:55,412
You could have like an open source library. Again like chaos mesh giving

382
00:23:55,468 --> 00:23:59,692
you YAML syntax for kubernetes environments.

383
00:23:59,828 --> 00:24:04,020
We're now out of that AKS specific chaos engineering testing

384
00:24:04,052 --> 00:24:07,962
that we offer out of Chaos studio in Azure. You need to translate

385
00:24:08,018 --> 00:24:12,186
the YAML files into JSON and that's also documented in this

386
00:24:12,250 --> 00:24:16,026
article. Don't worry too much about where to find that fold library.

387
00:24:16,170 --> 00:24:20,002
You have that link in the Chaos studio portal and I also have it in

388
00:24:20,018 --> 00:24:23,730
my slides all the way at the end. Good. So let's

389
00:24:23,762 --> 00:24:27,690
go back to our scenario and we're going to simulate like a

390
00:24:27,722 --> 00:24:31,378
cpu pressure. Now I can define some of my settings,

391
00:24:31,426 --> 00:24:35,238
right? I'm going to run this for let's say ten minutes and I'm going

392
00:24:35,246 --> 00:24:38,758
to hammer my server with 99% cpu.

393
00:24:38,846 --> 00:24:43,118
Don't ask me why it's not possible to select 100%,

394
00:24:43,246 --> 00:24:47,190
but you probably get the idea because once it reaches 100% cpu,

395
00:24:47,302 --> 00:24:51,350
it's typically crashing the server. Next we're going to define the target

396
00:24:51,462 --> 00:24:55,206
resource, where I'm going to hammer my Ubuntu and

397
00:24:55,230 --> 00:24:58,440
the web VM. So the nice thing here is that you can run the same

398
00:24:58,472 --> 00:25:02,304
performance testing against multiple endpoints. Could be the same server

399
00:25:02,344 --> 00:25:05,872
workload, could be different ones. Like my web VM is running my web

400
00:25:05,928 --> 00:25:09,688
engine, my Ubuntu VM is running a Mysql

401
00:25:09,736 --> 00:25:13,528
postgres database, and I'm going to test the behavior when I'm hammering

402
00:25:13,576 --> 00:25:17,032
my server with a cpu load. And that's literally all

403
00:25:17,048 --> 00:25:20,768
it takes. If you want you can add a delay like

404
00:25:20,816 --> 00:25:24,296
testing something for a few minutes. After that waiting couple

405
00:25:24,320 --> 00:25:27,402
of minutes, testing it again, waiting a few minutes, testing it again.

406
00:25:27,528 --> 00:25:31,254
So that's another maybe more complex scenario. And then

407
00:25:31,294 --> 00:25:34,838
adding an additional step is nothing more than doing the same

408
00:25:34,886 --> 00:25:39,078
thing where again it's going to run through that step by step scenario,

409
00:25:39,166 --> 00:25:43,070
running through that sequence where let's say for now we

410
00:25:43,102 --> 00:25:46,286
gonna kill a process and

411
00:25:46,310 --> 00:25:49,734
the process name is called CMD Exe. Not the most fancy

412
00:25:49,774 --> 00:25:53,150
one, but again this could be like any super important business

413
00:25:53,222 --> 00:25:56,710
critical workload where you just gonna stop and kill that

414
00:25:56,742 --> 00:25:59,902
process. That's the idea. Where next

415
00:25:59,958 --> 00:26:03,166
while my cpu load is hammering, I'm gonna

416
00:26:03,270 --> 00:26:06,782
trigger some other process stop. And again

417
00:26:06,838 --> 00:26:10,606
from here you can add multiple steps, making it more complex,

418
00:26:10,750 --> 00:26:14,526
integrating the time waiting scenario, you probably get

419
00:26:14,550 --> 00:26:18,822
that idea. From here you review, create. That's basically it.

420
00:26:18,958 --> 00:26:22,540
Now again, I already ran this process and

421
00:26:22,612 --> 00:26:26,132
what I have is cpu experiments. And then later on

422
00:26:26,188 --> 00:26:29,544
I got something for my aks cluster as well.

423
00:26:30,004 --> 00:26:33,636
Now from here we have chaos studio. We enabled the service in the

424
00:26:33,660 --> 00:26:37,180
platform. Next we define target direct service

425
00:26:37,292 --> 00:26:40,932
or using that agent based deployment. Step number three,

426
00:26:41,028 --> 00:26:44,876
we defined experiments as easy or as complex as you wanted,

427
00:26:44,980 --> 00:26:49,814
targeting a single step with a single fault to a single vm target

428
00:26:49,894 --> 00:26:53,742
object, or making it more complex. More, yeah, more complex.

429
00:26:53,878 --> 00:26:56,526
Adding VM scale sets, web apps,

430
00:26:56,630 --> 00:27:00,510
testing kubernetes, clusters and anything else that I already talked

431
00:27:00,542 --> 00:27:02,874
about. Now from here,

432
00:27:03,494 --> 00:27:06,914
next step is obviously triggering an experiment.

433
00:27:07,414 --> 00:27:11,382
Now before this is capable of kicking off, you need

434
00:27:11,398 --> 00:27:15,534
to define role based access permission. You need to provide

435
00:27:16,354 --> 00:27:20,218
the correct permissions. And interesting enough, it only needs reader

436
00:27:20,266 --> 00:27:23,658
permissions so there's no real security violation

437
00:27:23,746 --> 00:27:27,522
I would say, or security violation actually better where

438
00:27:27,578 --> 00:27:31,402
the cpu experiment by itself is becoming an

439
00:27:31,498 --> 00:27:35,650
Azure standalone resource, which means it has a service principle

440
00:27:35,682 --> 00:27:39,246
in the back and we need to define our RBAC permissions.

441
00:27:39,430 --> 00:27:43,230
Defining read RBAC role based access for

442
00:27:43,262 --> 00:27:46,582
my PDT CPU experiment towards that

443
00:27:46,678 --> 00:27:50,870
specific resource. So we go into our target scenario,

444
00:27:50,902 --> 00:27:54,554
in this case my ubuntu vm, we go into access control.

445
00:27:55,374 --> 00:27:59,374
We're going to define that. My PDD CPU experiment gets

446
00:27:59,454 --> 00:28:03,634
reader permissions, so add new role assignment.

447
00:28:04,324 --> 00:28:07,812
Reader permissions is all it needs and

448
00:28:07,828 --> 00:28:11,260
we're going to specify the member where my member

449
00:28:11,332 --> 00:28:15,084
is. PDT CPU experiment that should

450
00:28:15,124 --> 00:28:18,964
be able to find something. Not for now for some weird reason,

451
00:28:19,004 --> 00:28:23,092
but you probably get the idea. Not gonna wait for it. So now

452
00:28:23,108 --> 00:28:26,388
the next step is running your testing. And as you

453
00:28:26,396 --> 00:28:29,160
can see I got a few other ones from other demos that I did,

454
00:28:29,292 --> 00:28:32,960
and some of them are failed, some of them are successful. So we're obviously aiming

455
00:28:32,992 --> 00:28:37,124
for successful ones. So what I'm going to do here is kicking it off,

456
00:28:37,704 --> 00:28:40,924
starting my process to just show you what it's about.

457
00:28:41,584 --> 00:28:45,608
It's going to move this into studio processing cube,

458
00:28:45,656 --> 00:28:48,496
so nothing really to wait for.

459
00:28:48,680 --> 00:28:52,684
And while it is running you can validate the details.

460
00:28:53,264 --> 00:28:57,184
Looks like my portal is running behind a little bit now.

461
00:28:57,224 --> 00:29:00,576
Here it tells me because I was not able to actually define that

462
00:29:00,600 --> 00:29:04,200
RBAC. It's literally going to tell me like too bad it's not working.

463
00:29:04,272 --> 00:29:07,680
I don't have permissions to run this, which is totally fine.

464
00:29:07,712 --> 00:29:11,488
I explicitly wanted to show you, but I can go back to

465
00:29:11,536 --> 00:29:15,304
another task and showing you the outcome of it, the exact

466
00:29:15,344 --> 00:29:18,936
same scenario. I simulated cpu pressure

467
00:29:19,080 --> 00:29:22,808
running cpu testing during 1010 minutes. So you can

468
00:29:22,936 --> 00:29:26,560
nicely see here it started 446 and it

469
00:29:26,592 --> 00:29:30,528
finished 456 and it ran for about ten

470
00:29:30,576 --> 00:29:34,536
minutes and the outcome is complete. Now the

471
00:29:34,560 --> 00:29:38,064
part that I cannot really show you, but you should probably find

472
00:29:38,104 --> 00:29:41,808
out that you could go back to your Azure monitor, could go back to log

473
00:29:41,856 --> 00:29:45,096
analytics, going to your virtual machine if you want to run

474
00:29:45,120 --> 00:29:48,476
this live and validating where you go into the metrics,

475
00:29:48,580 --> 00:29:52,140
checking the cpu load and seeing that the cpu is

476
00:29:52,172 --> 00:29:56,300
spiking up to 99% and then after ten minutes it's totally

477
00:29:56,332 --> 00:29:59,868
dropping back and at the same time, and that's obviously more important,

478
00:29:59,996 --> 00:30:03,144
you're going to validate the impact on your workload.

479
00:30:03,644 --> 00:30:06,908
Another scenario for my AKS cluster,

480
00:30:06,956 --> 00:30:10,700
why not? Is first of all defining your

481
00:30:10,732 --> 00:30:14,360
chaos studio. We already did defining the target agent

482
00:30:14,392 --> 00:30:18,288
list. So the direct service option and creating

483
00:30:18,376 --> 00:30:21,544
an experiment where what I did with this

484
00:30:21,584 --> 00:30:24,792
one is defining a step where

485
00:30:24,848 --> 00:30:28,904
I'm going to run a predefined chaos mesh. So that open sourced

486
00:30:28,984 --> 00:30:32,800
library, the family of the library that I showed you earlier

487
00:30:32,872 --> 00:30:36,608
in the docs and just grabbing one of those parameters where

488
00:30:36,656 --> 00:30:39,984
you can see here parts of that JSon, and I don't really know if it's

489
00:30:40,024 --> 00:30:44,020
related to the preview, but if I go into edit mode it's

490
00:30:44,052 --> 00:30:47,300
not going to show me the details of that JSoN. So that's something

491
00:30:47,492 --> 00:30:51,036
I noticed while going through the configuration that

492
00:30:51,140 --> 00:30:54,676
from here it's not really, I would say publishing,

493
00:30:54,780 --> 00:30:58,372
showing you the details of that JSON file experiment.

494
00:30:58,468 --> 00:31:02,308
So maybe something to keep in mind during your preview testing to

495
00:31:02,356 --> 00:31:06,236
copy your fold library snippets aside, if you don't just want to

496
00:31:06,260 --> 00:31:09,904
rely on what's already available over here in that

497
00:31:09,984 --> 00:31:13,344
fold library, if you want to spin up a new one.

498
00:31:13,424 --> 00:31:17,344
So what I could do here is my

499
00:31:17,384 --> 00:31:20,520
pots and grabbing one of those

500
00:31:20,552 --> 00:31:24,096
jSon. So that's literally what I did and you can see

501
00:31:24,120 --> 00:31:27,928
it down here. So let's run this experiment

502
00:31:27,976 --> 00:31:31,432
as well. We're going to start it, gonna kick it

503
00:31:31,448 --> 00:31:34,812
off. The best way to validate your

504
00:31:34,948 --> 00:31:38,396
running paths and how they're behaving is running

505
00:31:38,420 --> 00:31:42,260
cube control, right? You can validate a little bit of it using

506
00:31:42,332 --> 00:31:46,516
Azure monitor as well, but why not showing you Kubectl

507
00:31:46,660 --> 00:31:50,268
get pods. We're now out of my experiment.

508
00:31:50,396 --> 00:31:53,860
It should run. Some of my pots and some other ones

509
00:31:53,892 --> 00:31:57,264
are getting stopped. So that's literally what we're testing here.

510
00:31:57,684 --> 00:32:01,170
I can see that already. In just a couple of minutes it's

511
00:32:01,202 --> 00:32:04,690
terminating and it is restarting once where the other ones,

512
00:32:04,722 --> 00:32:08,458
because there's a little bit of time I kept in between the recording of

513
00:32:08,586 --> 00:32:12,274
kicking off the task and moving to the behavior of the pots,

514
00:32:12,394 --> 00:32:15,282
where you can see that I'm literally stopping a pot,

515
00:32:15,338 --> 00:32:19,010
starting it again, stopping it, starting it again. That's the main scenario

516
00:32:19,042 --> 00:32:22,694
we're testing. I'm only running one note in the backend,

517
00:32:23,194 --> 00:32:25,814
but you probably get the idea from here.

518
00:32:26,334 --> 00:32:29,886
Awesome. I'm so excited that all my demos actually worked.

519
00:32:29,990 --> 00:32:32,934
Now, to make sure I'm not running too much out of time here for my

520
00:32:32,974 --> 00:32:37,078
session, let's wrap it up with sharing some resources. The first link

521
00:32:37,126 --> 00:32:41,014
here is our official Chaos studio documentation on the Microsoft

522
00:32:41,054 --> 00:32:45,310
Learn platform. The second one are pointers to additional

523
00:32:45,342 --> 00:32:48,990
learn resources that could be helpful if you're a little

524
00:32:49,022 --> 00:32:52,534
bit teased by the demos that I did, because those are the step by step

525
00:32:52,574 --> 00:32:56,952
instructions on how to integrate chaos studio for your Kubernetes clusters

526
00:32:57,048 --> 00:33:00,448
and using virtual machine agent based. With that,

527
00:33:00,496 --> 00:33:03,816
I would like to thank you for watching my session. I hope

528
00:33:03,840 --> 00:33:07,416
you learned from it, and obviously even more, I hope you enjoyed it.

529
00:33:07,560 --> 00:33:11,272
Don't hesitate reaching out in case of any questions on the session

530
00:33:11,368 --> 00:33:15,144
on Azure, and maybe even more so on Azure Chaos studio

531
00:33:15,224 --> 00:33:19,080
specifically. Enjoy the rest of 42 side reliability

532
00:33:19,152 --> 00:33:22,800
engineering conference and I hope to see you again in any of my other online

533
00:33:22,872 --> 00:33:25,624
sessions. Thank you so much and enjoy the rest of the day.

