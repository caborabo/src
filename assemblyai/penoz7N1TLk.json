{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/b9135812-e927-45fe-b097-7cd24235c1fd", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["app", "basics", "beyond", "blind", "conf fourty two", "customizable", "debugging", "features", "gofr", "gofrdev", "golang developer", "including", "levels", "srijan rastogi", "tracing", "unlock"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_audio_quality": null, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "speech_model": null, "id": "eb70ef3f-3788-4150-a6d8-4395b940c14c", "status": "completed", "error": null, "text": "Hello everyone, I am Sujan restaurant. Thanks for joining in on my presentation on the topic no more flying plant unlock observability for smooth selling with Quofem. Here we will be discussing about observability, what are its building blocks? How it benefits the developer to gain insights of the application and then we will dive into Gopher and its features regarding observability in todays digital age, applications are becoming increasingly complex, often built using microservices architecture. This complexity makes it challenging to understand how these systems behave and identify issues when they arise. Thats where observability comes in for your health. What is observability? Observability is ability to understand the internal state of the system. By examining its external output. It provides a holistic view of your system health, enabling us to troubleshoot problems, optimize performance and ensure application reliability. The building blocks of observability are considered to be metrics, logs and traces. These three building blocks work together to provide a comprehensive view of your system. Metrics offer a high level overview. Logs provide detailed information about specific events and traces help us understand the flow of execution across services. What are the benefits of observability? By having a clear understanding of our systems behavior, you can identify and fix problems much faster. Observability helps you optimize your applications performance and stability, leading to a better user experience. Additionally, you can proactively identify potential issues before even they impact users, which causes to reduce your downtime and ensuring business continuity. Now let's get started with Gopher. Gopher is an open source and it has a large and active community of users who are happy to help. Gopher also provides comprehensive documentation, tutorials and forums to guide you through the installation and configuration process. You can visit her on the mentioned website or our GitHub repo. Let's see how we can build a simple hello API using kofer. I have created a directory of the name Gopher hello API. Let's initialize the comod for it with the same name. So to get Kofer as a dependency we would need to run command go gether dot de f. Also to add the configs of the application we would need to add a configs directory in which we can add a env file which will have configs for our application regarding HTTP server databases and also we are adding trace exporter which we will discuss later. Now let's get started with the main file main go. In the main function we would be initializing a app risk it's returned by the Gofund new function. It gives us an instance of a gopher application using which we can register handlers, run DB migrations, or start the server here in hello server hello handler. We are returning hello world and nil is the error all the woofer handlers return interface and error type. Now let's get started with the server. Before that we need to run Gomont id. Now let's get started with the server. As you can see, the server is getting initialized at 9000. The metrics are already being initialized at 21 21, and our traces are being exported to the mentioned website. So let's hit the server and see what we get in return. So as you can see we are getting hello Web. Now let's check the metrics server. Here you can see Gopher provides the memory metrics. Also you can see the HTTP response with the specific routes with the status port, how much time it took, and all the go routines. Memory related metrics now we can hit more request and see if the metrics are updated. Yes. Now the gopher also provides you with the health six functionality. You can hit that on the server dot well known slash alive endpoint so it returns that the status is for the service. Also you can see that these are the logs which are perfectly formatted on the terminal for our application. Now let's see how the traces are being shown in our offer tracer UI. These are the correlation ids which are respect, which are unique for all the requests and which are used to track the application flow. Let's search for that. Here you can see that we have the traces like we hit the get endpoint at hello and the gopher router, how much time it took, and all the other necessary details. Now as we have seen the implementation from Gopher, let's see how Gopher helps you overcome the challenges of observability. It provides a centralized inbuilt platform for all your observability needs. Lets explore how Gopher can empower your development and operations teams. It collects metrics, data which can be used to identify bottlenecks and track the health of your application over time logs which can be helpful for debugging and troubleshooting issues. Distributed tracing helps you pinpoint the root cause of issues in complex systems. Now lets get started with the building blocks of mapsibility. Let's start with metrics. Metrics are the foundation of observability. They provide us with quantifiable data points that allows us to measure the performance and health of your system. Think of metrics as gauges on your car's dashboard. They tell us how fast you are going, how much fuel you have left, and if there are any potential problems. In Gopher's perspective, there are many different types of metrics that can be used in cofer, but some of the most common ones falls into three categories, application performance, infrastructure performance and user behavior. By analyzing these metrics in Gopher, you can gain valuable insights into how your system is performing, identify potential issues, and ultimately deliver a better user experience. Gopher also empowers you to create custom metrics for your specific use, case and needs. Now let's discuss about logging think of logs as your application diary. They capture what's happening inside your code at a different point of time. Logs are the one of the three pillars of observability alongside with metrics and traces. While metrics offer high level overviews and traces shows request flows, logs provide the detailed stories behind the scene. In Gopher's perspective, it provides logs for every single detail of your application, like reading of configs, databases, server starts, etcetera. It provides beautiful terminal logs as shown in the image. The logs can also be exported in a well structured JSON format which helps you in filtering on the basis of keys. Now let's talk about traces. Distributed tracing is a powerful technique for monitoring and debugging applications, especially those built with microservices architecture. By tracing requests across different services, we gain valuable insights into how our application is functioning as a whole. Gopher highlights the integration with tracing tools like Zipkin and Eagle. It also has a internal tracing tool which we will discuss later and also trace ids are used to track requests across microservices. Visualizing the request flow helps pinpointing the bottleneckness and performance issues, leading to faster debugging and improved application health. Overall, distributed tracing empowers developments developers to build robust and scalable applications with the help of WOFL. So as we discussed in now, the benefits of observability features in Gopher and how it enhances the efficiency of developing an application. Here is a quick summary of them. Gopher removes the need for multiple tools and provide a uniform platform for all your observability needs. It quickly identify and resolve issues. With Gophers powerful analytics and visualization capabilities, you can also gain deeper insights into application behavior to make informed development decisions. Kofer is also an open source platform, eliminating the need for expensive propriety solutions. Now let's see. In Libya action for the microservices. Here I have filled two microservices order func and order data so let's see, for order data configs we have app name, app version, HTTP port and the DB configurations. Similarly, like we have created the migration also to create the orders table. And if we go to orders funk, we have added the same configurations here where data service being the URL for the downstream service. So let's start the order data service. So if we see like the DB is connected because the log migration that we wrote successfully, so the table would have been created. Let's run the order funk service. Now the service is being started on port 8080. Now let's hit some requests. We are using jmeter for that. So now we can see that there are multiple requests coming on both the order data service and the order the function. Here we can see the downstream URL also for the data service. So now if we go to check the metrics here, we have used Grafana to visualize the metrics. I will attach the dashboard JSON file in my repo so you can take a look over that. So let's see how matrix visualization comes into play. So we can see that go routines memory utilization is being visualized using Gopher matrix. We are also showing the response time SLA for the metrics and the heat map for them. Request count and request code is also shown. So this would be helpful. Like to know the service how many requests came, which type of request it got. We can see like it is showing the path, it is showing the method over that. And in the status code we can see like this type of status code it responded with. Similarly we see like p 90, p 95, all of those percentiles. Also like we can also see like which route and which path combo combination return, which status code, how many times. So here we only have two execs, 200 and 201s. So yeah, for outbound request, since it is a data layer, we won't have SQa DB metrics. We can also see like we are showing how many, how much time did the DB took to respond, like which type of queries we ran on the Db and how many DB connections were open. Same as we can also see the order funk here we can see like we can see the versions also similarly go routines, memory inbound request. Here there is a point that we can notice, like this point of time. We can see that it took a lot of time to process the request at 99.9%. So here we can debug like and like find the root cause for that. What would be the reason like for this much time of the request for responding and see like how many requests are being hit. What is this response code for that? Similarly, as we discussed for order data, we can see like post was the main culprit for the response time. Similarly, we can see the response codes and output. So here we can see like order data was the culprit. So we can see like DB was taking a lot of time. Like it took around 4.5 seconds. So we can see. And regarding the next peak, we will need to check with order funk. So here, let's check with order funk tracer. Also, we will add a trace exporter config equal to gopher. So yeah, let's restart the services again. First we will restart the order data service showing these sales. Yeah, so now tracer is being exported. Let's start this service as well. So yeah, again, we will be making some requests on the services. Use jmeter again for that. Yeah, and now since we have these trace ids, correlation ids, so we can use any one of that to see the traces at the tracer dot gopher dot de f. Let me just copy paste it. Let's see, like first of all, let's see the response of the service. So yeah, as we discussed further, like we have a health check endpoint. It shows like the downstream service order data is up. Now we can see the tracer UI. We just need to go to this URL, copy paste the tracer id, and we can see like this type of request we hid from where it circulates, like from where it went, all the details like method schema, status code. Thank you for joining in. You can explore all the content being used on this given GitHub repo. Also do visit Gopher dev and give us a start to support us. Thank you.", "words": [], "utterances": null, "confidence": 0.906478473025049, "audio_duration": 927.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Observability is ability to understand the internal state of the system. It provides a holistic view of your system health, enabling us to troubleshoot problems, optimize performance and ensure application reliability. Building blocks of observability are considered to be metrics, logs and traces.\n- Gopher is an open source software that tracks application flow. It collects metrics which can be used to identify bottlenecks and track the health of your application. Distributed tracing helps you pinpoint the root cause of issues in complex systems. Lets explore how Gopher can empower your development and operations teams.\n- Gopher provides three pillars of mapsibility: metrics, logs and traces. Think of metrics as gauges on your car's dashboard. Logs capture what's happening inside your code at a different point of time. Gopher also empowers you to create custom metrics for your specific use, case and needs.\n- Distributed tracing is a powerful technique for monitoring and debugging applications. By tracing requests across different services, we gain valuable insights into how our application is functioning as a whole. Visualizing the request flow helps pinpointing the bottleneckness and performance issues. Overall, distributed tracing empowers developers to build robust and scalable applications.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.07, "text": "application performance", "timestamps": [{"start": 427030, "end": 428254}]}, {"count": 1, "rank": 0.06, "text": "application behavior", "timestamps": [{"start": 585444, "end": 586732}]}, {"count": 1, "rank": 0.06, "text": "improved application health", "timestamps": [{"start": 543454, "end": 545102}]}, {"count": 1, "rank": 0.06, "text": "debugging applications", "timestamps": [{"start": 502050, "end": 503462}]}, {"count": 1, "rank": 0.06, "text": "request code", "timestamps": [{"start": 704012, "end": 704756}]}, {"count": 1, "rank": 0.06, "text": "application reliability", "timestamps": [{"start": 83418, "end": 84894}]}, {"count": 1, "rank": 0.06, "text": "request flows", "timestamps": [{"start": 468074, "end": 469130}]}, {"count": 1, "rank": 0.06, "text": "SQa DB metrics", "timestamps": [{"start": 745894, "end": 748342}]}, {"count": 1, "rank": 0.06, "text": "order data configs", "timestamps": [{"start": 608812, "end": 610222}]}, {"count": 1, "rank": 0.06, "text": "memory inbound request", "timestamps": [{"start": 770438, "end": 773016}]}, {"count": 1, "rank": 0.06, "text": "Gopher matrix", "timestamps": [{"start": 694324, "end": 695388}]}, {"count": 1, "rank": 0.05, "text": "multiple requests", "timestamps": [{"start": 658910, "end": 659790}]}, {"count": 8, "rank": 0.05, "text": "order data", "timestamps": [{"start": 605668, "end": 606544}, {"start": 608812, "end": 609348}, {"start": 630234, "end": 630898}, {"start": 661198, "end": 661718}, {"start": 802484, "end": 803404}, {"start": 814204, "end": 814796}, {"start": 840888, "end": 841408}, {"start": 890140, "end": 890644}]}, {"count": 1, "rank": 0.05, "text": "Memory related metrics", "timestamps": [{"start": 287660, "end": 290144}]}, {"count": 1, "rank": 0.05, "text": "order funk tracer", "timestamps": [{"start": 829672, "end": 831064}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}