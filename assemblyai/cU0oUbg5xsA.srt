1
00:00:20,680 --> 00:00:24,326
Hi and thanks for tuning in here at Con 42

2
00:00:24,390 --> 00:00:28,414
Golang and especially for joining my talk going so

3
00:00:28,454 --> 00:00:31,846
serverless with Webassembly. So without

4
00:00:31,950 --> 00:00:35,358
further ado, let me quickly bring up my slides

5
00:00:35,486 --> 00:00:37,554
and let's get started right,

6
00:00:39,014 --> 00:00:42,734
alright, who am I? My name is Torsten.

7
00:00:42,854 --> 00:00:46,462
I work as a cloud advocate with Fermion Technologies.

8
00:00:46,638 --> 00:00:50,214
The most important thing on this slide is my mail

9
00:00:50,254 --> 00:00:54,590
address. So if you have any further questions, don't hesitate,

10
00:00:54,662 --> 00:00:58,470
just shoot me a mail after the talk, after a

11
00:00:58,502 --> 00:01:02,206
conference, just reach out and

12
00:01:02,230 --> 00:01:05,662
we will sort things out. So in the

13
00:01:05,678 --> 00:01:09,422
upcoming 30 minutes we will take a look at what webassembly

14
00:01:09,478 --> 00:01:13,086
is, why it is so important, and then we

15
00:01:13,110 --> 00:01:16,874
will dive into the open source project spin

16
00:01:17,174 --> 00:01:20,862
and we'll do some hands on, right? So we'll start with a simple

17
00:01:20,918 --> 00:01:24,358
hello world, then we will extend that a little bit,

18
00:01:24,486 --> 00:01:28,254
and from there we will take a look at a full fledged crud API

19
00:01:28,334 --> 00:01:31,782
implementation. And finally

20
00:01:31,838 --> 00:01:36,030
we will take a look at now that we end up with a serverless

21
00:01:36,142 --> 00:01:39,470
app in webassembly that

22
00:01:39,502 --> 00:01:43,262
we've written in tiny go where can we run it and how do

23
00:01:43,278 --> 00:01:46,814
we do that? All right, so let's jump right

24
00:01:46,854 --> 00:01:50,054
into Webassembly. So what

25
00:01:50,094 --> 00:01:53,522
is webassembly? Maybe you've already heard the term web

26
00:01:53,558 --> 00:01:57,094
waSm, which is just an abbreviation for Webassembly,

27
00:01:58,194 --> 00:02:01,906
which ultimately specifies a binary instruction

28
00:02:01,970 --> 00:02:05,914
format. This means that we

29
00:02:05,994 --> 00:02:09,738
as developers take or write code,

30
00:02:09,866 --> 00:02:13,898
right, in any language that supports Webassembly,

31
00:02:14,066 --> 00:02:18,394
and we compile it down to that binary format,

32
00:02:18,474 --> 00:02:21,382
right? And then there are runtimes.

33
00:02:21,478 --> 00:02:25,714
Runtimes are stack based virtual machines that

34
00:02:26,174 --> 00:02:29,514
can run our webassembly binaries.

35
00:02:30,934 --> 00:02:35,558
There are many runtimes available. There are runtimes optimized

36
00:02:35,646 --> 00:02:39,474
for edge computing, optimized for cloud computing,

37
00:02:40,014 --> 00:02:44,054
general purpose runtimes. So there's a whole

38
00:02:44,134 --> 00:02:48,534
ecosystem when it comes to webassembly

39
00:02:50,634 --> 00:02:53,134
compatible runtime. So to say,

40
00:02:54,874 --> 00:02:59,162
we have a lot, really a lot of popular programming

41
00:02:59,218 --> 00:03:02,174
languages already supporting Webassembly.

42
00:03:02,594 --> 00:03:06,234
However, it's still a growing list

43
00:03:06,274 --> 00:03:09,362
of languages, and we hope to check more

44
00:03:09,418 --> 00:03:12,054
boxes in the upcoming months or so.

45
00:03:13,414 --> 00:03:16,878
Initially, WebAssembly has been invented for the browser,

46
00:03:16,926 --> 00:03:20,830
right? Because all our compute devices became

47
00:03:20,902 --> 00:03:24,646
beefier, they had more power, they could achieve more,

48
00:03:24,710 --> 00:03:28,814
right? So Webassembly allowed software vendors

49
00:03:28,894 --> 00:03:33,246
to take existing code, compile it instead

50
00:03:33,310 --> 00:03:37,914
to a processor architecture like X 64.

51
00:03:38,714 --> 00:03:42,338
They could compile it down to Webassembly and

52
00:03:42,426 --> 00:03:46,642
move that piece of code closer

53
00:03:46,698 --> 00:03:50,922
to the user and leverage their compute

54
00:03:51,018 --> 00:03:54,610
capabilities, right? So a popular example

55
00:03:54,682 --> 00:03:58,498
is, for example, Adobe Photoshop where a

56
00:03:58,626 --> 00:04:02,514
whole lot of algorithms were moved

57
00:04:02,634 --> 00:04:06,730
into the browser, which allows us as users to

58
00:04:06,762 --> 00:04:10,670
do photo editing right inside of the browser

59
00:04:10,742 --> 00:04:14,034
by leveraging webassembly under the covers.

60
00:04:14,854 --> 00:04:18,318
So that's why Webassembly was invented.

61
00:04:18,406 --> 00:04:21,750
However, the strict sandbox and

62
00:04:21,862 --> 00:04:25,686
the near native performance that we as developers

63
00:04:25,830 --> 00:04:29,974
got from adopting Webassembly was

64
00:04:30,054 --> 00:04:34,286
the key for Webassembly, you know, growing beyond

65
00:04:34,390 --> 00:04:37,510
the browser and becoming

66
00:04:37,622 --> 00:04:41,154
popular on the server and also in the cloud.

67
00:04:43,574 --> 00:04:46,438
Ultimately, at some point in time,

68
00:04:46,566 --> 00:04:50,062
Webassembly becomes for us as developers just

69
00:04:50,118 --> 00:04:53,798
a compilation target. And to illustrate that,

70
00:04:53,926 --> 00:04:57,950
let's have a look at a simple diagram, right? So we write code

71
00:04:58,022 --> 00:05:01,478
in any language, let's say tinygo, right? It supports

72
00:05:01,526 --> 00:05:06,086
webassembly. So we can instruct a tiny go compiler

73
00:05:06,230 --> 00:05:10,126
to compile our code down to webassembly,

74
00:05:10,270 --> 00:05:14,342
and we end up with a webassembly module or

75
00:05:14,398 --> 00:05:18,462
file with a WASM extension. So from

76
00:05:18,518 --> 00:05:21,614
there with our module, which is our executable

77
00:05:21,694 --> 00:05:24,510
or maybe shared library,

78
00:05:24,582 --> 00:05:28,806
whatever, right? We can take that wasm

79
00:05:28,870 --> 00:05:33,178
file and hand it over to a webassembly

80
00:05:33,366 --> 00:05:36,634
runtime, which is then

81
00:05:36,714 --> 00:05:40,094
responsible for loading the webassembly module,

82
00:05:40,514 --> 00:05:44,362
instantiating it and invoking its entry

83
00:05:44,418 --> 00:05:48,394
point or its exposed API,

84
00:05:48,514 --> 00:05:52,134
that is, you know, the desired one.

85
00:05:54,354 --> 00:05:58,466
Ultimately, webassembly gives us

86
00:05:58,570 --> 00:06:00,814
four main capabilities.

87
00:06:01,154 --> 00:06:05,130
So especially if you compare webassembly applications

88
00:06:05,242 --> 00:06:09,474
to traditional applications that we may be distribute

89
00:06:09,514 --> 00:06:12,986
in containers, our applications are way smaller,

90
00:06:13,050 --> 00:06:17,266
right? Because we have a binary instruction format.

91
00:06:17,410 --> 00:06:20,714
So in our distributable is just the app.

92
00:06:20,794 --> 00:06:24,894
So we don't have to ship a web server in order to

93
00:06:26,034 --> 00:06:29,586
get a web app from our, let's say Ci CD

94
00:06:29,650 --> 00:06:32,878
system into production, right? The module just consists

95
00:06:32,926 --> 00:06:37,062
of the app, which reduces the distributable

96
00:06:37,158 --> 00:06:38,674
size a lot,

97
00:06:40,414 --> 00:06:45,350
secure. So every webassembly application

98
00:06:45,502 --> 00:06:49,366
is instantiated and executed

99
00:06:49,430 --> 00:06:52,274
in a strict sandbox environment.

100
00:06:53,374 --> 00:06:57,890
We must specify which

101
00:06:57,962 --> 00:07:01,434
permissions or which capabilities our app

102
00:07:01,474 --> 00:07:04,454
is allowed to use. So by default, for example,

103
00:07:05,234 --> 00:07:08,762
a webassembly module is not able to read files

104
00:07:08,898 --> 00:07:13,482
from the local file system, right? We have to explicitly

105
00:07:13,538 --> 00:07:17,826
grant the permission to that app that it

106
00:07:17,970 --> 00:07:21,330
may read from the temp folder or that it may

107
00:07:21,402 --> 00:07:24,270
write to the user's home directory.

108
00:07:24,402 --> 00:07:27,902
So we have to explicitly define

109
00:07:27,998 --> 00:07:32,766
or specify the permissions or the intent for

110
00:07:32,910 --> 00:07:37,190
that app. With webassembly

111
00:07:37,382 --> 00:07:40,354
we get near native performance,

112
00:07:40,854 --> 00:07:44,662
right? So apps are freaking fast.

113
00:07:44,838 --> 00:07:48,414
And to me one of the most, besides,

114
00:07:48,454 --> 00:07:52,126
I would say besides secure, secure, it's the most

115
00:07:52,190 --> 00:07:55,244
interesting capability is the portability,

116
00:07:55,704 --> 00:07:59,472
right? We don't have to care about different

117
00:07:59,568 --> 00:08:03,928
operating systems or different processor architectures

118
00:08:04,016 --> 00:08:07,408
anymore. We write code, we compile

119
00:08:07,456 --> 00:08:11,048
it to webassembly, and it does not matter if we

120
00:08:11,176 --> 00:08:14,960
execute it on an x 64 or an

121
00:08:14,992 --> 00:08:18,768
ARM 64 architecture. We compile

122
00:08:18,816 --> 00:08:21,964
it once and we run it everywhere.

123
00:08:24,064 --> 00:08:27,424
So now that we have a common understanding

124
00:08:27,544 --> 00:08:31,008
of what webassembly is and why it is

125
00:08:31,096 --> 00:08:34,032
so important, I will,

126
00:08:34,168 --> 00:08:38,208
you know, introduce you to the open source framework

127
00:08:38,376 --> 00:08:40,524
or project spin.

128
00:08:41,464 --> 00:08:45,256
So spin, you can find it on GitHub@GitHub.com

129
00:08:45,400 --> 00:08:48,768
fermion spin. It mainly

130
00:08:48,816 --> 00:08:53,040
consists of three pillars, right? So we have developer tooling

131
00:08:53,112 --> 00:08:56,464
which ensures that you remain productive.

132
00:08:56,624 --> 00:09:01,204
It's a super simple yet powerful CLI

133
00:09:02,264 --> 00:09:06,456
that allows you to create new projects using different templates,

134
00:09:06,640 --> 00:09:10,376
to compile your code down to webassembly and

135
00:09:10,400 --> 00:09:14,098
to run apps locally. So it addresses all the concerns

136
00:09:14,216 --> 00:09:16,634
of the inner loop experience.

137
00:09:18,774 --> 00:09:22,994
The second pillar is a set of lightweight,

138
00:09:23,454 --> 00:09:27,542
language specific SDKs. So instead

139
00:09:27,598 --> 00:09:30,754
of relying on core web assembly APIs,

140
00:09:31,174 --> 00:09:35,514
spin provides higher level APIs

141
00:09:36,614 --> 00:09:40,114
that make you more productive

142
00:09:40,254 --> 00:09:44,138
at the end of the day, right? And last but not least,

143
00:09:44,266 --> 00:09:47,906
the spin itself is built on top on wasn't time.

144
00:09:47,970 --> 00:09:51,610
So the spin CLi, right? So it allows you

145
00:09:51,642 --> 00:09:55,090
to run your apps locally. So it's

146
00:09:55,162 --> 00:09:58,494
also a webassembly runtime, so to say,

147
00:10:00,474 --> 00:10:04,674
okay, so let's jump right into the terminal

148
00:10:04,794 --> 00:10:08,034
and let's get started. Started. So where's my terminal?

149
00:10:08,734 --> 00:10:13,326
There we go. So first let's do a spin

150
00:10:13,510 --> 00:10:18,034
version. So I'm right now on spin 2.42

151
00:10:19,134 --> 00:10:23,006
and I have spin comes with a built in template

152
00:10:23,110 --> 00:10:26,606
engine. So I have installed some

153
00:10:26,670 --> 00:10:30,222
templates. There are multiple templates available. You can

154
00:10:30,278 --> 00:10:33,978
roll your own templates that the line bit more with your

155
00:10:34,026 --> 00:10:37,978
preferences if the default templates doesn't

156
00:10:38,026 --> 00:10:41,922
address your needs, right. What we will use right now is the

157
00:10:41,978 --> 00:10:46,010
HTTP go template to build a simple

158
00:10:46,082 --> 00:10:49,922
hello world so we can do a spin new set our

159
00:10:49,978 --> 00:10:53,586
template HTTP go. We accept the defaults

160
00:10:53,650 --> 00:10:57,454
because every template can ask you some

161
00:10:57,834 --> 00:11:01,472
questions to get additional information or

162
00:11:01,528 --> 00:11:04,680
metadata. But we will stick with defaults right now and we will

163
00:11:04,712 --> 00:11:07,804
call our app helloconf 42.

164
00:11:08,504 --> 00:11:11,856
Okay, so what do we get from that? Let's go.

165
00:11:11,920 --> 00:11:15,520
No, let's go into helloconf 42 and let's do

166
00:11:15,552 --> 00:11:19,364
a code dot. So we get.

167
00:11:20,064 --> 00:11:23,424
That looks familiar, right? So we get a go mod sum file,

168
00:11:23,464 --> 00:11:27,262
we get a main go file, but we also get a spin Tamil.

169
00:11:27,398 --> 00:11:30,918
And the spin toml is like the application manifest

170
00:11:31,006 --> 00:11:35,118
where we have all those application wide metadata

171
00:11:35,206 --> 00:11:38,398
where we can configure triggers. So triggers

172
00:11:38,446 --> 00:11:42,198
are like they specify the

173
00:11:42,246 --> 00:11:45,678
event that makes the runtime invoke

174
00:11:45,726 --> 00:11:49,526
our code. So in this case we have a simple HTTP

175
00:11:49,590 --> 00:11:53,588
trigger, listening to forward root route

176
00:11:53,636 --> 00:11:57,164
and everything behind that. And if

177
00:11:57,204 --> 00:12:00,548
a request hits that endpoint, we want to invoke the

178
00:12:00,596 --> 00:12:03,916
Helocon 42 component.

179
00:12:04,100 --> 00:12:07,664
But how do we get from source code to that component?

180
00:12:08,164 --> 00:12:11,204
So spin takes care of that. It doesn't matter

181
00:12:11,244 --> 00:12:14,636
if you do, if you use go, if you use JavaScript for different

182
00:12:14,700 --> 00:12:17,980
scenario, maybe typescript, maybe rust, whatever, right?

183
00:12:18,132 --> 00:12:22,196
You always follow the spin workflow

184
00:12:22,340 --> 00:12:26,412
and one command of the spin workflow. We just saw spin

185
00:12:26,468 --> 00:12:30,100
new, another one is spin build to compile

186
00:12:30,132 --> 00:12:33,740
the source code down to webassembly in order to

187
00:12:33,772 --> 00:12:37,372
be language agnostic. You can see the

188
00:12:37,428 --> 00:12:41,212
build command which is executed if you run spin go

189
00:12:41,308 --> 00:12:44,472
behind a certain, right,

190
00:12:44,568 --> 00:12:48,336
so we do a tiny go build, we target wasi, which is

191
00:12:48,360 --> 00:12:51,912
the webassembly system interface, and provide additional

192
00:12:51,968 --> 00:12:55,644
flags. We also have a spin,

193
00:12:55,944 --> 00:12:59,712
you also have a spin watch command so that you get hot reload

194
00:12:59,768 --> 00:13:03,096
if you're coding. But for now let's

195
00:13:03,120 --> 00:13:05,484
have a look at the implementation, right?

196
00:13:06,424 --> 00:13:10,632
So the skeleton looks like we

197
00:13:10,688 --> 00:13:14,680
have an init function. And yes, by convention you

198
00:13:14,712 --> 00:13:18,160
have to place your handler inside of the init

199
00:13:18,232 --> 00:13:21,968
func. And we use the primitives

200
00:13:22,016 --> 00:13:25,824
provided by go, right? So you have HTTP response

201
00:13:25,864 --> 00:13:29,952
writer, HTTP request, like all those primitives that you've

202
00:13:30,128 --> 00:13:33,284
been using for decade, for a decade right now.

203
00:13:33,904 --> 00:13:37,248
And we use that to set a response

204
00:13:37,376 --> 00:13:41,442
content, type HTTP header on the response and

205
00:13:41,578 --> 00:13:44,858
to write out hello Fermion. So let's write out

206
00:13:44,906 --> 00:13:48,574
hello Conf 42 in our case,

207
00:13:49,634 --> 00:13:52,882
and let's bring up the terminal

208
00:13:52,978 --> 00:13:56,962
inside of versus code, and let's do it the spin

209
00:13:57,138 --> 00:14:01,010
build. So this takes

210
00:14:01,042 --> 00:14:04,394
our source code uses tiny go to compile

211
00:14:04,434 --> 00:14:08,418
it down to Webassembly, and we end up with a waSm

212
00:14:08,466 --> 00:14:11,722
file over here. And if we open that anyway

213
00:14:11,818 --> 00:14:15,494
with the text editor, we see that is a binary

214
00:14:15,914 --> 00:14:19,170
format. So as spin

215
00:14:19,202 --> 00:14:23,474
is already a runtime, by leveraging wasm

216
00:14:23,514 --> 00:14:26,554
time, we can also do like a spin up,

217
00:14:26,714 --> 00:14:30,794
which starts the app on the local system.

218
00:14:30,914 --> 00:14:35,200
As you can see, the app is now available on port port 3000.

219
00:14:35,392 --> 00:14:38,968
So let's copy that URL. Let's open up a new

220
00:14:39,016 --> 00:14:44,004
terminal and let's curl this thing curl.

221
00:14:45,024 --> 00:14:48,632
There we go. And we get back hello Conf

222
00:14:48,808 --> 00:14:52,592
42. So it's fairly easy to get

223
00:14:52,648 --> 00:14:55,844
started with webassembly using spin.

224
00:14:57,744 --> 00:15:01,374
Let's move back to the slides again.

225
00:15:02,154 --> 00:15:05,570
But I mean, we've seen hello world, right?

226
00:15:05,682 --> 00:15:09,658
So in the next step we will just enhance

227
00:15:09,706 --> 00:15:13,274
it a little bit. But then instead of you

228
00:15:13,314 --> 00:15:16,618
seeing me typing, we will explore a full fledged

229
00:15:16,666 --> 00:15:20,454
crud application and take it from there.

230
00:15:21,354 --> 00:15:25,482
So let's do some hands on, right? So instead

231
00:15:25,538 --> 00:15:29,222
of, you know, let me, let me quickly start the app again.

232
00:15:29,318 --> 00:15:32,518
Let's say spin up. There we go.

233
00:15:32,686 --> 00:15:36,134
So it does not matter what I, you know,

234
00:15:36,214 --> 00:15:39,806
do right here I can do a get

235
00:15:39,870 --> 00:15:43,394
with another path. I can do a post post

236
00:15:45,174 --> 00:15:48,814
over here. I always, I always see

237
00:15:48,854 --> 00:15:52,766
the same result. That's because in

238
00:15:52,790 --> 00:15:56,992
the spin toml we specified that we wanna

239
00:15:57,048 --> 00:16:00,684
listen to all routes, which is good.

240
00:16:01,064 --> 00:16:05,040
However, we just have that simple spin HTTP

241
00:16:05,152 --> 00:16:07,844
handle func over here.

242
00:16:08,584 --> 00:16:12,784
However, the spin SDK allows

243
00:16:12,824 --> 00:16:16,696
us to build more sophisticated apps. So for

244
00:16:16,720 --> 00:16:19,524
example, let's take the router,

245
00:16:20,304 --> 00:16:24,160
which is spin HTTP new router,

246
00:16:24,312 --> 00:16:28,400
and then we can say router get. We want

247
00:16:28,432 --> 00:16:31,648
to listen to a route which

248
00:16:31,736 --> 00:16:35,672
has a parameter, let's call that kind and

249
00:16:35,728 --> 00:16:39,472
we want to handle the get request by

250
00:16:39,528 --> 00:16:42,364
providing a dedicated handle func.

251
00:16:43,224 --> 00:16:47,204
So let's do a func handle get.

252
00:16:47,364 --> 00:16:51,396
And this quickly copied the parameters over there we

253
00:16:51,420 --> 00:16:55,324
get again the response

254
00:16:55,364 --> 00:16:58,708
writer request request. But in addition we get

255
00:16:58,756 --> 00:17:04,384
params which comes from the spin HTTP module.

256
00:17:06,084 --> 00:17:09,620
And finally, so we can register more routes over here.

257
00:17:09,692 --> 00:17:12,638
Register more routes, right,

258
00:17:12,726 --> 00:17:16,654
routes. But ultimately we

259
00:17:16,694 --> 00:17:20,830
must tell the spin or the, because the requests

260
00:17:20,902 --> 00:17:24,194
goes into that handle func, we must forward

261
00:17:24,574 --> 00:17:31,150
it to the router. So we can simply say hey router server,

262
00:17:31,182 --> 00:17:34,994
and we just forward the

263
00:17:35,454 --> 00:17:37,714
response writer and a request.

264
00:17:38,594 --> 00:17:42,162
So taking a look at our get handle get

265
00:17:42,298 --> 00:17:45,378
function, let's quickly come up with

266
00:17:45,426 --> 00:17:49,146
a new type say response model

267
00:17:49,210 --> 00:17:51,854
which is a struct struct.

268
00:17:53,234 --> 00:17:56,866
We have a message string which we want to represent

269
00:17:57,010 --> 00:18:01,054
in JSON as lowercase message.

270
00:18:02,154 --> 00:18:06,158
So what we now want to do is we want to extract

271
00:18:06,306 --> 00:18:10,270
the kind parameter specified in the route over here.

272
00:18:10,462 --> 00:18:14,326
So let's say k

273
00:18:14,430 --> 00:18:18,254
equals params by

274
00:18:18,334 --> 00:18:21,674
name and we say it's kind.

275
00:18:22,374 --> 00:18:26,590
So if the len of k

276
00:18:26,742 --> 00:18:30,102
is zero, then we can use

277
00:18:30,278 --> 00:18:33,854
the other primitives from, from the go

278
00:18:33,894 --> 00:18:37,994
as the standard library, right? We can say HTTP

279
00:18:38,734 --> 00:18:42,594
error and say bad

280
00:18:42,894 --> 00:18:46,574
request request and return

281
00:18:46,654 --> 00:18:50,870
a 400 just be safe.

282
00:18:50,902 --> 00:18:54,550
Or here, however, if we receive a kind,

283
00:18:54,742 --> 00:18:59,024
we want to construct a result which is a response

284
00:18:59,064 --> 00:19:02,560
model instance, and we set the message to

285
00:19:02,632 --> 00:19:06,208
k. So from here,

286
00:19:06,376 --> 00:19:12,032
what do we want to do? Well, we want to return JSON

287
00:19:12,128 --> 00:19:14,640
instead of plain text, which we did before,

288
00:19:14,752 --> 00:19:18,704
right? We can set, we can add a simple header called

289
00:19:18,784 --> 00:19:22,624
content type, set that one to application

290
00:19:22,744 --> 00:19:26,292
JSON. And now we have to take care

291
00:19:26,348 --> 00:19:30,004
about encoding the body right, so we can

292
00:19:30,044 --> 00:19:34,052
create an encoder using JSON

293
00:19:34,188 --> 00:19:38,204
new encoder, new encoder,

294
00:19:38,284 --> 00:19:41,836
forward the I o writer over here

295
00:19:41,940 --> 00:19:45,104
and finally say hey, please go encoder,

296
00:19:45,404 --> 00:19:50,832
encode the result in

297
00:19:50,848 --> 00:19:55,280
the case of any error, if error not

298
00:19:55,312 --> 00:19:59,244
equal nil, we want to HTTP error,

299
00:20:00,824 --> 00:20:04,288
let's say error while

300
00:20:04,456 --> 00:20:08,204
encoding message, payload or

301
00:20:08,624 --> 00:20:12,216
response message. And let's fail

302
00:20:12,280 --> 00:20:16,324
within HTTP 500. Let's return this thing.

303
00:20:16,744 --> 00:20:24,080
Ultimately we wanna keep

304
00:20:24,112 --> 00:20:27,296
it as it is. All right,

305
00:20:27,400 --> 00:20:32,200
so let's quickly double check the implementation. That looks

306
00:20:32,272 --> 00:20:36,096
good. We have used serv HTTP over

307
00:20:36,160 --> 00:20:40,776
here. So let's bring up the terminal and

308
00:20:40,800 --> 00:20:43,912
again cycle through the spin workflow.

309
00:20:43,968 --> 00:20:48,186
So spin new, create the app, spin build to

310
00:20:48,290 --> 00:20:51,866
compile it down to webassembly and then we

311
00:20:51,890 --> 00:20:56,546
will use spin up to run

312
00:20:56,570 --> 00:20:59,814
the app. So spin up, there we go.

313
00:21:00,354 --> 00:21:04,134
And let's clean this thing up and let's do a curl

314
00:21:05,074 --> 00:21:08,778
ix get HTTP.

315
00:21:08,866 --> 00:21:12,034
Oh, have I constructed a response message?

316
00:21:14,934 --> 00:21:18,874
I just put that there. No, I don't want that. Let's change that quickly.

317
00:21:20,654 --> 00:21:24,954
Let's say format as printf hello

318
00:21:26,374 --> 00:21:32,286
conf 42s

319
00:21:32,430 --> 00:21:36,356
like this and provide k as an argument over there.

320
00:21:36,510 --> 00:21:39,992
And let's do quickly. We can also simplify that. So we

321
00:21:40,008 --> 00:21:43,960
can do a spin up build

322
00:21:44,032 --> 00:21:47,720
over here so that compiles the app and immediately starts

323
00:21:47,752 --> 00:21:51,120
it on using spin up so

324
00:21:51,152 --> 00:21:56,884
we can say HTTP localhost 3000

325
00:21:57,464 --> 00:22:01,564
Golang and we get back

326
00:22:02,004 --> 00:22:05,828
JSOn with a message property and its value

327
00:22:05,876 --> 00:22:08,624
set. Hello conf 42 golang.

328
00:22:08,964 --> 00:22:12,540
Great. So just demonstrating

329
00:22:12,612 --> 00:22:16,764
that you can use all the goodness from the Go standard library,

330
00:22:16,884 --> 00:22:19,744
you can also bring in third party dependencies.

331
00:22:20,084 --> 00:22:24,508
And to demonstrate that, let me quickly kill this

332
00:22:24,556 --> 00:22:28,424
one. And let's have a look at the

333
00:22:29,124 --> 00:22:32,824
crud sample that I wrong folder.

334
00:22:35,244 --> 00:22:39,864
Let's have a look at the crud sample crud code dot.

335
00:22:41,364 --> 00:22:45,148
So what do we have over here? So we have a

336
00:22:45,156 --> 00:22:48,668
full fledged crud API which is using

337
00:22:48,756 --> 00:22:53,184
a SQLite database to, you know, for persisting

338
00:22:54,194 --> 00:22:57,674
items that we can manage with that API.

339
00:22:57,834 --> 00:23:01,650
So we have to explicitly grant the permission to that particular

340
00:23:01,762 --> 00:23:05,574
app to use a sQlite database called default.

341
00:23:06,994 --> 00:23:11,170
And if we take a look at the go

342
00:23:11,242 --> 00:23:14,882
module, you can see I used external dependencies over

343
00:23:14,938 --> 00:23:19,322
here like the UUID module from, from Google

344
00:23:19,418 --> 00:23:24,490
and SQL to streamline my

345
00:23:24,562 --> 00:23:28,454
experience when interacting with Sqlite.

346
00:23:29,994 --> 00:23:33,570
So domain go file just takes

347
00:23:33,602 --> 00:23:37,410
the API package that I created

348
00:23:37,442 --> 00:23:41,490
over here. So there you can see that we use

349
00:23:41,562 --> 00:23:45,506
the spin HTTP router to create all the routes that we

350
00:23:45,530 --> 00:23:49,334
need to build full fledged crud API with all

351
00:23:49,374 --> 00:23:53,262
the handlers taking care about HTTP requests

352
00:23:53,318 --> 00:23:57,154
and translating or encoding

353
00:23:57,694 --> 00:24:01,694
maybe structs or slices of structs

354
00:24:01,814 --> 00:24:06,022
into JSON again. So the handlers take care

355
00:24:06,198 --> 00:24:09,594
about validating incoming

356
00:24:10,094 --> 00:24:13,054
messages and producing response responses.

357
00:24:13,874 --> 00:24:18,970
The actual implementation for all the crud APIs

358
00:24:19,042 --> 00:24:22,554
or crud capabilities is encapsulated in the

359
00:24:22,594 --> 00:24:25,866
persistence model over here module over here.

360
00:24:26,010 --> 00:24:29,778
So for example, if we look at creating a new item,

361
00:24:29,946 --> 00:24:33,974
we first create a new random, a new guid,

362
00:24:34,514 --> 00:24:37,794
it's a v four. In that case then

363
00:24:37,874 --> 00:24:41,908
we take the incoming item create

364
00:24:41,996 --> 00:24:45,764
model, right? Because we want to build a robust

365
00:24:45,844 --> 00:24:49,908
API. So we have dedicated models. So upon creating

366
00:24:49,956 --> 00:24:53,772
a new item, users may only specify the name and

367
00:24:53,868 --> 00:24:57,228
a boolean indicating if that particular item is

368
00:24:57,276 --> 00:25:00,624
active or not. However,

369
00:25:01,564 --> 00:25:05,534
in contrast, if you ask for a particular item,

370
00:25:05,684 --> 00:25:09,218
you will also get back an id. But it's our,

371
00:25:09,306 --> 00:25:13,522
let's say business logic, right to roll a new id

372
00:25:13,618 --> 00:25:17,414
for an item. So we take the

373
00:25:18,954 --> 00:25:23,650
incoming payload, we transform

374
00:25:23,802 --> 00:25:27,810
that into an item type and ultimately

375
00:25:27,922 --> 00:25:31,410
we use the spin SDK in the DB

376
00:25:31,522 --> 00:25:34,640
method over a function over here to open

377
00:25:34,712 --> 00:25:37,376
up the SQL lite connection.

378
00:25:37,520 --> 00:25:41,616
And then we use SQlex and say, hey, sql X, here's the

379
00:25:41,640 --> 00:25:45,576
connection. Please let

380
00:25:45,640 --> 00:25:48,896
or simplify or streamline the experience for

381
00:25:48,960 --> 00:25:52,764
interacting with that database in SQlite.

382
00:25:55,024 --> 00:25:59,274
And finally, if things went well, we close the connect,

383
00:25:59,394 --> 00:26:03,466
we defer closing the connection and we execute

384
00:26:03,490 --> 00:26:06,974
the query by providing our SQL statement

385
00:26:07,314 --> 00:26:11,362
and you know, using, providing all those

386
00:26:11,538 --> 00:26:15,098
different values for the different columns

387
00:26:15,146 --> 00:26:18,546
in our table. So the same is for

388
00:26:18,610 --> 00:26:22,570
update. And maybe we can have a look at the, reading the

389
00:26:22,642 --> 00:26:25,872
list of items, read items over there.

390
00:26:26,048 --> 00:26:29,324
So we do a simple query X,

391
00:26:29,984 --> 00:26:35,280
provide a select id name and query

392
00:26:35,432 --> 00:26:39,112
if the item is active or not. And then we use

393
00:26:39,168 --> 00:26:42,576
a struct scan from the SQL X from the

394
00:26:42,600 --> 00:26:46,564
SQL X package to construct

395
00:26:46,904 --> 00:26:50,204
structs from result rows.

396
00:26:51,284 --> 00:26:55,544
All right, how can we run this? So this leads to

397
00:26:56,284 --> 00:26:59,876
the no, first let's run it locally. Come on, let's do

398
00:26:59,900 --> 00:27:04,132
that. So we can do a spin

399
00:27:04,268 --> 00:27:07,940
build over here again that compiles our

400
00:27:08,012 --> 00:27:09,904
code down to webassembly.

401
00:27:12,404 --> 00:27:15,916
There we go. So from here we

402
00:27:15,940 --> 00:27:20,600
can simply run instead of

403
00:27:20,712 --> 00:27:24,336
running it just with spin up. We want to use

404
00:27:24,440 --> 00:27:28,240
our SqLite database and I have created a file called

405
00:27:28,312 --> 00:27:32,432
Migrations SQl which you know, create a table

406
00:27:32,488 --> 00:27:36,524
if not exists and pre populates some items.

407
00:27:37,064 --> 00:27:40,648
So with spin Clr you can simply

408
00:27:40,696 --> 00:27:45,090
say, hey, use that migrationstore file

409
00:27:45,242 --> 00:27:48,674
in order to see the database or to prepare

410
00:27:48,714 --> 00:27:51,374
the database. So let's invoke that.

411
00:27:51,954 --> 00:27:55,594
And as you can see we are running on localhost 3000

412
00:27:55,714 --> 00:27:58,774
and let's, instead of curling everything,

413
00:27:59,434 --> 00:28:04,134
let's simply take a look at localhost

414
00:28:04,794 --> 00:28:08,346
3000 items. And as

415
00:28:08,370 --> 00:28:11,962
you can see, we get better the dog mode which is active,

416
00:28:12,018 --> 00:28:15,746
full self driving capabilities that

417
00:28:15,770 --> 00:28:18,826
are active and sentry mode which is

418
00:28:18,890 --> 00:28:22,986
active as well. So we can take a look at sentry

419
00:28:23,170 --> 00:28:26,654
mode. It's active. Yes. So we can

420
00:28:27,714 --> 00:28:31,626
put, and instead of having

421
00:28:31,690 --> 00:28:35,214
this one activated, we can deactivate it.

422
00:28:35,894 --> 00:28:40,662
We just have to align with the schema which is

423
00:28:40,718 --> 00:28:45,150
that let's send it and let's read

424
00:28:45,182 --> 00:28:49,182
it again. So we say get. Give me

425
00:28:49,238 --> 00:28:52,838
that item again. You see, we get back false.

426
00:28:53,006 --> 00:28:56,294
And finally we can delete sentry mode

427
00:28:56,374 --> 00:29:00,354
from the list of all items we get back and no content.

428
00:29:01,234 --> 00:29:05,026
And we can look for the list of items again

429
00:29:05,130 --> 00:29:08,374
and we expect just two items being returned.

430
00:29:09,194 --> 00:29:12,818
Great. So let's quickly

431
00:29:12,906 --> 00:29:16,530
go back to the slides because we want

432
00:29:16,562 --> 00:29:20,586
to take a look at different contexts for

433
00:29:20,690 --> 00:29:24,894
running solus apps. So besides

434
00:29:25,354 --> 00:29:28,834
using spin cli to run your apps locally,

435
00:29:28,994 --> 00:29:32,786
you can also run those apps in Fermion Cloud,

436
00:29:32,850 --> 00:29:36,426
which is a fully managed cloud following

437
00:29:36,490 --> 00:29:39,970
a no ops pattern that you can use to

438
00:29:40,002 --> 00:29:43,762
run your apps. You can run it on Spincube

439
00:29:43,818 --> 00:29:47,122
which is an open source stack that allows you to

440
00:29:47,178 --> 00:29:50,658
run your spin amp next to your containers

441
00:29:50,706 --> 00:29:54,722
in any Kubernetes cluster. Or if you want

442
00:29:54,738 --> 00:29:59,804
to go high density, then you can also take

443
00:30:00,664 --> 00:30:05,664
Fermion platform for Kubernetes which is our commercial offering that

444
00:30:05,704 --> 00:30:09,600
you can use to run inside of Kubernetes and in a way

445
00:30:09,752 --> 00:30:13,752
denser mode as Spincube allows you to do.

446
00:30:13,928 --> 00:30:18,352
Okay, so let's have a look at Fermion cloud and open

447
00:30:18,408 --> 00:30:21,884
source spincube and let's

448
00:30:21,924 --> 00:30:25,184
move back to versus code for that.

449
00:30:27,004 --> 00:30:31,460
So I have already logged in into Fermi

450
00:30:31,492 --> 00:30:35,284
cloud. So basically that's a spin cloud login

451
00:30:35,324 --> 00:30:38,836
that I already did. But I can simply do a

452
00:30:38,860 --> 00:30:42,740
spin cloud deploy in the folder of the

453
00:30:42,772 --> 00:30:46,900
crud sample. Right? So now the app is packaged

454
00:30:47,012 --> 00:30:51,406
and uploaded to fermion cloud and Fermion

455
00:30:51,430 --> 00:30:55,046
cloud recognizes. Hey, you're using a database called

456
00:30:55,110 --> 00:30:59,006
default. Do you want to use an existing one in your cloud account

457
00:30:59,070 --> 00:31:02,694
or should we create a new one for you? Well, let's go with a new

458
00:31:02,734 --> 00:31:06,670
one. We can provide a name or accept a generated

459
00:31:06,742 --> 00:31:10,718
name which is affectionate melon.

460
00:31:10,846 --> 00:31:14,906
So let's use that one. And within a matter of

461
00:31:14,970 --> 00:31:18,858
seconds both the database is provisioned for

462
00:31:18,906 --> 00:31:22,178
us and the app is deployed into

463
00:31:22,266 --> 00:31:26,234
fermion cloud. There we go. So now

464
00:31:26,274 --> 00:31:29,466
that the app is deployed, we still have to, you know,

465
00:31:29,570 --> 00:31:33,346
provision or create the database and seed

466
00:31:33,410 --> 00:31:37,114
some data. For that you can use spin cloud

467
00:31:37,234 --> 00:31:41,086
SQlite list again to get the list of databases.

468
00:31:41,190 --> 00:31:44,638
And the affectionate melon is still there. So we can

469
00:31:44,686 --> 00:31:48,350
say spin cloud

470
00:31:48,502 --> 00:31:52,158
Sqlite execute database,

471
00:31:52,286 --> 00:31:55,806
provide a name for the database and provide

472
00:31:55,990 --> 00:32:00,954
the file migrations sql

473
00:32:03,334 --> 00:32:07,450
there we go. So we have executed everything.

474
00:32:07,602 --> 00:32:11,794
So we can take

475
00:32:11,874 --> 00:32:16,014
this URL, go back to Postman

476
00:32:18,034 --> 00:32:21,854
and just swap localhost 4000 with that one.

477
00:32:23,714 --> 00:32:27,618
And we should see full self driving and sentry mode being

478
00:32:27,666 --> 00:32:33,414
there. So we can grab sentry mode again and

479
00:32:33,454 --> 00:32:37,114
play around with that one next.

480
00:32:37,614 --> 00:32:41,358
So besides fermion cloud there is spincube.

481
00:32:41,446 --> 00:32:46,286
So let's create like a variable for

482
00:32:46,430 --> 00:32:50,726
representing the image. So we will use an OCI artifact

483
00:32:50,830 --> 00:32:55,622
for distributing our app. So the spin

484
00:32:55,638 --> 00:32:59,344
CLI allows us to do a spin registry push

485
00:32:59,884 --> 00:33:03,420
using our OCI artifact name. In that case

486
00:33:03,452 --> 00:33:07,636
I'm using TTL sh. So basically this

487
00:33:07,780 --> 00:33:11,212
OCi artifact will remain available for 24

488
00:33:11,268 --> 00:33:15,436
hours. And in

489
00:33:15,460 --> 00:33:19,588
my Kubernetes cluster I have a SQL D running.

490
00:33:19,676 --> 00:33:23,276
So let's say get PO

491
00:33:23,380 --> 00:33:26,690
and SVC in the default namespace. And as you can see

492
00:33:26,722 --> 00:33:30,002
there's a SQL D running over there which is

493
00:33:30,058 --> 00:33:33,386
exposed at 8080, right with the

494
00:33:33,410 --> 00:33:38,586
name SQL D. So we can say we

495
00:33:38,610 --> 00:33:42,258
can change the runtime behavior of a spin app by

496
00:33:42,306 --> 00:33:45,002
providing runtime configuration file.

497
00:33:45,178 --> 00:33:48,546
And I said hey, with this config I can tell spin,

498
00:33:48,610 --> 00:33:51,894
hey if you want to use the default SQlite data,

499
00:33:52,484 --> 00:33:56,556
use LibSQL and you can find the database at HTTP

500
00:33:56,620 --> 00:33:59,304
sql D 8080, right?

501
00:33:59,884 --> 00:34:03,464
So we can use spin cube scaffold,

502
00:34:04,684 --> 00:34:08,424
say from the following OCi artifact.

503
00:34:09,004 --> 00:34:13,252
And by the way use the config file called Cube

504
00:34:13,388 --> 00:34:16,956
Toml. So right now we scaffold the

505
00:34:16,980 --> 00:34:20,448
Yaml Kubernetes deployment manifest to standard out.

506
00:34:20,616 --> 00:34:24,288
Because our intention is at this point our

507
00:34:24,336 --> 00:34:28,328
story should end. If you want to deploy your kubernetes workloads

508
00:34:28,376 --> 00:34:31,912
with kubectl, go for it. If you want to build handshots, go for

509
00:34:31,928 --> 00:34:35,352
it. If you want to use Gitops, go for it.

510
00:34:35,528 --> 00:34:39,624
So for demonstration purpose, let's say kget po

511
00:34:39,704 --> 00:34:43,696
again and kget spin app. So there's

512
00:34:43,840 --> 00:34:48,699
nothing in the cluster yet. So let's do the

513
00:34:48,731 --> 00:34:51,983
scaffold and this time we pipe it to kubectl

514
00:34:52,723 --> 00:34:55,383
and apply it immediately. Oops.

515
00:34:55,683 --> 00:34:59,947
Apply, apply f that

516
00:34:59,995 --> 00:35:03,715
one. And you see the spin app has been created.

517
00:35:03,779 --> 00:35:07,715
So if we do get spin up again, we see

518
00:35:07,779 --> 00:35:10,787
the app running in our cluster using

519
00:35:10,875 --> 00:35:13,434
container d shim for spin.

520
00:35:14,014 --> 00:35:17,422
And if we do a kget pod, you see we

521
00:35:17,438 --> 00:35:21,062
have two instances of the Golang crud

522
00:35:21,238 --> 00:35:24,910
running and we also have a service sitting

523
00:35:24,942 --> 00:35:28,446
in front of it, Golang crud over here. So what

524
00:35:28,470 --> 00:35:32,310
we will do next is Kubectl port forward.

525
00:35:32,502 --> 00:35:36,366
There we go. From my local machine port 8080

526
00:35:36,550 --> 00:35:39,104
into the cluster port 80.

527
00:35:39,564 --> 00:35:43,092
There we go. And now let's

528
00:35:43,148 --> 00:35:45,624
go to this one,

529
00:35:46,604 --> 00:35:50,024
get rid of the ID and let's say

530
00:35:50,564 --> 00:35:55,664
HTTP localhost 8080

531
00:35:56,044 --> 00:35:59,624
items. And you see there's just the full

532
00:36:01,364 --> 00:36:05,494
self driving so we can create a new one. Let's go there,

533
00:36:05,574 --> 00:36:08,574
there, let's say name,

534
00:36:08,694 --> 00:36:13,022
oops, name is the dog

535
00:36:13,118 --> 00:36:16,398
mode. And let's say active is

536
00:36:16,486 --> 00:36:17,674
obviously true.

537
00:36:20,974 --> 00:36:26,062
Now there's a column missing over there and

538
00:36:26,118 --> 00:36:29,754
let's hit send and we get back the iD.

539
00:36:30,254 --> 00:36:34,326
But if we just go back and say hey, give me all the items,

540
00:36:34,470 --> 00:36:38,194
we now have two items. And if we go finally

541
00:36:38,654 --> 00:36:42,478
once back to this, we saw two connections have been handled

542
00:36:42,606 --> 00:36:46,554
on localhost 8080 and forwarded to the service

543
00:36:46,854 --> 00:36:48,914
running inside of Kubernetes.

544
00:36:50,134 --> 00:36:51,714
So that being said,

545
00:36:53,734 --> 00:36:57,544
we want to wrap up this thing. So a couple of key

546
00:36:57,584 --> 00:37:01,200
takeaways, right? Webassembly will definitely

547
00:37:01,272 --> 00:37:05,760
change the way we build distributed apps because we

548
00:37:05,792 --> 00:37:09,992
can now build serverless applications in

549
00:37:10,008 --> 00:37:13,112
a reactive manner, right? No matter which language you use,

550
00:37:13,168 --> 00:37:16,512
as long as the language compiles down to Webassembly.

551
00:37:16,688 --> 00:37:20,344
And those apps are way more efficient as

552
00:37:20,424 --> 00:37:22,604
regular containers could be.

553
00:37:24,344 --> 00:37:26,164
So apps are fast,

554
00:37:26,744 --> 00:37:30,600
secure and portable by default. So we can get rid

555
00:37:30,632 --> 00:37:34,456
of, you know, all the pains and pitfalls

556
00:37:34,520 --> 00:37:37,844
that we may have with cross compilation,

557
00:37:38,664 --> 00:37:43,124
Fermion Cloud, Spincube and Fermion platform for Kubernetes

558
00:37:43,784 --> 00:37:46,960
allow us to, you know, run our serverless

559
00:37:47,032 --> 00:37:51,054
apps in different contexts. So maybe you

560
00:37:51,094 --> 00:37:54,638
have already Kubernetes in place then Spintube or Firmin

561
00:37:54,686 --> 00:37:58,262
platform for Kubernetes could be a great fit or great addition

562
00:37:58,358 --> 00:38:01,914
to your overall application landscape.

563
00:38:02,214 --> 00:38:06,034
So you can roll your own serverless platform.

564
00:38:07,494 --> 00:38:11,270
And once again we can use the languages that

565
00:38:11,302 --> 00:38:15,570
we love and know. And obviously we can also bring in

566
00:38:15,682 --> 00:38:19,098
all the goodness that others created to

567
00:38:19,146 --> 00:38:23,130
make that language so successful. With that

568
00:38:23,202 --> 00:38:27,374
being said, thank you very much for joining

569
00:38:27,754 --> 00:38:31,794
me on that journey to build serverless apps

570
00:38:31,834 --> 00:38:35,490
using Webassembly. You can find all the code online on

571
00:38:35,522 --> 00:38:39,394
GitHub. Thank you and enjoy the rest of conference.

