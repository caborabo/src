{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/bb4e8dae-467b-451a-b56f-44e30011dfe1", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["benefits", "circuits", "classiq", "conf fourty two", "director commercial partnerships", "gatebased", "productivity", "program", "programming", "traditional", "vincent van wingerden"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_audio_quality": null, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "speech_model": null, "id": "d54b600e-d7c7-4d2c-93b1-6af6dbf29e50", "status": "completed", "error": null, "text": "My name is Zinfan, and I work at classic today. I want to share a little bit about what classic does. So firstly, who are we? We are a startup based solver world ranging from the US, Europe and Asia. We are roughly with 65 people, and we focus specifically on quantum software, and we serve both commercial companies as well as academia. So let's take a look at what we do. The challenge that we're trying to fit is creating efficient and large scale quantum circuit. If you're familiar with quantum programming, these images are very familiar to you. These represent quantum circuits, which are programs that run on quantum computers. If you aren't that familiar, let me give you a quick walkthrough. In the lines that you see specifically on the image on the left. Those represent qubits or quantum bits, and each of the squares or other shapes on there are operations that you apply on these specific quantum bits. When you apply multiple operations on these quantum bits, eventually you will get a large quantum program, and that is what you want to run on your quantum computer to achieve your specific needs. Well, if we look at the quantum circuit on the left, that is a relatively small circuit with its few operations than just a handful of qubits. This is something that many quantum programmers can just create easily with the tools that we have available today. The tools that we have available today are mostly what we call gate based programming. So that means that you are manually putting all these gates or operations on the circuit board, or you have a larger group of gates that you put on a specific circuit board. If we move up to a little bit larger quantum circuit, the image in the middle, things get a little bit more complex. So you either need a lot more time to create this, and you need a lot more ideas on what specific things that you actually want to create and how you could most efficiently create that functionality in your quantum circuit. If we go to the right, you have a very big quantum program. These quantum programs represent the things that we actually want to do with quantum computer, like quantum chemistry or other extremely nice use cases. The problem is, when you're programming with the current tools, creating such a very large quantum circuit can be very challenging. Not only that is if you create a specific quantum program that doesn't guarantee that the program will run efficiently on each quantum computer. That means that it could run very efficiently on one machine, but very inefficiently on the other. The solution to that currently is that you would have to actually creates two different quantum circuits, one that will run better on one machine and one and the other not only that is once you have more qubits available when the quantum computers become larger, if you want to actually make use of those, you would have to reprogram. Again, that's a very manual task to actually generate these quantum circuits and also to make them very efficient. That is the exact problem or challenge that classic wants to tackle. Instead of writing quantum circuits on a gate level, in classic you write a higher level description of what you want to achieve. This means that you do not have to describe at a low level or gate level how you want to achieve specific functionality, you just write what functionality you want to achieve. It's important to note here that the same functionality can be achieved in various ways on a quantum computer. So that means that you have a lot of freedom to pick how you want to implement it. That also means that if you make a wrong decision, a specific circuit can be less efficient. And this is something that I, our compiler or synthesis engine does for you. So in classic, you write your program, your desired functionality in a higher level programming language, and our compiler makes the decision on how to implement that specific functionality for you on a gate based circuit. The interesting thing is that we do not only take the high level description or program as an input to our compiler, we also take the quantum computer that you want to run on as an input. This means our compiler can inadvertently optimize the quantum circuit for that specific machine. That also means if you want to target a new machine with a different architecture or you have more qubit available, you do not need to reprogram anything. You just tell a compiler that you have a new target. And our compiler will try to make the most efficient use of those extra qubits or the different architecture that you're trying to target. Once you've created your circuit, you can actually analyze the output in our online analyzer. This allows you to see how our compiler has actually implemented your functionality. And finally, when you have your circuit and you're happy with, you can execute it right away from within our platform to any cloud provider that there are ranging from Amazon, Azure, AWS, IBM and more. If you don't know if the provider that you want isn't there, you can simply export the circuits that you have in a chasm file and run it anywhere where you like. This gives you all the flexibility to execute your code everywhere. So let's look at a specific example. In this example, we're going to look at Grover's algorithm. Grover's algorithm is an algorithm for unstructured search, and it can search things quicker than a classical computer could. In this case, we're looking at how to solve a specific mathematical expression. What we see right here is the IDE, which is a web based application of the classic platform. In the middle, you can see our code area, where you can write classics own quantum computer programming language. And on the right, we have a helpful tool that helps you write that code. Specifically for a grow verb search function. Over here, you can input your mathematical equation. And in this case, the equation is relatively simple. A plus b times one, two, or divided by two times c needs to equal ten. The goal of this specific Grover algorithm is to find the values of a, b, and c that satisfy this specific expression. The only thing we need to do is set our expression, which we've done over here. And next to that, we need to set what we like to be. Would we like them to be integers or maybe floats? If they're floats, how many decimal points we want? And do we want them signed or unsigned, for example? Next to that, there's other optimization. How do you want to optimize? Would you like the most shallow as possible circuit, or would you like the least amount of qubit to be used? Once you set this all up, we can create the classic code that you see in the middle. And if you want, you can even change that and add more or take out some functionality that was created for you. Once you're happy, you can press the synthesis, and that will actually generate the quantum circuit for you. And in this case, this is the entire Grover circuit that was created. What I've created here is a circuit with a specific constraint. In this case, I put a constraint 25 qubits, because a simulator I want to run on has a maximum of 25 qubits. Next to that, I have also put an optimization parameter of depth. That means that the synthetic will generate the shallowest as possible cert. And as you can see, all these operations together will generate one big Grover's algorithm, from the initialization of the variable to the grove, oracle, and the diffuser. Now, if we want to execute it, we simply press execute on the top right, and we can run it directly on classic simulator or any other simulator or quantum computer that is out there. And as you can see, when we hover over these bars, you see the right answers that satisfy this specific equation. And as you can see, there's multiple answers possible. The highlighted here is a seven, b three, and then t two, which eventually will satisfy this specific equation. That is how simple it is to create a Grover's algorithm in classic. Imagine having to do all this on a gate based programming that will take you a lot more time. And here it just took me five minutes from the creation all the way to the execution. Now, let's look at some more complex use cases that Classic has dealt with. The first one is an algorithm called HHL. This is an algorithm that pulls linear equations exponentially quicker, and classical methods. Could you. This is very interesting in many different industries, because solving linear equations is a very big challenge in many industries. And being able to write an efficient HTGL algorithm is actually something that can be useful everywhere. Classic allows you to very easily create this algorithm and scale it from very small to very big. This is an example where we used a very big simulator to simulate this enormous algorithm that we have created together with Rollsroyce. Next to that is a financial use case where we're together with an italian bank in testosterone Paulo actually created a new way of pricing specific options called rainbow options. Using Classic, they're able to very quickly implement their new way of pricing these options and actually test whether their method does actually work. And finally, together with another bank, we're using QAOA, an optimization algorithm, to optimize portfolio. And the research that we have done here is what type of parameters for that QAOA algorithm are the most efficient to actually get the best circuit and the ideal portfolio. With that, I want to thank you so much, and I hope you enjoy the rest of the conference.", "words": [], "utterances": null, "confidence": 0.914188731650031, "audio_duration": 730.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- Zinfan: The challenge that we're trying to fit is creating efficient and large scale quantum circuit. Instead of writing quantum circuits on a gate level, in classic you write a higher level description of what you want to achieve. Our compiler can inadvertently optimize the quantum circuit for that specific machine.", "auto_highlights_result": {"status": "success", "results": [{"count": 7, "rank": 0.08, "text": "quantum computer", "timestamps": [{"start": 104842, "end": 106166}, {"start": 178062, "end": 178942}, {"start": 201276, "end": 202544}, {"start": 276430, "end": 277634}, {"start": 323182, "end": 324030}, {"start": 441364, "end": 442748}, {"start": 583262, "end": 583990}]}, {"count": 1, "rank": 0.08, "text": "quantum computer programming language", "timestamps": [{"start": 441364, "end": 444104}]}, {"count": 3, "rank": 0.08, "text": "quantum program", "timestamps": [{"start": 101410, "end": 102962}, {"start": 172422, "end": 173286}, {"start": 195732, "end": 196828}]}, {"count": 2, "rank": 0.08, "text": "specific functionality", "timestamps": [{"start": 264282, "end": 265846}, {"start": 307886, "end": 309934}]}, {"count": 3, "rank": 0.07, "text": "quantum bits", "timestamps": [{"start": 82794, "end": 84254}, {"start": 93642, "end": 94894}, {"start": 97994, "end": 98962}]}, {"count": 7, "rank": 0.07, "text": "quantum circuit", "timestamps": [{"start": 58982, "end": 60594}, {"start": 111158, "end": 112038}, {"start": 148564, "end": 149660}, {"start": 168334, "end": 169634}, {"start": 189564, "end": 190492}, {"start": 332622, "end": 333822}, {"start": 532102, "end": 532982}]}, {"count": 1, "rank": 0.07, "text": "specific options", "timestamps": [{"start": 686496, "end": 687844}]}, {"count": 1, "rank": 0.07, "text": "possible circuit", "timestamps": [{"start": 508382, "end": 509502}]}, {"count": 2, "rank": 0.06, "text": "gate based programming", "timestamps": [{"start": 130958, "end": 132408}, {"start": 614924, "end": 616284}]}, {"count": 1, "rank": 0.06, "text": "efficient and large scale quantum circuit", "timestamps": [{"start": 56342, "end": 60594}]}, {"count": 1, "rank": 0.06, "text": "specific quantum program", "timestamps": [{"start": 195236, "end": 196828}]}, {"count": 1, "rank": 0.06, "text": "quantum programming", "timestamps": [{"start": 62342, "end": 63662}]}, {"count": 1, "rank": 0.06, "text": "specific quantum bits", "timestamps": [{"start": 92802, "end": 94894}]}, {"count": 1, "rank": 0.06, "text": "two different quantum circuits", "timestamps": [{"start": 214108, "end": 216252}]}, {"count": 1, "rank": 0.06, "text": "more qubits", "timestamps": [{"start": 222716, "end": 223308}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}