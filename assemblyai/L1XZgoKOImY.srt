1
00:00:23,800 --> 00:00:27,822
Hello everyone and welcome to Con 42

2
00:00:27,878 --> 00:00:32,038
JavaScript. My name is Gabriel and

3
00:00:32,166 --> 00:00:35,798
although this session recording from

4
00:00:35,846 --> 00:00:39,782
home remotely, I like to travel. This is one of

5
00:00:39,838 --> 00:00:43,510
my hobbies and usually when

6
00:00:43,542 --> 00:00:46,594
I travel I'm using two documents.

7
00:00:47,174 --> 00:00:50,550
The first one is on the left side, my passport,

8
00:00:50,702 --> 00:00:54,038
and the right one is the flight

9
00:00:54,086 --> 00:00:57,158
ticket. And let's talk about the

10
00:00:57,206 --> 00:01:01,214
difference between those documents because

11
00:01:01,374 --> 00:01:04,926
they are probably both allow me to

12
00:01:04,950 --> 00:01:08,430
get on a plane and travel. But I have different

13
00:01:08,542 --> 00:01:11,814
roles. The passport is a form

14
00:01:11,854 --> 00:01:15,686
of my identity. I declare, I verify my

15
00:01:15,710 --> 00:01:18,878
identity with a passport, but I cannot go on

16
00:01:18,886 --> 00:01:22,320
a flight, only with a passport. I need to authorize myself,

17
00:01:22,502 --> 00:01:25,668
myself to a flight. A passport also,

18
00:01:25,796 --> 00:01:29,788
for example, is something that I'm renewing once for

19
00:01:29,836 --> 00:01:33,300
ten years. But flight ticket is something

20
00:01:33,372 --> 00:01:36,516
that I get again and again for every flight

21
00:01:36,580 --> 00:01:40,236
that I'm going to. The details on both

22
00:01:40,300 --> 00:01:44,148
documents are different. One is the details that verify

23
00:01:44,196 --> 00:01:47,532
my identity, like a biometric image,

24
00:01:47,668 --> 00:01:51,172
picture or my birth date.

25
00:01:51,348 --> 00:01:54,732
The other is the particular details that allow me

26
00:01:54,748 --> 00:01:59,836
to go on the flight, like the seat number and

27
00:01:59,980 --> 00:02:03,332
the passport is something I'm using once in

28
00:02:03,348 --> 00:02:07,340
the airport. The flight ticket is something that I'm using again and again.

29
00:02:07,412 --> 00:02:10,364
I'm showing it in the check in, and then I'm showing when I check the

30
00:02:10,444 --> 00:02:14,204
luggage, then in the security, then in the gate. And if

31
00:02:14,244 --> 00:02:17,070
someone start fighting me on my seat,

32
00:02:17,222 --> 00:02:20,790
I'm taking my flight ticket out and telling hey,

33
00:02:20,942 --> 00:02:24,086
one a is my seat, right? So there are

34
00:02:24,110 --> 00:02:27,926
many differences between passport and flight ticket, but what

35
00:02:27,950 --> 00:02:31,870
is matter for JavaScript or software? It's matter

36
00:02:31,942 --> 00:02:35,794
because there are two terms in access control that usually

37
00:02:37,094 --> 00:02:40,714
confuse developer, authentication and authorization.

38
00:02:41,194 --> 00:02:45,082
Access control is a term, is a general term to describe

39
00:02:45,178 --> 00:02:49,218
who allowed access to our application. Every application

40
00:02:49,306 --> 00:02:53,386
has some level of access. It could be node J's applications.

41
00:02:53,450 --> 00:02:56,014
And this is what we are going to talk about today.

42
00:02:56,514 --> 00:02:59,938
Authentication is the step where our users verify

43
00:02:59,986 --> 00:03:03,322
their identity, right? Same as they do in password,

44
00:03:03,498 --> 00:03:06,818
in passport, yeah, they do it with password, but password

45
00:03:06,866 --> 00:03:10,146
is not that safe. So there are features like biometrics,

46
00:03:10,250 --> 00:03:14,226
multifactor authentication. But authentication happened once

47
00:03:14,290 --> 00:03:17,546
and then we maintained session, but authorization,

48
00:03:17,730 --> 00:03:20,810
the determination of the user permissions

49
00:03:20,962 --> 00:03:24,938
to know if a particular user that already authenticated themselves

50
00:03:24,986 --> 00:03:28,450
is authorized to do an action in our software.

51
00:03:28,642 --> 00:03:31,866
It is something that happened again and again

52
00:03:32,050 --> 00:03:35,702
require permission model, right. We need

53
00:03:35,758 --> 00:03:40,046
to understand what a user can or cannot do. It has

54
00:03:40,230 --> 00:03:44,514
evolved much more data than authentication session include.

55
00:03:45,174 --> 00:03:48,606
It's not something to revoke because it exists

56
00:03:48,670 --> 00:03:52,582
or valid only for one time that we are checking for

57
00:03:52,638 --> 00:03:56,566
permissions. So the difference between authentication and

58
00:03:56,590 --> 00:04:00,034
authorization are similar to passport and flight ticket.

59
00:04:00,834 --> 00:04:04,730
But authentication has also many advanced features. It's not

60
00:04:04,762 --> 00:04:07,658
as simple as it seems like multi factor authentication.

61
00:04:07,706 --> 00:04:10,626
We want to make sure that the user that just put a password is the

62
00:04:10,650 --> 00:04:14,250
real user. So we are trying maybe sms or

63
00:04:14,282 --> 00:04:17,898
authentication app. We want also to let user

64
00:04:17,946 --> 00:04:22,322
use their own identity. So we give them like sociology

65
00:04:22,418 --> 00:04:26,250
login with their Google account or GitHub. We might want

66
00:04:26,282 --> 00:04:30,130
to let them use biometric or passwordless mechanism to

67
00:04:30,162 --> 00:04:34,120
authenticate. We also need to manage all our users,

68
00:04:34,232 --> 00:04:38,004
right? We need some identity provider to manage identities.

69
00:04:38,464 --> 00:04:42,160
We also need to manage the sessions, manage the

70
00:04:42,192 --> 00:04:46,584
registration of the user, all the flows, the login flows, the signup flow.

71
00:04:46,744 --> 00:04:51,224
We need to verify account and there are many, many features

72
00:04:51,304 --> 00:04:55,032
in authentication. So authentication is not that

73
00:04:55,088 --> 00:04:58,808
simple, right? But for developers is simple because there are

74
00:04:58,856 --> 00:05:02,672
many, many software as a service providers that

75
00:05:02,728 --> 00:05:07,326
let you feel all that advanced feature as a service.

76
00:05:07,510 --> 00:05:11,150
To implement, for example, clerk into your node J's or

77
00:05:11,182 --> 00:05:14,934
JavaScript app, you need only three lines of

78
00:05:14,974 --> 00:05:18,550
code, four lines of code, and then all the advanced authentication

79
00:05:18,622 --> 00:05:21,494
feature is implemented into your app.

80
00:05:21,654 --> 00:05:25,438
Batting authorization, which is not simple

81
00:05:25,566 --> 00:05:29,688
than authentication. And we will go through it and you'll see that authorization

82
00:05:29,776 --> 00:05:32,564
also require some features,

83
00:05:32,864 --> 00:05:37,008
right? We still work really hard. It's still

84
00:05:37,136 --> 00:05:41,176
the old way of trying to code everything in authorization

85
00:05:41,280 --> 00:05:44,404
ourselves, but burn a lot of time.

86
00:05:44,944 --> 00:05:48,808
My name is Gabriel and today I'm going to talk about

87
00:05:48,976 --> 00:05:53,844
how can we do better authorization in JavaScript application

88
00:05:54,864 --> 00:05:59,050
short about intro about myself I am in

89
00:05:59,082 --> 00:06:02,810
software development for many years, JavaScript considered

90
00:06:02,842 --> 00:06:06,778
as my mother language. Every time that I just need to

91
00:06:06,946 --> 00:06:10,814
sketch something on a paper, I'm doing it in JavaScript.

92
00:06:12,194 --> 00:06:15,242
But I'm also a big fan of front end and

93
00:06:15,338 --> 00:06:18,946
security and this is how I got to everything related to access

94
00:06:19,010 --> 00:06:22,434
control in applications. And now I'm leading the developer

95
00:06:22,474 --> 00:06:25,946
relation in permit IO. Permit IO is a startup that do

96
00:06:26,010 --> 00:06:29,584
authorization as service. And today I'm

97
00:06:29,624 --> 00:06:33,464
going to share with you a lot of learns that I learned along my career

98
00:06:33,544 --> 00:06:36,924
about having better authorization on applications.

99
00:06:37,344 --> 00:06:41,336
But before we dive into authorization, let's try to understand

100
00:06:41,440 --> 00:06:45,728
what happened maybe started ten years ago

101
00:06:45,896 --> 00:06:50,328
that let developers create simplest authentication

102
00:06:50,416 --> 00:06:53,124
using providers like we saw like Ozero.

103
00:06:53,914 --> 00:06:57,098
Two innovations happened a couple of

104
00:06:57,146 --> 00:07:00,250
years ago. The first is Oauth. OAuth is a

105
00:07:00,282 --> 00:07:03,786
protocol that allowed to decouple

106
00:07:03,930 --> 00:07:07,354
the authentication server from any kind of

107
00:07:07,394 --> 00:07:10,706
application. Here we can see in the center API, gateway and

108
00:07:10,730 --> 00:07:14,714
also API services could be any kind of language

109
00:07:14,794 --> 00:07:18,378
or technology for any of them. We can once

110
00:07:18,466 --> 00:07:22,218
connect the authentication server which in their

111
00:07:22,266 --> 00:07:26,258
turn return a token. The base of OAuth is

112
00:07:26,306 --> 00:07:30,698
creating token based authentication instead of managing

113
00:07:30,786 --> 00:07:35,346
sessions. And every time that we need to know if a user authenticated,

114
00:07:35,530 --> 00:07:39,770
we are calling a session directory and check if session exists.

115
00:07:39,922 --> 00:07:43,474
We are using token token that we can validate and we can

116
00:07:43,514 --> 00:07:47,322
do it in a decentralized way. So every application

117
00:07:47,458 --> 00:07:51,218
that need to do authentication can call the OAuth

118
00:07:51,266 --> 00:07:55,018
server to make authentication flow with the user

119
00:07:55,186 --> 00:07:59,194
and then by use token verify the identity

120
00:07:59,234 --> 00:08:03,050
of the user. Another thing that came

121
00:08:03,202 --> 00:08:07,322
to public lately, or maybe it's not lately anymore, it's like

122
00:08:07,418 --> 00:08:10,730
I think already ten years, is JWT JSON

123
00:08:10,802 --> 00:08:14,526
web token. This is a format of token that especially

124
00:08:14,630 --> 00:08:18,014
work well in web that can be verified without

125
00:08:18,134 --> 00:08:22,134
calling the authentication server. So in the architecture we see here,

126
00:08:22,174 --> 00:08:26,206
the user is made the authentication against the OAuth server

127
00:08:26,350 --> 00:08:30,014
and then each API, microservice or application

128
00:08:30,174 --> 00:08:33,566
can probably verify their authentication

129
00:08:33,750 --> 00:08:37,254
with this architecture service provider like cloud service

130
00:08:37,334 --> 00:08:40,966
provider. Or if you are just develop a platform, you can do it

131
00:08:40,990 --> 00:08:44,512
yourself. You can create all of server that,

132
00:08:44,568 --> 00:08:49,200
creating centralized authentication and decentralized authentication

133
00:08:49,272 --> 00:08:53,136
in one and a secure way using JWT.

134
00:08:53,280 --> 00:08:57,024
That's in general the way that all the authentication service

135
00:08:57,104 --> 00:09:00,084
provider works, but always go with authorization.

136
00:09:00,544 --> 00:09:04,080
So the most simple form of authorization is the if statement that

137
00:09:04,112 --> 00:09:07,824
we see here, right? We can ask if a user is

138
00:09:07,864 --> 00:09:11,334
admin and only then allow them to delete something.

139
00:09:11,504 --> 00:09:15,282
It's a fan code because the user delete themselves. We don't want allow

140
00:09:15,338 --> 00:09:18,746
admin delete themselves, but that's a demonstration.

141
00:09:18,850 --> 00:09:21,054
How can we code authorization?

142
00:09:21,634 --> 00:09:24,842
Probably this way is not the smartest way to do.

143
00:09:24,938 --> 00:09:28,842
First, every time we are changing something, we need to change

144
00:09:28,898 --> 00:09:32,578
the code and we involve the code in the logic that we need

145
00:09:32,626 --> 00:09:36,394
to do so. It's also hard to read. So a more clean way

146
00:09:36,434 --> 00:09:39,800
to code authorization is using middleware.

147
00:09:39,922 --> 00:09:43,300
Here we can see an example of express middleware.

148
00:09:43,412 --> 00:09:48,092
It's a piece of JavaScript code for delete

149
00:09:48,188 --> 00:09:51,908
endpoint of a user. And instead of mixing

150
00:09:51,996 --> 00:09:56,064
the business logic of checking if a user is admin with

151
00:09:57,044 --> 00:10:01,100
the function itself, we are taking it out into a middleware.

152
00:10:01,132 --> 00:10:04,356
And then we check if a user can remove something.

153
00:10:04,540 --> 00:10:07,998
This is better than just ask if a user is

154
00:10:08,046 --> 00:10:11,622
admin. But it's not easy because for

155
00:10:11,638 --> 00:10:15,174
example, we need more permission models than just

156
00:10:15,254 --> 00:10:19,366
asking for a user role. We can see here in example that

157
00:10:19,430 --> 00:10:25,078
we need more granular level of permissions

158
00:10:25,206 --> 00:10:28,838
to make sure a user is allowed to do some action.

159
00:10:29,006 --> 00:10:32,222
This level of granularity this level of

160
00:10:32,278 --> 00:10:35,634
granularity, granularity can change. It could be like

161
00:10:35,754 --> 00:10:39,082
role, as we saw in the middle of all required,

162
00:10:39,218 --> 00:10:42,594
but can also be based on attributes of a user

163
00:10:42,714 --> 00:10:45,934
or maybe data from a different service.

164
00:10:46,354 --> 00:10:49,898
Well, data from a different service is also not

165
00:10:49,946 --> 00:10:53,466
that good because sometime is not part of the request

166
00:10:53,530 --> 00:10:56,786
itself. So middlewares,

167
00:10:56,850 --> 00:11:00,298
as we can see in the code here in the right hand side, we are

168
00:11:00,346 --> 00:11:04,242
trying to know what is the tier of the user. This tier of

169
00:11:04,258 --> 00:11:08,506
the user is not something which is part of the request itself.

170
00:11:08,650 --> 00:11:12,586
It's something that we need to go to ask somewhere in the

171
00:11:12,610 --> 00:11:16,410
middle of the business logic. So no matter how

172
00:11:16,482 --> 00:11:20,586
we will make our middleware granular, sometimes we

173
00:11:20,610 --> 00:11:24,634
will have a need where we need to do authorization decision

174
00:11:24,754 --> 00:11:28,498
in the middle of the code, right? I think we already saw

175
00:11:28,546 --> 00:11:32,482
enough code to understand that the way we are coding

176
00:11:32,538 --> 00:11:36,844
authorization, it may be work, but it's not that clean. Because the

177
00:11:36,924 --> 00:11:41,252
requirement of authorization with permissions model with roles,

178
00:11:41,308 --> 00:11:45,020
or maybe more granular permission models and endpoint,

179
00:11:45,092 --> 00:11:48,196
and maybe more granular level of permission enforcement

180
00:11:48,260 --> 00:11:51,628
on endpoint. It's getting complex and complex.

181
00:11:51,756 --> 00:11:55,624
For example, we can see that users getting

182
00:11:56,844 --> 00:12:00,740
decisions that need only for partial

183
00:12:00,812 --> 00:12:04,382
authorization and not for the whole scope of the function.

184
00:12:04,548 --> 00:12:07,898
And this code is getting dirtier and dirtier.

185
00:12:08,066 --> 00:12:12,290
But clean code is not the only problem of the way we are doing authorization

186
00:12:12,402 --> 00:12:15,762
today. Sometimes we need a different

187
00:12:15,858 --> 00:12:19,338
environment with different permissions, right? We do

188
00:12:19,426 --> 00:12:22,994
continuous integration, we want to create tests and we

189
00:12:23,034 --> 00:12:26,722
want maybe the admin in the staging environment to

190
00:12:26,738 --> 00:12:30,174
be allowed to do what super admin allowed in

191
00:12:30,474 --> 00:12:34,146
production. How can we separate these

192
00:12:34,250 --> 00:12:37,858
policies, these permissions between environments?

193
00:12:37,986 --> 00:12:41,130
It's not only staging in production, it could

194
00:12:41,162 --> 00:12:44,894
be different tenant environment, it could be different

195
00:12:46,154 --> 00:12:49,234
customer environment. So as you can see,

196
00:12:49,394 --> 00:12:53,002
having policy or having enforcement

197
00:12:53,098 --> 00:12:57,178
or having decision, mostly, most accurately having decision

198
00:12:57,306 --> 00:13:01,296
of authorization in the code. It's something that can

199
00:13:01,320 --> 00:13:04,044
be complex when your application getting complex.

200
00:13:04,584 --> 00:13:07,872
And also the real fact is we love JavaScript,

201
00:13:07,928 --> 00:13:11,440
but sometimes we need to do a different app, we need to do a

202
00:13:11,552 --> 00:13:15,000
data application. So we are using Python and we want

203
00:13:15,032 --> 00:13:17,936
to keep the same logic across our applications,

204
00:13:18,080 --> 00:13:21,864
across our stack. And also let's

205
00:13:21,904 --> 00:13:25,764
go a bit back to the clean cutting

206
00:13:26,064 --> 00:13:30,284
authorization decision. It's something that could cost performance.

207
00:13:30,704 --> 00:13:33,712
And when we need to debug those performances,

208
00:13:33,808 --> 00:13:37,440
when we need to get the audit of what the

209
00:13:37,472 --> 00:13:40,952
authorization decision does, it's something that

210
00:13:41,128 --> 00:13:44,244
can't get a hell of decision

211
00:13:44,584 --> 00:13:48,360
in case we are doing it in just coding the decision

212
00:13:48,472 --> 00:13:51,004
logic as part of our applications,

213
00:13:51,704 --> 00:13:54,840
right? So the problem of creating

214
00:13:54,912 --> 00:13:58,240
permissions and authorization as part of application is

215
00:13:58,272 --> 00:14:01,606
clear. Let's see from the examples we

216
00:14:01,630 --> 00:14:05,278
saw what we can do to make sure that authorization

217
00:14:05,406 --> 00:14:09,454
service let's say that we are now creating an authorization microservice,

218
00:14:09,494 --> 00:14:13,078
a dedicated one. What it has to be first,

219
00:14:13,246 --> 00:14:16,278
and for the last thing, we want it to be declarative.

220
00:14:16,446 --> 00:14:20,374
The way that we are coding complex imperative code

221
00:14:20,414 --> 00:14:23,678
to get authorization decision, it's something that

222
00:14:23,726 --> 00:14:27,016
hard to read and also hard to manage and audit.

223
00:14:27,190 --> 00:14:30,420
We want it also to be generic,

224
00:14:30,572 --> 00:14:34,436
right? We don't want it to be in a level of roles

225
00:14:34,500 --> 00:14:38,780
or attributes. We want it to have to support

226
00:14:38,932 --> 00:14:41,468
any kind of permission models that we want.

227
00:14:41,596 --> 00:14:45,140
Permission decision could be simple as if his admin,

228
00:14:45,252 --> 00:14:48,692
but could be complex as if his admin and a paid

229
00:14:48,748 --> 00:14:51,704
user and own the document.

230
00:14:52,044 --> 00:14:55,356
We want it also to be unified in one place so we can run

231
00:14:55,380 --> 00:14:59,270
it in multiple application, we can manage it for multiple environments.

232
00:14:59,452 --> 00:15:02,826
We want it to be agnostic to the language that we are using,

233
00:15:03,010 --> 00:15:06,306
and because we want it to be agnostic, we want it to decouple from the

234
00:15:06,330 --> 00:15:10,146
code. So every time we need to change, every time a PM comment wants

235
00:15:10,170 --> 00:15:13,962
us to change authorization decision,

236
00:15:14,138 --> 00:15:17,562
we don't want to change the application code, we want to decouple it.

237
00:15:17,658 --> 00:15:21,490
And we also want it to be easy to audit, because access control

238
00:15:21,562 --> 00:15:25,928
is something that then create very high level security

239
00:15:26,016 --> 00:15:29,456
vulnerabilities. So we really want it to be easy to

240
00:15:29,480 --> 00:15:32,284
audit when we are getting maybe wrong decision.

241
00:15:33,224 --> 00:15:37,184
So what is the way to build this authorization

242
00:15:37,304 --> 00:15:41,280
microservice? So let's start with a simple five

243
00:15:41,352 --> 00:15:45,240
steps. Maybe not simple, but I'll try to make it simple.

244
00:15:45,392 --> 00:15:49,444
The first is model. Before we are doing authorization,

245
00:15:49,944 --> 00:15:52,564
we need to model the permission model.

246
00:15:53,044 --> 00:15:57,164
What do you mean? What does that mean? Authentication is

247
00:15:57,204 --> 00:16:01,124
something that can create out there. We decide who are

248
00:16:01,164 --> 00:16:04,748
giving us identities, we decide how do we authenticate

249
00:16:04,796 --> 00:16:08,524
users. But authorization is something that driven by our

250
00:16:08,604 --> 00:16:13,052
application needs, and hence we need to model what our application

251
00:16:13,108 --> 00:16:16,708
needs. What is the easiest way to model is think

252
00:16:16,756 --> 00:16:20,158
about three principles. In our application, we'll always

253
00:16:20,246 --> 00:16:24,462
have three principles when we want to get a decision, a user

254
00:16:24,638 --> 00:16:27,806
or other principle, maybe a service, an action,

255
00:16:27,950 --> 00:16:31,422
what they want to do, and a resource, the resource that they want to

256
00:16:31,438 --> 00:16:35,342
do on. So for example, a permission decision. Is a

257
00:16:35,358 --> 00:16:38,214
monkey allowed to eat a banana? A monkey is the user,

258
00:16:38,334 --> 00:16:41,942
eat is the action and banana is the resource. Yeah, but in a

259
00:16:41,958 --> 00:16:45,656
real world is of course, if an administrator allowed to

260
00:16:45,680 --> 00:16:48,728
delete a document, or if an admin allowed

261
00:16:48,776 --> 00:16:52,368
to delete a document created today, or if an

262
00:16:52,456 --> 00:16:55,736
admin allowed to delete a

263
00:16:55,760 --> 00:16:59,032
document that they are not owning. Right.

264
00:16:59,088 --> 00:17:02,364
So every authenticate authorization decision

265
00:17:02,784 --> 00:17:06,344
is happening with these three principles. So that help us

266
00:17:06,384 --> 00:17:09,724
to model all our authorization rules.

267
00:17:10,304 --> 00:17:14,440
Second point is the level of authorization applications

268
00:17:14,512 --> 00:17:18,184
stack built usually from let's say UI

269
00:17:18,304 --> 00:17:21,856
or gateway, right. The way that we are exposing to the

270
00:17:21,880 --> 00:17:25,304
user the application logic and

271
00:17:25,384 --> 00:17:29,040
the data itself, the database in application logic,

272
00:17:29,072 --> 00:17:32,392
which is the main part of our code. We want to do enforcement. We want

273
00:17:32,408 --> 00:17:36,408
to have a simple function that get these three principles, user action

274
00:17:36,456 --> 00:17:39,752
and resource and return. True or false. We don't want to do

275
00:17:39,768 --> 00:17:43,104
the decision in the application logic. We want

276
00:17:43,144 --> 00:17:46,944
us to do the logic of the decision in a different service and in

277
00:17:46,984 --> 00:17:50,592
application itself only enforce the permission.

278
00:17:50,768 --> 00:17:54,216
We also sometimes need to do feature toggling in the UI or

279
00:17:54,240 --> 00:17:57,848
the gateway to make sure the user are not

280
00:17:57,896 --> 00:18:01,684
getting the resources or not allowing to do

281
00:18:02,544 --> 00:18:06,376
or to see what they need to see. And we also

282
00:18:06,440 --> 00:18:10,000
sometimes want on the data itself do data filtering. So to not return

283
00:18:10,072 --> 00:18:13,284
the user something that they are not supposed to get.

284
00:18:14,064 --> 00:18:17,936
So we know what is the principles, how this enforcement

285
00:18:18,000 --> 00:18:21,144
function signature should look like accepting these

286
00:18:21,184 --> 00:18:24,232
three principles and returning either data filtering

287
00:18:24,288 --> 00:18:27,600
or true or false result. And then we need to

288
00:18:27,632 --> 00:18:31,152
design a permission model. Why it is important to design a permission

289
00:18:31,208 --> 00:18:35,824
model because that help us to create

290
00:18:35,904 --> 00:18:39,284
a good picture of how the authorization

291
00:18:39,714 --> 00:18:42,970
policies looks in our application. Let's talk

292
00:18:43,002 --> 00:18:46,682
about four common permission model. Why and when

293
00:18:46,738 --> 00:18:50,234
and where use each. First is the access control list.

294
00:18:50,274 --> 00:18:53,570
Access control list is a very old one. I consider it as an end

295
00:18:53,602 --> 00:18:57,850
of life model. It usually used in system and firewalls

296
00:18:57,882 --> 00:19:01,562
and switches, etcetera. It's maintain a list,

297
00:19:01,618 --> 00:19:04,418
long list of users.

298
00:19:04,546 --> 00:19:08,452
And in the list, let's say title is an action

299
00:19:08,508 --> 00:19:11,860
and a resource or only a resource. And the users that

300
00:19:11,892 --> 00:19:15,036
appear in the list are actually the one that allowed to

301
00:19:15,060 --> 00:19:18,436
do something. In this kind of permission

302
00:19:18,500 --> 00:19:22,084
model it's hard to scale because we need to maintain all those lists

303
00:19:22,204 --> 00:19:26,036
and we need to use data that is saved in

304
00:19:26,060 --> 00:19:30,268
the list. If for example, we want to get the role of a user,

305
00:19:30,396 --> 00:19:34,414
or we want to get a decision based on a user that

306
00:19:34,874 --> 00:19:38,466
assigning to some list, but it's not

307
00:19:38,490 --> 00:19:42,002
appearing the list is in a different system. It's really hard.

308
00:19:42,178 --> 00:19:46,014
So ACL is not fit for modern application.

309
00:19:46,714 --> 00:19:50,714
RBaC role based access control is like the generic name

310
00:19:50,754 --> 00:19:54,314
for authorization. Why? Because it's very simple

311
00:19:54,354 --> 00:19:57,994
to assign users roles. We can take a user and tell this

312
00:19:58,034 --> 00:20:01,402
user is admin, this user is a moderator,

313
00:20:01,538 --> 00:20:05,380
and then we can easily assign permissions for particular

314
00:20:05,562 --> 00:20:09,080
resources and actions of these roles,

315
00:20:09,192 --> 00:20:12,992
right? So if we want to give a nice user experience for

316
00:20:13,048 --> 00:20:16,520
our application admin, we will use RBAC because then

317
00:20:16,552 --> 00:20:20,272
we can explain hey, if you want your users to be able

318
00:20:20,328 --> 00:20:24,168
to do a particular action on a resource, just assign

319
00:20:24,216 --> 00:20:28,000
them the role. While RBAC is easy to define and also to

320
00:20:28,032 --> 00:20:31,624
use and audit because every decision we make we can easily get

321
00:20:31,664 --> 00:20:34,536
see hey this got this decision because they enroll.

322
00:20:34,680 --> 00:20:38,162
It's hard to inspect into resource, right? If for example

323
00:20:38,218 --> 00:20:41,962
we want to allow users to do something only on their owned

324
00:20:42,018 --> 00:20:45,810
resources, we don't have the granular level to do

325
00:20:45,842 --> 00:20:49,930
that. Because as we can see here, the granularity of RBAC is

326
00:20:49,962 --> 00:20:53,614
only in the resource level, not in the resource instance level.

327
00:20:54,034 --> 00:20:57,594
Also there is no resource. Also there is scalability

328
00:20:57,674 --> 00:21:01,394
is limited because if we need for example to have more

329
00:21:01,434 --> 00:21:05,346
roles or more granular way on, looking on users is getting

330
00:21:05,410 --> 00:21:08,440
harder. ABAc in the other hand is

331
00:21:08,472 --> 00:21:12,584
the most complex way to model policies yet.

332
00:21:12,664 --> 00:21:16,208
It's important to understand that it might be complex,

333
00:21:16,336 --> 00:21:20,040
but it still let give our users a very easy way to

334
00:21:20,072 --> 00:21:23,760
define policy rules. If you have a way to define policy rules,

335
00:21:23,872 --> 00:21:26,888
then you can take attribute of the users

336
00:21:26,936 --> 00:21:31,144
and the resource, right? In software, everything probably has attributes.

337
00:21:31,224 --> 00:21:35,030
User has attributes like name, role, job description,

338
00:21:35,102 --> 00:21:37,686
address, city, whatever it is,

339
00:21:37,870 --> 00:21:41,806
resources as attributes. And then we can create policy

340
00:21:41,910 --> 00:21:45,510
roles that consider set of attributes together with an

341
00:21:45,542 --> 00:21:49,294
action and decide if a user is allowed or not allowed

342
00:21:49,334 --> 00:21:52,406
to do something. While ABAC is the most

343
00:21:52,510 --> 00:21:55,958
granular policy level, it's hard when

344
00:21:56,046 --> 00:22:00,254
we for example need relationships. So for example, if we think about Google

345
00:22:00,294 --> 00:22:03,890
Drive, Google Drive has account in account,

346
00:22:03,962 --> 00:22:07,618
there are folders, in folders there are documents.

347
00:22:07,786 --> 00:22:11,226
A document is belong to a user, not user,

348
00:22:11,290 --> 00:22:14,826
not because an attribute of a document because it's a part of

349
00:22:14,850 --> 00:22:18,178
a folder. So we need to find a way to

350
00:22:18,226 --> 00:22:21,914
propagate or derive policy rules based

351
00:22:21,954 --> 00:22:25,738
on relationships in applications. So to solve this

352
00:22:25,786 --> 00:22:29,378
level of granularity in resource instances

353
00:22:29,546 --> 00:22:33,402
and derivation of permissions, there is a model called

354
00:22:33,538 --> 00:22:37,450
relationship. By accessing some based access control rebuild

355
00:22:37,562 --> 00:22:41,338
where we can create a graph database

356
00:22:41,466 --> 00:22:45,202
of connections between thing and make our policy

357
00:22:45,298 --> 00:22:48,610
rules based on this graph and say if there is

358
00:22:48,642 --> 00:22:52,394
a tuple a relationship between resources,

359
00:22:52,554 --> 00:22:56,826
then we can take the granular level of resource

360
00:22:56,930 --> 00:23:00,894
instances and create policy rule based on them.

361
00:23:01,294 --> 00:23:04,742
So now we understand the first

362
00:23:04,838 --> 00:23:08,354
point model, our application permission.

363
00:23:08,694 --> 00:23:12,278
We have in mind the model that we need. Maybe it's RBAC,

364
00:23:12,326 --> 00:23:15,502
maybe RBAC with ReBAC, maybe RBAC with ABAC

365
00:23:15,638 --> 00:23:19,958
we understand who are our users, what are our resources

366
00:23:20,046 --> 00:23:22,702
and what are the policy rules that we need to create.

367
00:23:22,798 --> 00:23:25,950
We draw it nicely on a whiteboard and

368
00:23:25,982 --> 00:23:30,386
we want to author it, right? So we want to have like authorization

369
00:23:30,490 --> 00:23:33,482
microservice with all these policy rules.

370
00:23:33,618 --> 00:23:36,754
So one way is of course do it imperative as we

371
00:23:36,794 --> 00:23:40,426
did before, like create code that do

372
00:23:40,450 --> 00:23:43,922
it. But then it means we are coupling ourselves

373
00:23:43,978 --> 00:23:47,226
again to application code. So how about we

374
00:23:47,250 --> 00:23:51,698
can the idea of create contracts

375
00:23:51,786 --> 00:23:55,406
for creating policies, what if for creating,

376
00:23:55,470 --> 00:23:58,478
let's say RBAC policies or RBAC rules,

377
00:23:58,606 --> 00:24:01,734
we have a new language that dedicated for

378
00:24:01,774 --> 00:24:05,574
that. And this is one of the things that I want to introduce

379
00:24:05,614 --> 00:24:09,662
you today. Policy languages. Policy languages is a trend

380
00:24:09,718 --> 00:24:13,382
that coming by for the last years. Every couple of months

381
00:24:13,438 --> 00:24:16,686
you see a new policy language release. This language is not a

382
00:24:16,710 --> 00:24:20,598
real programming language, it's more a configuration language. It's not a language

383
00:24:20,686 --> 00:24:23,790
usually it's not a language that you need to learn from scratch,

384
00:24:23,902 --> 00:24:27,876
but to know how to use that. There are also policy languages

385
00:24:27,940 --> 00:24:31,628
that based on YAML or JSON. So you don't need to learn a

386
00:24:31,636 --> 00:24:35,484
new syntax. Today we are going to talk about, I'm going to

387
00:24:35,524 --> 00:24:39,184
mention three policy language. The first one is the most

388
00:24:40,004 --> 00:24:43,500
famous one, open policy agent. Open policy agent

389
00:24:43,532 --> 00:24:47,444
is a decision engine. Like think about a compiler

390
00:24:47,484 --> 00:24:51,340
that we can run a policy program and get a decision

391
00:24:51,412 --> 00:24:54,742
if it allowed or not. Open policy agent has a language

392
00:24:54,798 --> 00:24:58,006
called Rigo where you can

393
00:24:58,070 --> 00:25:01,670
declare your own policies and then enforce them by

394
00:25:01,702 --> 00:25:04,774
the decision that happened in the open policy agent.

395
00:25:04,934 --> 00:25:08,398
There is also a language called Cder. Cder is a language

396
00:25:08,446 --> 00:25:12,126
released by AWS as an open source. This is the language that we are

397
00:25:12,150 --> 00:25:16,806
going to demonstrate today. And there are type

398
00:25:16,830 --> 00:25:19,950
of languages for OpenFGA, for Google

399
00:25:19,982 --> 00:25:23,346
Zanzibar. Google Zanzibar will not expand on it

400
00:25:23,370 --> 00:25:27,074
too much, but we mentioned relationship based access control.

401
00:25:27,234 --> 00:25:31,306
And sometimes relationship based access control require much

402
00:25:31,370 --> 00:25:35,026
more sophisticated policy

403
00:25:35,130 --> 00:25:38,546
engines for that. So if you need a specific

404
00:25:38,610 --> 00:25:42,442
case of relationship based access control, let's say that you have tons of

405
00:25:42,498 --> 00:25:45,954
resources and instances and millions of users, you might

406
00:25:45,994 --> 00:25:49,346
need this language. But let's dive for the CDer

407
00:25:49,410 --> 00:25:52,952
language. Here we can see, and sorry it looks small in

408
00:25:52,968 --> 00:25:56,924
the left side here we can see three examples

409
00:25:57,624 --> 00:26:00,936
of rules that declared in cedar language.

410
00:26:01,040 --> 00:26:04,160
Let's focus on the one in the middle.

411
00:26:04,272 --> 00:26:07,784
In the middle. So we can see that we are declaring a rule of

412
00:26:07,824 --> 00:26:11,648
permit. Permit means a user is allowed to do

413
00:26:11,696 --> 00:26:14,936
something. And as you can see one of the 9th thing in CDER

414
00:26:15,040 --> 00:26:18,864
is that we are declaring policy with the three principles of

415
00:26:18,904 --> 00:26:22,026
authorization, the user, the action and

416
00:26:22,050 --> 00:26:26,178
the resource. So we say here like an ABAC policy that said,

417
00:26:26,306 --> 00:26:29,562
a user is permitted to do update,

418
00:26:29,618 --> 00:26:33,466
list, create task, update task or delete task on

419
00:26:33,490 --> 00:26:37,194
a resource, any resource or any users only

420
00:26:37,274 --> 00:26:40,778
when this user is one of the resource editors,

421
00:26:40,906 --> 00:26:44,770
right? So see how in what a clean way we can

422
00:26:44,882 --> 00:26:47,764
describe policy rule.

423
00:26:48,464 --> 00:26:52,528
Let's see on the left hand side which is a most sophisticated ABAC

424
00:26:52,576 --> 00:26:56,656
role. And we say if a resource as owner

425
00:26:56,720 --> 00:26:59,960
and the owner is a principal, then we allowed something

426
00:27:00,152 --> 00:27:05,056
in the last side, in the left hand side did a small letters

427
00:27:05,160 --> 00:27:08,640
is a RBAC policy. Like we say, only a user with the role

428
00:27:08,712 --> 00:27:12,032
admin is allowed to do something. Now we can

429
00:27:12,088 --> 00:27:15,664
have one policy repository where we create

430
00:27:15,784 --> 00:27:19,000
all our authorization rules, okay?

431
00:27:19,112 --> 00:27:22,536
And all our application use the same authorization rule.

432
00:27:22,640 --> 00:27:26,232
All what we need to do is call the CDR agent that

433
00:27:26,288 --> 00:27:29,504
loaded with these rules and make

434
00:27:29,544 --> 00:27:33,120
an authorization decisions or authorization enforcement based

435
00:27:33,152 --> 00:27:33,884
on it.

436
00:27:39,344 --> 00:27:42,736
Another option of course is to have your authorization

437
00:27:42,840 --> 00:27:46,752
service with some UI. Here is what we built in permit IO

438
00:27:46,848 --> 00:27:50,758
to manage policies and then you can just let your product

439
00:27:50,846 --> 00:27:54,238
manager or whatever it is to edit the policies

440
00:27:54,366 --> 00:27:57,854
without even knows the code. We are using our

441
00:27:57,894 --> 00:28:00,878
UI to create and configure policies.

442
00:28:01,006 --> 00:28:04,342
And then all this policy is, all these

443
00:28:04,438 --> 00:28:08,574
policies is created or generated as policy, as code.

444
00:28:08,654 --> 00:28:12,430
And then you can use the UI for what easy to

445
00:28:12,462 --> 00:28:16,238
config and use the code for the most invested use

446
00:28:16,286 --> 00:28:20,000
cases. So we understand how we author the

447
00:28:20,032 --> 00:28:23,416
policies, but how we check that these policies is what we

448
00:28:23,440 --> 00:28:27,112
mean. So there are agents. Agent is like

449
00:28:27,168 --> 00:28:30,744
a decision maker where we are passing

450
00:28:30,904 --> 00:28:35,392
three principles, a particular user, an action description

451
00:28:35,488 --> 00:28:38,632
and a resource, or maybe attributes of a resource.

452
00:28:38,728 --> 00:28:42,942
And this agent returning the result. True or false allowed

453
00:28:43,048 --> 00:28:46,626
or not allowed, right? So once

454
00:28:46,690 --> 00:28:50,434
we have an agent, we starting to form

455
00:28:50,594 --> 00:28:54,210
a complete authorization service. We have a

456
00:28:54,402 --> 00:28:57,586
policy repository where we over all the

457
00:28:57,610 --> 00:29:01,322
policy, then we have the agent where we can get the queries

458
00:29:01,458 --> 00:29:05,146
and then what we left is to enforce, right? So we

459
00:29:05,170 --> 00:29:08,954
can enforce it by calling the policy agent.

460
00:29:09,074 --> 00:29:12,378
Here we can see that we are calling the cedar agent in an

461
00:29:12,426 --> 00:29:16,094
HTTP interface. As you can see we are passing the

462
00:29:16,134 --> 00:29:19,614
principal action in a resource from our request

463
00:29:19,734 --> 00:29:23,102
to the seeder agent. And the context is also something

464
00:29:23,158 --> 00:29:27,022
that we can use to expand the data that we are passing

465
00:29:27,158 --> 00:29:30,030
with the policy enforcement request.

466
00:29:30,182 --> 00:29:33,286
And in this case or with this example,

467
00:29:33,430 --> 00:29:37,350
we are not writing the decision logic in our

468
00:29:37,382 --> 00:29:41,544
application anymore. We are keeping our application logic

469
00:29:41,694 --> 00:29:45,020
only in enforcing permission. And think about this is

470
00:29:45,052 --> 00:29:48,468
great. We actually decouple the policy from the code.

471
00:29:48,596 --> 00:29:52,548
We have a unified place for our policy. We can

472
00:29:52,636 --> 00:29:56,620
make it generic to the language because we can do it in a HTTP

473
00:29:56,692 --> 00:30:00,588
API or some other RPC forms. It's easy to audit

474
00:30:00,636 --> 00:30:04,236
because all the decision happen in this agent. So if

475
00:30:04,260 --> 00:30:07,548
we need to audit something, we're just going and see what

476
00:30:07,596 --> 00:30:11,028
happened in the decision and it's declarative. So if

477
00:30:11,076 --> 00:30:14,938
someone want to understand what happened or how our policy

478
00:30:15,066 --> 00:30:18,194
configured, it's easy to see just by

479
00:30:18,234 --> 00:30:21,898
looking at the code. Great right? So we are enforcing

480
00:30:21,946 --> 00:30:25,722
policy. But not only that, there is a nice framework called Castle

481
00:30:25,778 --> 00:30:29,654
for front end where we can load all our

482
00:30:30,914 --> 00:30:34,770
authorization, all our policy decision that

483
00:30:34,802 --> 00:30:38,258
we need for our front end from our SIDAR agent

484
00:30:38,386 --> 00:30:42,416
and then SiDAR agent and then we can in the front end

485
00:30:42,520 --> 00:30:45,616
feature toggle the everything we

486
00:30:45,640 --> 00:30:49,048
need when we need to audit.

487
00:30:49,216 --> 00:30:53,064
It's easy to see because all the seeder agents and

488
00:30:53,104 --> 00:30:57,136
all the policy engine are probably auditing what

489
00:30:57,200 --> 00:31:00,564
happened when we got the authorization decision.

490
00:31:00,944 --> 00:31:04,376
So we understand the framework and let's see in practical how is

491
00:31:04,400 --> 00:31:07,860
that looks like. So let's say that we want

492
00:31:07,892 --> 00:31:11,572
to have now authorization microservice that we can easily use.

493
00:31:11,748 --> 00:31:15,324
So authorization include control plane as we described

494
00:31:15,364 --> 00:31:19,020
where we author the policy and a data plane where

495
00:31:19,052 --> 00:31:23,140
we get the decision and the application when we do the enforcement.

496
00:31:23,252 --> 00:31:26,996
And on the other side the data sources. We need to enrich our

497
00:31:27,060 --> 00:31:30,132
policy with data to make better decision,

498
00:31:30,268 --> 00:31:33,896
right? Policy decision can maybe need

499
00:31:34,040 --> 00:31:36,404
data from external sources.

500
00:31:37,664 --> 00:31:41,816
How we do all that not from scratch. We can use Opal.

501
00:31:41,920 --> 00:31:45,240
Opal is an open source tool that lets you

502
00:31:45,272 --> 00:31:49,888
with one docker compose file spin up in minutes

503
00:31:50,056 --> 00:31:53,888
everything we saw before. Create a complete

504
00:31:53,976 --> 00:31:57,728
microservice that can help

505
00:31:57,776 --> 00:32:00,926
you with do authorization in

506
00:32:00,990 --> 00:32:04,406
all your application using one interface

507
00:32:04,550 --> 00:32:07,670
with audit. Here you can see the QR code. The QR

508
00:32:07,702 --> 00:32:11,510
code will lead you to a GitHub repository of

509
00:32:11,582 --> 00:32:15,390
Opal that actually you can see there everything related

510
00:32:15,462 --> 00:32:18,742
to Opal and how to spin it up. We'll also do a demo soon.

511
00:32:18,878 --> 00:32:22,914
And Opal, as you can see here is a complete authorization

512
00:32:23,454 --> 00:32:26,714
service that you need for all your application.

513
00:32:26,794 --> 00:32:30,674
Opal include Opal client and Opal server. The server is

514
00:32:30,714 --> 00:32:33,738
probably the policy store.

515
00:32:33,866 --> 00:32:37,514
It's actually connected to a git repository where you store

516
00:32:37,554 --> 00:32:41,374
all your policy. You can also separate it to environment and

517
00:32:42,554 --> 00:32:45,930
maybe even applications. Also you configure. You can

518
00:32:45,962 --> 00:32:49,918
configure in Opal what is the sources that your data need.

519
00:32:50,066 --> 00:32:53,934
And then the Opal client is running

520
00:32:54,014 --> 00:32:58,382
as a sidecar in your application or for couple of

521
00:32:58,558 --> 00:33:02,462
four multiple applications. And those applications can

522
00:33:02,518 --> 00:33:06,294
get decisions that based on the logic that exists

523
00:33:06,374 --> 00:33:10,174
in the central part. If you see it hopal, this is actually

524
00:33:10,334 --> 00:33:13,822
giving you the same as JWT and OAuth server

525
00:33:13,918 --> 00:33:17,860
bring to authentication. You have one server to

526
00:33:17,892 --> 00:33:21,436
configure all the policy needed like oo server.

527
00:33:21,540 --> 00:33:24,980
And you have instead of making the calls

528
00:33:25,012 --> 00:33:29,108
to the configuration themselves, you are calling the sidecar like

529
00:33:29,196 --> 00:33:32,612
verifying JWT that sitting close to the application,

530
00:33:32,668 --> 00:33:36,468
maybe even as a binary and making very fast

531
00:33:36,556 --> 00:33:40,076
decision. Now it's a good time for

532
00:33:40,100 --> 00:33:43,660
a demo. So here is the

533
00:33:43,692 --> 00:33:47,440
code that I want to to discuss about. First let's

534
00:33:47,472 --> 00:33:51,284
talk about the Opal docker compose. This repository

535
00:33:51,664 --> 00:33:55,200
is exist on GitHub. I'll share a link later.

536
00:33:55,392 --> 00:34:00,216
And actually

537
00:34:00,400 --> 00:34:04,328
the first part of this repository is Docker compose that has

538
00:34:04,456 --> 00:34:08,016
Opal and also some

539
00:34:08,200 --> 00:34:11,704
infrastructure that we create running it locally.

540
00:34:11,824 --> 00:34:14,536
Let's start from the bottom where we are loading opal.

541
00:34:14,640 --> 00:34:18,560
So we are loading the opal server image. Remember opal server

542
00:34:18,592 --> 00:34:21,648
is actually where we are storing the policy

543
00:34:21,736 --> 00:34:24,952
and configuring the data. So as you can see here,

544
00:34:25,048 --> 00:34:29,144
I'm saying the policies sit in this git repository. This git

545
00:34:29,184 --> 00:34:32,888
repository is actually a mock repository that I'm launching

546
00:34:32,936 --> 00:34:36,112
in another docker container here. And I also

547
00:34:36,168 --> 00:34:39,840
say I need data from external resources. This external resource

548
00:34:39,872 --> 00:34:45,164
can be let's say your CRM system

549
00:34:45,244 --> 00:34:49,324
or CRM service. Also here I'm just mocking it

550
00:34:49,364 --> 00:34:52,892
from a Nginx server but I'm configuring

551
00:34:52,988 --> 00:34:56,772
the policy configuration and then I spin

552
00:34:56,828 --> 00:35:00,556
up the opal client, the decision agent. I actually wrap the

553
00:35:00,580 --> 00:35:03,996
see their agent with the opal client. The nice thing is

554
00:35:04,020 --> 00:35:07,608
that in production you can scale this opal client again

555
00:35:07,656 --> 00:35:11,456
and again for every application that you need and you will always

556
00:35:11,640 --> 00:35:15,152
get the same decision. Let's see now

557
00:35:15,208 --> 00:35:19,368
how our applications looks like. So I have your simple

558
00:35:19,416 --> 00:35:23,000
node application. This application has route

559
00:35:23,072 --> 00:35:26,968
for like let's say a blog. There is article we can create,

560
00:35:27,056 --> 00:35:30,472
article we can update, we can get it, we can delete it.

561
00:35:30,648 --> 00:35:34,136
And we have a middleware, but different than

562
00:35:34,160 --> 00:35:38,104
a middleware that we saw in the beginning that can dart our code.

563
00:35:38,224 --> 00:35:41,950
This middleware actually always do the same logic.

564
00:35:42,102 --> 00:35:46,166
No matter how complex is the decision, we need to do it

565
00:35:46,230 --> 00:35:49,406
only enforce it by these three principles.

566
00:35:49,550 --> 00:35:53,350
Right? So we can see, we call the opal client that

567
00:35:53,462 --> 00:35:56,934
actually is the cedar agent. And even if we

568
00:35:56,974 --> 00:36:00,270
for example need to do this authorization in the middle

569
00:36:00,302 --> 00:36:04,166
of the code, we are not dirtying the business logic.

570
00:36:04,230 --> 00:36:08,414
We are just doing the same authorization function

571
00:36:08,494 --> 00:36:12,286
again and again. So let's see how it is work.

572
00:36:12,390 --> 00:36:16,230
So I already run Opal here. Opal is getting the

573
00:36:16,422 --> 00:36:19,606
git. As you can see here is pulling the git,

574
00:36:19,790 --> 00:36:23,126
the policy git from our repository and

575
00:36:23,150 --> 00:36:26,910
let's see how our rules looks like. So here is the folder

576
00:36:26,942 --> 00:36:30,246
of the policy. First we have an admin policy.

577
00:36:30,430 --> 00:36:33,710
The admin policy said that every user with the

578
00:36:33,742 --> 00:36:37,538
role admin actually can do

579
00:36:37,586 --> 00:36:41,466
anything on the system. The user policy said

580
00:36:41,650 --> 00:36:44,554
that a user can do only get right?

581
00:36:44,634 --> 00:36:47,970
Think about it like anonymous user. So a user

582
00:36:48,122 --> 00:36:51,730
with no role can do only the

583
00:36:51,762 --> 00:36:55,134
get action writer can do

584
00:36:55,594 --> 00:36:59,914
more more actions than that. For example,

585
00:36:59,954 --> 00:37:03,584
a writer can do post and put.

586
00:37:04,684 --> 00:37:09,196
Of course it will also derive the user attributes

587
00:37:09,340 --> 00:37:13,996
and writer can also post and put permissions.

588
00:37:14,140 --> 00:37:17,276
Now I already ran this node js application.

589
00:37:17,420 --> 00:37:21,224
Let's try to do something in a user.

590
00:37:24,044 --> 00:37:27,740
So I'm trying here to post an article as a

591
00:37:27,772 --> 00:37:31,694
user. And as you can imagine, I'll not be able to do that access

592
00:37:31,774 --> 00:37:35,766
denied. But what happened if I'll try to do the same

593
00:37:35,830 --> 00:37:37,154
one as a writer?

594
00:37:38,054 --> 00:37:41,326
Okay, so here I'm still doing

595
00:37:41,390 --> 00:37:45,230
the I'm doing as a writer. I can

596
00:37:45,262 --> 00:37:48,462
see that the article created,

597
00:37:48,598 --> 00:37:52,126
right? So all the decision happened not in

598
00:37:52,150 --> 00:37:55,074
the application happened. As a result,

599
00:37:55,484 --> 00:37:59,064
the policy seeder of the cedar policy.

600
00:37:59,404 --> 00:38:02,780
The nice thing is that if I want to change

601
00:38:02,852 --> 00:38:06,948
my policy, so for example, I want now to do a bank,

602
00:38:07,116 --> 00:38:10,404
okay, I want to the writer, I want them

603
00:38:10,444 --> 00:38:13,692
to be allowed to write article and

604
00:38:13,748 --> 00:38:17,124
publish it immediately. Only let's say they

605
00:38:17,164 --> 00:38:20,828
are senior in the system. If they have like lot of

606
00:38:20,876 --> 00:38:23,556
karma. If they don't have this karma,

607
00:38:23,700 --> 00:38:27,060
I don't want them to do the opera

608
00:38:27,092 --> 00:38:31,132
to be allowed to publish published articles.

609
00:38:31,268 --> 00:38:35,116
So in a traditional way I should

610
00:38:35,260 --> 00:38:38,876
go to my application and write

611
00:38:38,940 --> 00:38:42,428
this policy logic in a policy as code way.

612
00:38:42,556 --> 00:38:46,620
I'm just having to change the policy here.

613
00:38:46,652 --> 00:38:50,370
So as you can see a limit the permission.

614
00:38:50,522 --> 00:38:54,730
I limit the permission to do post and put of writers

615
00:38:54,842 --> 00:38:57,946
into writers with more than thousand karma.

616
00:38:58,090 --> 00:39:01,634
But that's valid only if the

617
00:39:01,674 --> 00:39:05,098
article is published. If the article is not published,

618
00:39:05,226 --> 00:39:08,906
I'm still allowed them to do it. Okay,

619
00:39:09,050 --> 00:39:12,746
where this karma getting from? So if you remember we

620
00:39:12,770 --> 00:39:15,826
have here this data JSON, this data JSON.

621
00:39:15,890 --> 00:39:19,634
Think about it as a identity provider, which is

622
00:39:19,674 --> 00:39:23,234
something also that we are connecting to the authorization microservice.

623
00:39:23,354 --> 00:39:26,866
So the admin will be allowed to do everything. It's not part of the

624
00:39:26,890 --> 00:39:30,362
ABAC, but the writer, the senior

625
00:39:30,498 --> 00:39:34,250
writer will be able to do the publish.

626
00:39:34,322 --> 00:39:37,658
True because he had more karma than the writer that

627
00:39:37,706 --> 00:39:41,550
has only 800 karma. Now we change

628
00:39:41,622 --> 00:39:45,582
the writer cedar file and what we need to do

629
00:39:45,758 --> 00:39:48,982
is just commit this file

630
00:39:49,118 --> 00:39:53,674
into the git repository, right? Let's do this way git

631
00:39:53,974 --> 00:39:58,566
commit m

632
00:39:58,750 --> 00:40:02,886
a back policy. Now I committed

633
00:40:02,910 --> 00:40:06,434
the file and as you can see here the

634
00:40:07,174 --> 00:40:10,754
soon the opal will get an update

635
00:40:12,164 --> 00:40:19,452
that a new change is happened to

636
00:40:19,468 --> 00:40:23,348
the policy as code. Soon we can see that

637
00:40:23,516 --> 00:40:26,956
it takes a bit of time to update sometimes, but it's

638
00:40:26,980 --> 00:40:31,060
still really fast because you don't need all the software development CI

639
00:40:31,092 --> 00:40:34,476
CD to make it. And as you can see here it got a

640
00:40:34,500 --> 00:40:37,324
notification of a new policy that updated.

641
00:40:37,704 --> 00:40:41,484
If I'll try now to do this call

642
00:40:41,784 --> 00:40:45,480
in the same of writer, what will happen? The access will be

643
00:40:45,512 --> 00:40:49,480
denied because this writer has not enough karma.

644
00:40:49,632 --> 00:40:53,296
But if I'll do the same but for with the

645
00:40:53,360 --> 00:40:59,104
senior writer user the

646
00:40:59,144 --> 00:41:03,096
article will create it. It's amazing. I haven't changed

647
00:41:03,200 --> 00:41:06,614
any kind of user data or any kind of

648
00:41:06,654 --> 00:41:10,438
application code and the authorization microservice

649
00:41:10,486 --> 00:41:14,038
did everything for me. And also remember there are not much

650
00:41:14,086 --> 00:41:18,206
than just implement like the Opal SDK

651
00:41:18,390 --> 00:41:22,286
application. And one of the most amazing thing I

652
00:41:22,310 --> 00:41:25,754
also have here a Python application

653
00:41:26,134 --> 00:41:29,806
that actually consume the exact same

654
00:41:29,950 --> 00:41:33,884
authorization service. So we can take one

655
00:41:33,924 --> 00:41:37,940
authorization microservice and ship everything

656
00:41:38,132 --> 00:41:41,940
into all of our application.

657
00:41:42,132 --> 00:41:45,796
Isn't that amazing? So Opal probably can

658
00:41:45,860 --> 00:41:49,628
help you reach in open source everything you

659
00:41:49,676 --> 00:41:53,500
have with authentication provider for authorization

660
00:41:53,692 --> 00:41:57,380
using policy as code and in the most advanced way

661
00:41:57,412 --> 00:42:01,250
you can see permit IO. In the other end is

662
00:42:01,322 --> 00:42:04,054
the commercial tool on top of Opal.

663
00:42:04,634 --> 00:42:08,290
I'll not stick on it too because as I say, it's a commercial tool

664
00:42:08,322 --> 00:42:11,394
but I'm really inviting you to try it.

665
00:42:11,474 --> 00:42:14,826
It has also the option to edit all the

666
00:42:14,850 --> 00:42:18,450
policies in the UI and scale it and store

667
00:42:18,482 --> 00:42:21,762
it and much more feature than Opal offer.

668
00:42:21,938 --> 00:42:25,580
But to start Opal is definitely enough and

669
00:42:25,692 --> 00:42:29,196
I really want to ask you to give

670
00:42:29,220 --> 00:42:32,356
a star for Opal. Opal is an open source so

671
00:42:32,500 --> 00:42:36,260
you can support also in contribution. But the first basic support

672
00:42:36,332 --> 00:42:39,476
for open source is of course giving it a start,

673
00:42:39,660 --> 00:42:43,356
giving our more power to continue maintaining it, to continue

674
00:42:43,540 --> 00:42:47,324
the way for a better access control for

675
00:42:47,444 --> 00:42:51,044
all the applications out there. Thank you very much.

