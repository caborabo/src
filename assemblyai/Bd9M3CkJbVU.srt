1
00:00:24,570 --> 00:00:28,070
Good morning, good afternoon, good evening folks.

2
00:00:28,490 --> 00:00:31,986
Thank you for listening to me. My name is Gaurav.

3
00:00:32,098 --> 00:00:34,310
I am the director of engineering.

4
00:00:35,290 --> 00:00:39,510
I worked in a lot of New York City based companies and

5
00:00:39,580 --> 00:00:43,414
thank you for joining me for my talk on scalability on

6
00:00:43,452 --> 00:00:47,142
AWS. More specifically scalability and cloud

7
00:00:47,196 --> 00:00:50,654
native architecture on AWS. Now, I know I'm trying to hit

8
00:00:50,692 --> 00:00:53,966
as many buzzwords as possible, but I'm going to

9
00:00:53,988 --> 00:00:57,674
try to keep this talk at more or less a beginner to intermediate

10
00:00:57,722 --> 00:01:01,402
level. So I'm going to try to get as much into the basics

11
00:01:01,466 --> 00:01:04,594
as possible and hopefully if you like it, if you are interested,

12
00:01:04,712 --> 00:01:08,178
you can then move on and search for some

13
00:01:08,184 --> 00:01:11,890
of the online literature to get into more advanced topics.

14
00:01:12,310 --> 00:01:16,290
So without further delay, I'm going to start off by

15
00:01:16,360 --> 00:01:19,606
talking about the structure of how this presentation is going to

16
00:01:19,628 --> 00:01:22,120
unfold. To begin with,

17
00:01:23,130 --> 00:01:26,342
of course I'm going to give you an introduction. I'll talk about who I am,

18
00:01:26,396 --> 00:01:30,266
what I do for a living, and as I've said, I am

19
00:01:30,288 --> 00:01:34,294
an architect. I'll talk about why you might want to have an architect

20
00:01:34,342 --> 00:01:38,586
in your company. This is again, you can think about it

21
00:01:38,768 --> 00:01:41,370
as advertising for my profession.

22
00:01:42,110 --> 00:01:46,170
I will then, because this talk is more specific about scalability,

23
00:01:46,250 --> 00:01:50,314
I will talk about the problem that currently exists in all the businesses

24
00:01:50,362 --> 00:01:53,694
that I have worked with as an architect. What is it that

25
00:01:53,732 --> 00:01:57,090
causes you to start looking for scalability AWS? A solution?

26
00:01:58,070 --> 00:02:01,886
I will then talk about what it is that scalability exactly tries

27
00:02:01,918 --> 00:02:05,474
to solve. What does a focus on scalability give you?

28
00:02:05,672 --> 00:02:09,414
And then I will talk about how focusing on scalability can

29
00:02:09,452 --> 00:02:12,550
solve the problem that currently exists in the industry.

30
00:02:12,890 --> 00:02:16,726
Now this is very abstract, so I would like to also go into some

31
00:02:16,748 --> 00:02:20,694
of the tools that AWS gives you in order to make your application more

32
00:02:20,732 --> 00:02:23,878
scalable. As with any architecture,

33
00:02:23,974 --> 00:02:27,226
there's always a pro and a con. There's always a trade off.

34
00:02:27,248 --> 00:02:30,106
So I'll talk about some of the trade offs that you'll have to make in

35
00:02:30,128 --> 00:02:33,962
order to make your application scalable on AWS.

36
00:02:34,106 --> 00:02:37,246
And then I'll talk about some of the metrics that you

37
00:02:37,268 --> 00:02:41,486
can use to decide how much you want to give up in order to

38
00:02:41,508 --> 00:02:44,846
have a more scalable application. Then I will

39
00:02:44,868 --> 00:02:47,762
go into some of the best practices that you can follow.

40
00:02:47,816 --> 00:02:51,346
What are the rules of thumb that you can follow in order to design your

41
00:02:51,368 --> 00:02:54,606
system so that you can make the right trade offs

42
00:02:54,638 --> 00:02:57,926
and make the right choices for your application from a

43
00:02:57,948 --> 00:03:01,286
more scalability perspective? And finally,

44
00:03:01,468 --> 00:03:05,730
I am aware of the fact that people have short attention spans

45
00:03:05,890 --> 00:03:10,258
in these days of TikTok and all. So I'll

46
00:03:10,274 --> 00:03:13,994
give you a cheat sheet, a TLDR, if I may, where I will

47
00:03:14,032 --> 00:03:17,546
talk about just two things that if you were to miss the

48
00:03:17,568 --> 00:03:20,762
entire presentation, what are the two things that I would like you to walk away

49
00:03:20,816 --> 00:03:23,774
with that I would think you would benefit from?

50
00:03:23,892 --> 00:03:26,606
And these might be things that you already know or may not,

51
00:03:26,708 --> 00:03:30,586
but I would like to reiterate those things. And throughout

52
00:03:30,618 --> 00:03:34,474
the presentation, I would like to weave business outcomes with security

53
00:03:34,612 --> 00:03:38,654
and technology. So it won't just be a very technical presentation.

54
00:03:38,702 --> 00:03:41,860
I will try to make it as business value focused as possible.

55
00:03:42,390 --> 00:03:45,278
One last structural point. Throughout the presentation,

56
00:03:45,454 --> 00:03:48,974
I will have this question at the bottom left corner

57
00:03:49,022 --> 00:03:52,294
of the screen. This will be the question that I'm trying

58
00:03:52,332 --> 00:03:55,846
to answer while I'm going through each and every slide. So if you think

59
00:03:55,868 --> 00:03:59,414
that I'm rambling too much on a particular slide, or if youll think,

60
00:03:59,532 --> 00:04:03,242
what exactly is he trying to say, hopefully looking at this

61
00:04:03,296 --> 00:04:06,554
question will make you reorient and try to kind of

62
00:04:06,592 --> 00:04:09,926
figure out what it is that I want you to take away from the slide,

63
00:04:09,958 --> 00:04:13,706
and I'll try to have at least just one takeaway from each slide.

64
00:04:13,898 --> 00:04:17,966
So with that said, again, as I said, I'm the author of the book

65
00:04:18,068 --> 00:04:21,994
Security and Microservice Architecture on AWS. It's an O'Reilly

66
00:04:22,042 --> 00:04:25,386
media publication from 2021.

67
00:04:25,428 --> 00:04:29,570
So if you want, please do grab a copy. It's available

68
00:04:29,640 --> 00:04:33,214
on Amazon by the day. I work as a director of engineering,

69
00:04:33,262 --> 00:04:36,718
sometimes as an architect, as a consultant in various companies,

70
00:04:36,824 --> 00:04:40,246
and I've worked in a lot of companies throughout my career in

71
00:04:40,268 --> 00:04:43,702
New York City. So please do find me

72
00:04:43,756 --> 00:04:47,822
on LinkedIn at night. I work as a research scholar

73
00:04:47,906 --> 00:04:52,250
and a doctoral student at University of

74
00:04:52,400 --> 00:04:55,542
Rutgers. So my thesis

75
00:04:55,606 --> 00:04:59,098
is on international business, on corruption and international business,

76
00:04:59,184 --> 00:05:02,734
something that I'm very passionate about. So do feel

77
00:05:02,772 --> 00:05:06,666
free to follow some of my work. Just apart

78
00:05:06,698 --> 00:05:10,106
from that, I have an MBA from NYU Stern

79
00:05:10,138 --> 00:05:14,042
School of Business in finance. So I try to merge finance

80
00:05:14,106 --> 00:05:17,326
into any tech related talk, any tech related discussion

81
00:05:17,358 --> 00:05:20,626
I have. That's just something that I like to do. And I

82
00:05:20,648 --> 00:05:24,398
also have a master of Science from Rochester Institute of Technology in AI.

83
00:05:24,494 --> 00:05:27,702
This was before the whole AI hype, so somehow I managed to be

84
00:05:27,756 --> 00:05:31,506
ahead of the curve there another structural

85
00:05:31,538 --> 00:05:35,062
part of the presentation. Throughout the presentation, I like to keep my

86
00:05:35,116 --> 00:05:38,694
examples consistent. That way I don't have to go

87
00:05:38,732 --> 00:05:42,058
back and explain what the setting is. So in this particular

88
00:05:42,144 --> 00:05:45,814
case, the setting that I would like to use is that of an ecommerce

89
00:05:45,862 --> 00:05:49,526
website. So you can assume that throughout

90
00:05:49,558 --> 00:05:53,594
this presentation I run a company that has an ecommerce

91
00:05:53,642 --> 00:05:56,240
website and this website,

92
00:05:57,730 --> 00:06:01,758
it gives you the ability to search for products. So you can search it

93
00:06:01,924 --> 00:06:05,358
by using simple keywords like I want sunglasses. Or you can

94
00:06:05,364 --> 00:06:09,006
have an advanced search there where you can say, okay, I want to find sunglasses

95
00:06:09,038 --> 00:06:12,306
which cost between $5 and $15 and have

96
00:06:12,328 --> 00:06:16,318
a rating of four stars and above. So that's

97
00:06:16,334 --> 00:06:20,054
the kind of website that you can assume I'm running. And any

98
00:06:20,092 --> 00:06:23,654
example that I want to give related to scalability would be

99
00:06:23,692 --> 00:06:27,382
pertaining to this website. So you can think about

100
00:06:27,516 --> 00:06:30,970
that. That way we are all on the same page when it comes to

101
00:06:31,120 --> 00:06:34,970
examples. Of course

102
00:06:35,120 --> 00:06:39,066
you can run wild on how this application is running, but you

103
00:06:39,088 --> 00:06:42,078
can just assume that the problem that I'm trying to solve is I want to

104
00:06:42,084 --> 00:06:46,346
make this application more scalability for all the different use cases

105
00:06:46,458 --> 00:06:49,680
that my end users are going to use this application for.

106
00:06:50,130 --> 00:06:53,842
With that said, and with that background, I like to go into,

107
00:06:53,896 --> 00:06:57,390
first of all, architecture. What exactly is architecture?

108
00:06:57,550 --> 00:07:01,074
So anytime I look at a software, I look at

109
00:07:01,192 --> 00:07:04,882
six different aspects of a software, I always think that

110
00:07:04,936 --> 00:07:08,370
these are the six points

111
00:07:08,440 --> 00:07:11,894
that I want to focus on. I feel an application,

112
00:07:12,092 --> 00:07:15,398
in our case the ecommerce website, has to be efficient. I don't want to

113
00:07:15,404 --> 00:07:19,334
pay money to a cloud provider or whatever for an inefficient

114
00:07:19,382 --> 00:07:19,980
system.

115
00:07:23,070 --> 00:07:26,266
I want to extract as much juice as I can out of the code that

116
00:07:26,288 --> 00:07:29,782
runs on this application. I want it to be scalable.

117
00:07:29,846 --> 00:07:33,626
Again, this is the whole point of the talk. So anytime I add a server

118
00:07:33,658 --> 00:07:37,486
to the mix, anytime the number of requests jump up,

119
00:07:37,588 --> 00:07:41,118
I need to be able to increase the amount of servers that

120
00:07:41,124 --> 00:07:44,906
I have, the resources that I have, and handle the

121
00:07:45,028 --> 00:07:48,866
new load that my application gets. So if my application is

122
00:07:48,888 --> 00:07:52,754
an overnight success, I don't want to send people back saying like

123
00:07:52,792 --> 00:07:56,146
hey, I know youll visited my website, I know you wanted to

124
00:07:56,168 --> 00:07:59,878
buy it, but we just don't know how to handle so many requests at

125
00:07:59,884 --> 00:08:03,846
the same time. I might want my application to be available all the

126
00:08:03,868 --> 00:08:07,366
time. I don't want any downtime. I don't want it to be going down

127
00:08:07,388 --> 00:08:11,306
at 11:00 at night because of some network latency or

128
00:08:11,328 --> 00:08:15,322
something like that. I want my application to be secure. Security is

129
00:08:15,376 --> 00:08:19,514
important in the day of cyber attacks and everything. I don't want

130
00:08:19,712 --> 00:08:23,840
one malware to infect the entire application and bring everything down.

131
00:08:24,450 --> 00:08:28,270
Of course I might be running some kind of a venture backed application.

132
00:08:28,420 --> 00:08:32,074
So I want it to be as cost efficient

133
00:08:32,122 --> 00:08:35,886
as possible so I don't have to pay money and convince

134
00:08:35,918 --> 00:08:39,266
my investors that I can handle the cost aspect of it.

135
00:08:39,448 --> 00:08:42,802
And finally, I want my application to be simple. A simple

136
00:08:42,856 --> 00:08:46,194
application is easier to maintain. I can hire more

137
00:08:46,232 --> 00:08:50,418
efficiently after hiring, people can get onboarded more easily,

138
00:08:50,514 --> 00:08:53,606
I can document it better, and I can expand it

139
00:08:53,628 --> 00:08:56,840
in a better way. So I want all of these things.

140
00:08:57,470 --> 00:09:00,826
And this is where I realized that I

141
00:09:00,848 --> 00:09:04,554
can't have all of them in my life. I've realized you

142
00:09:04,592 --> 00:09:08,314
have to pick at the most four of

143
00:09:08,352 --> 00:09:11,998
these six points, if not three.

144
00:09:12,084 --> 00:09:15,200
Sometimes you might just get one or two even.

145
00:09:15,570 --> 00:09:18,858
And that's where you need an architect.

146
00:09:18,954 --> 00:09:21,934
An architect is someone that can come in and say,

147
00:09:21,972 --> 00:09:25,266
okay, these are the things that you need to focus on.

148
00:09:25,448 --> 00:09:28,898
These are some of the points that you can give up, some of your

149
00:09:29,064 --> 00:09:32,514
needs, and this is how your application will

150
00:09:32,552 --> 00:09:36,274
be most efficiently running for

151
00:09:36,472 --> 00:09:40,150
the scale and the level of growth that your business expects.

152
00:09:40,570 --> 00:09:44,166
And that's the whole point of this talk. The whole point of

153
00:09:44,188 --> 00:09:48,386
the talk is to look at every application from an architect's

154
00:09:48,418 --> 00:09:51,554
perspective, figure out how to make trade

155
00:09:51,602 --> 00:09:55,114
offs, where to make trade offs, and what are the

156
00:09:55,152 --> 00:09:58,540
factors that will decide where these trade offs should be made.

157
00:09:58,990 --> 00:10:02,570
What are the tools that are available to you

158
00:10:02,640 --> 00:10:05,966
in order to make these trade offs. So one of the tools that I

159
00:10:05,988 --> 00:10:09,882
always like to begin talking about is the AWS shared responsibility

160
00:10:09,946 --> 00:10:13,086
model. Back in the day, when you used to

161
00:10:13,108 --> 00:10:16,978
run the application on your own servers, Amazon started in

162
00:10:16,984 --> 00:10:20,690
a garage. You were responsible for every single

163
00:10:20,760 --> 00:10:23,986
aspect of the application your server should be running. It should

164
00:10:24,008 --> 00:10:27,774
be able to scale up, scale down. You should make sure that in that garage

165
00:10:27,822 --> 00:10:31,094
that you are running the server. No one should just jump in and steal your

166
00:10:31,132 --> 00:10:34,934
servers. At the same time, youll are responsible for availability and

167
00:10:34,972 --> 00:10:37,400
all of the six aspects that I talked about.

168
00:10:37,850 --> 00:10:41,500
That's not the world we live in today. That's why you have cloud services.

169
00:10:42,030 --> 00:10:45,818
Cloud says you can hand over some of

170
00:10:45,824 --> 00:10:49,530
the responsibilities that traditionally were yours to us.

171
00:10:49,600 --> 00:10:53,214
We will handle those responsibility in return. Of course, you pay

172
00:10:53,252 --> 00:10:56,570
us extra and you might lose on some of the flexibility

173
00:10:56,650 --> 00:10:59,790
that you have running those applications on your backend.

174
00:11:00,210 --> 00:11:04,138
A way of distinguishing them. I talked about, I always use this example by Albert

175
00:11:04,154 --> 00:11:07,742
Barron, which is about pizza as a service. I like to have pizza.

176
00:11:07,806 --> 00:11:11,346
I'm thinking of having pizza for dinner today. There are two ways I can do

177
00:11:11,368 --> 00:11:14,674
that. I could go out to a restaurant and then

178
00:11:14,712 --> 00:11:17,506
I don't have to worry about anything. I don't have to worry about where the

179
00:11:17,528 --> 00:11:21,074
cheese comes from. I don't have to worry about doing the dishes after eating.

180
00:11:21,202 --> 00:11:24,726
I don't have to worry about the temperature of the oven and all

181
00:11:24,748 --> 00:11:28,246
sorts of things. But at the same time, if I want a customization, if I

182
00:11:28,268 --> 00:11:31,446
want gluten free base or something like that, I don't

183
00:11:31,478 --> 00:11:34,860
have that option anymore. On the other hand,

184
00:11:35,390 --> 00:11:38,554
if I want everything customized, I want to have gluten free

185
00:11:38,592 --> 00:11:42,186
base. I want to have pizza dough, which is

186
00:11:42,208 --> 00:11:46,138
of a specific type. I want the cheese to be french mozzarella

187
00:11:46,234 --> 00:11:50,014
made from buffalo milk or whatever it is. I can make

188
00:11:50,052 --> 00:11:53,546
everything at home. But then after doing everything, I'm now responsible

189
00:11:53,578 --> 00:11:56,830
for the dishes. I'm responsible for setting the dining table,

190
00:11:56,910 --> 00:12:00,226
the oven, the heat, et cetera. So I

191
00:12:00,248 --> 00:12:03,380
have to decide what is it that I care about most.

192
00:12:03,990 --> 00:12:07,202
The third option is of course I can go for something in the middle

193
00:12:07,256 --> 00:12:10,598
where I can order takeout, or I can order on seamless or uber eats or

194
00:12:10,604 --> 00:12:13,846
something like that where I still have to do the dishes, but I don't have

195
00:12:13,868 --> 00:12:17,858
to worry about the pizza term. And in

196
00:12:17,884 --> 00:12:22,410
the same way on the cloud you can have an ala carte of responsibilities.

197
00:12:23,070 --> 00:12:26,794
I could have everything on premise, or I could

198
00:12:26,832 --> 00:12:29,446
have something where everything, including scalability,

199
00:12:29,558 --> 00:12:33,018
availability, security is taken care of by AWS,

200
00:12:33,194 --> 00:12:37,802
but then I lose the flexibility that is associated

201
00:12:37,946 --> 00:12:41,454
with running my own application. Or I

202
00:12:41,492 --> 00:12:44,942
could find something somewhere in the middle and decide

203
00:12:45,006 --> 00:12:48,754
how much to give up control. Again, that's my

204
00:12:48,792 --> 00:12:52,626
responsibility. And as an architect to evaluate what my business cares about the

205
00:12:52,648 --> 00:12:56,670
most, I would like to focus on the scalability aspect

206
00:12:56,750 --> 00:13:00,354
because that's what the presentation is about. More specifically,

207
00:13:00,402 --> 00:13:03,494
I would want to go into figuring out what is

208
00:13:03,532 --> 00:13:07,190
it that I will give up while trying to attain more scalability?

209
00:13:08,090 --> 00:13:11,366
And what is it that I will probably have to give

210
00:13:11,388 --> 00:13:15,014
up as far as scalability is concerned, if I want to be not flexible

211
00:13:15,062 --> 00:13:18,138
on the other aspects of my application. In order to

212
00:13:18,144 --> 00:13:21,454
do that, I want to take a step back and first go into

213
00:13:21,492 --> 00:13:25,390
what exactly scalability is part of. The reason is

214
00:13:25,460 --> 00:13:29,200
I've noticed scalability is often confused with another

215
00:13:29,650 --> 00:13:33,646
kind of cousin of it called efficiency, because they are

216
00:13:33,668 --> 00:13:35,940
both trying to solve a very similar problem.

217
00:13:36,470 --> 00:13:40,094
So let's assume our application, our ecommerce application, is an overnight

218
00:13:40,142 --> 00:13:43,518
success. All of a sudden you start getting millions of requests

219
00:13:43,534 --> 00:13:47,310
per minute. You can solve it and suddenly

220
00:13:47,390 --> 00:13:50,706
you realize that you are hitting the seams of your server. Your server CPU

221
00:13:50,738 --> 00:13:54,166
utilization is high, your ram is off the roof. You can

222
00:13:54,188 --> 00:13:57,606
solve it in two ways. You can either increase the

223
00:13:57,628 --> 00:14:00,630
size of the ram that you have. If you are hitting 80%,

224
00:14:00,700 --> 00:14:04,134
you add another 20% to it. Or you can add more servers

225
00:14:04,182 --> 00:14:07,530
to the equation. You could make your code

226
00:14:07,600 --> 00:14:11,194
run in such a way that it can suddenly handle more requests that come

227
00:14:11,232 --> 00:14:14,442
in. You can add caching to the equation.

228
00:14:14,506 --> 00:14:17,534
That way you don't have to make a round trip to the database or I

229
00:14:17,572 --> 00:14:21,454
o or whatever it is. In both ways the

230
00:14:21,492 --> 00:14:24,846
solution is the same. You can now handle more requests. In the

231
00:14:24,868 --> 00:14:27,906
first one you add more resources. In the second one, you keep the number of

232
00:14:27,928 --> 00:14:32,100
resources the same. You just get more out of whatever you have running.

233
00:14:32,550 --> 00:14:36,226
The first one where you add more resources is the scalability that we

234
00:14:36,248 --> 00:14:39,798
want to talk about in this talk. The second one where you keep the

235
00:14:39,804 --> 00:14:43,186
number of resources the same, just get more output

236
00:14:43,218 --> 00:14:46,854
out of the same number of resources is efficiency. In most

237
00:14:46,892 --> 00:14:50,218
cases you want the system to be as efficient as possible,

238
00:14:50,384 --> 00:14:54,166
but soon you start hitting limits. You have diminishing returns

239
00:14:54,198 --> 00:14:57,626
as far as efficiency goals go. And that's why you need to

240
00:14:57,648 --> 00:15:01,626
focus on scalability, because your business would be a success and the

241
00:15:01,648 --> 00:15:04,974
last thing you would want to do is not service customers because you

242
00:15:05,012 --> 00:15:08,526
don't have the resources. Or rather you have the resources that you could

243
00:15:08,548 --> 00:15:12,318
have added. You just don't know how to add them. An example

244
00:15:12,404 --> 00:15:16,234
here. I've tried to create this caricature

245
00:15:16,362 --> 00:15:20,690
in chat GPT, where we are sitting in this group

246
00:15:20,760 --> 00:15:24,146
of developers. We suddenly hit success and then how

247
00:15:24,168 --> 00:15:27,430
do we scale? Well, we scale by adding these servers.

248
00:15:28,170 --> 00:15:31,394
And what happens once you add those servers? For starters,

249
00:15:31,442 --> 00:15:34,818
you lose the simplicity. You created this monster

250
00:15:34,914 --> 00:15:39,378
Frankenstein application with all these chords going everywhere.

251
00:15:39,554 --> 00:15:43,146
And look at these people, they've all done it. It's all a scaled system,

252
00:15:43,248 --> 00:15:46,586
but at what cost? You have a Frankenstein that youll suddenly have to

253
00:15:46,608 --> 00:15:50,140
tame. So that's where you need to focus.

254
00:15:51,570 --> 00:15:54,766
So having discussed scalability, let's talk

255
00:15:54,788 --> 00:15:57,854
about the ways you can achieve scalability. Well, you can do it in two

256
00:15:57,892 --> 00:16:00,670
ways. The first one is vertical scalability.

257
00:16:01,090 --> 00:16:04,942
Vertical scalability, going back to the textbook definition, is just adding

258
00:16:05,006 --> 00:16:09,074
an extra size to it. If you're hitting building the

259
00:16:09,112 --> 00:16:12,546
ram ceiling, like say if you have a four GB computer and your

260
00:16:12,568 --> 00:16:16,510
ram is close to getting done, you increase your ram to eight GB.

261
00:16:16,670 --> 00:16:20,694
Or if you have a CPU, you can increase from

262
00:16:20,732 --> 00:16:24,040
go from I five to I seven to I nine or whatever it is,

263
00:16:24,410 --> 00:16:28,262
vertical scalability, where you just improve the size of the

264
00:16:28,316 --> 00:16:31,606
server that is holding your application. The advantage of

265
00:16:31,628 --> 00:16:34,906
doing it is you don't have to make any changes to your code. It's the

266
00:16:34,928 --> 00:16:38,362
same code, it just runs on a better system. The second

267
00:16:38,416 --> 00:16:42,170
way of doing it is horizontal scalability where you add an extra

268
00:16:42,240 --> 00:16:45,354
server to the mix. So if you're running a cluster,

269
00:16:45,402 --> 00:16:48,366
and this is a big F, if you are running your application AWS part of

270
00:16:48,388 --> 00:16:52,154
a cluster, there are different multiple resources

271
00:16:52,202 --> 00:16:56,190
within that cluster that run your application. Horizontal scalability

272
00:16:56,270 --> 00:17:00,066
means you can just add extra resources to that cluster and then you can

273
00:17:00,088 --> 00:17:03,934
start achieving more. So what are the advantages

274
00:17:03,982 --> 00:17:07,662
and disadvantages? Well, for starters, if you don't have your application

275
00:17:07,736 --> 00:17:10,994
running as a cluster, it's just easy to achieve vertical

276
00:17:11,042 --> 00:17:14,626
scalability, right? Especially in the world of cloud, you can just increase

277
00:17:14,658 --> 00:17:17,654
the size within 20 minutes and you're done.

278
00:17:17,852 --> 00:17:21,394
The disadvantage though is you have limits

279
00:17:21,442 --> 00:17:24,540
to how big your instance can be.

280
00:17:24,990 --> 00:17:27,978
On EC two you can't go beyond T 24 x.

281
00:17:28,064 --> 00:17:32,138
Well you shouldn't ever reach that point, but there are limits to that.

282
00:17:32,304 --> 00:17:35,646
Secondly, vertical scalability is very easy to

283
00:17:35,668 --> 00:17:38,926
achieve. Initially you don't have to hire new engineers, you don't have to change the

284
00:17:38,948 --> 00:17:43,054
code, but it starts hitting diminishing returns very quickly.

285
00:17:43,252 --> 00:17:46,302
And horizontal scalability is the way to go beyond

286
00:17:46,366 --> 00:17:50,206
a certain point. So these are the two places

287
00:17:50,318 --> 00:17:53,938
factors that you need to figure out at what stage is your application

288
00:17:54,104 --> 00:17:57,682
at your company at and that will decide whether you want horizontal

289
00:17:57,746 --> 00:18:01,334
or vertical scalability. Now getting a little more

290
00:18:01,372 --> 00:18:04,502
into vertical scalability, as I mentioned, you can have

291
00:18:04,556 --> 00:18:08,366
an EC two instance that is running. And if you want to scale vertically,

292
00:18:08,498 --> 00:18:12,858
all you can do is increase the RAM or the CPU or

293
00:18:12,944 --> 00:18:16,422
the throughput of that application of the instance. And then suddenly

294
00:18:16,486 --> 00:18:18,540
you have a more scaled system.

295
00:18:19,950 --> 00:18:23,902
The other thing you can do as far as achieving vertical scalability goes

296
00:18:23,956 --> 00:18:28,046
is if you have a general purpose instance running. That is if you have

297
00:18:28,228 --> 00:18:31,850
an instance with two gigs of RAM and one virtual CPU.

298
00:18:32,010 --> 00:18:35,454
If you suddenly want to increase the CPU size, AWS gives you a

299
00:18:35,492 --> 00:18:38,946
memory optimized or a CPU optimized instance that

300
00:18:38,968 --> 00:18:42,626
you can go for where you give up some of the RAM for an

301
00:18:42,648 --> 00:18:46,174
extra CPU or you give up an extra CPU for some more RAM.

302
00:18:46,302 --> 00:18:49,454
So if you hit one of the two limits, if you hit the Ram

303
00:18:49,502 --> 00:18:52,518
limit, you can give up some of the RAM and you can give up some

304
00:18:52,524 --> 00:18:56,086
of the CPU for extra RAM at the same cost. So that's the

305
00:18:56,108 --> 00:19:00,310
other way of achieving vertical scalability. And finally, slightly less

306
00:19:00,380 --> 00:19:03,622
intuitive way is if your application runs on a shared

307
00:19:03,686 --> 00:19:07,206
server. Like if you have a database running on a shared database cluster,

308
00:19:07,318 --> 00:19:11,286
you can move it to its own instance and that way you can achieve

309
00:19:11,478 --> 00:19:14,538
better data. Youll can have a dedicated server,

310
00:19:14,634 --> 00:19:18,126
that way you get more processing power with

311
00:19:18,148 --> 00:19:21,550
that instead. I wanted to go a little bit into what are the cost

312
00:19:21,620 --> 00:19:26,158
implications of that. For this I've collected

313
00:19:26,254 --> 00:19:30,180
all the on demand prices for the T four

314
00:19:31,270 --> 00:19:34,674
instance on EC two AWS. You can see

315
00:19:34,712 --> 00:19:38,150
if you have a micro instance that has a 1GB RAM,

316
00:19:38,490 --> 00:19:42,246
it costs you zero point.

317
00:19:42,348 --> 00:19:45,718
It has two virtual cPus. If you go from 1GB to

318
00:19:45,724 --> 00:19:49,798
two gigabyte, it takes 0.8 extra cents.

319
00:19:49,894 --> 00:19:53,450
And now for zero point $0.16 you get

320
00:19:53,600 --> 00:19:56,966
the same number of VCPU, but you get 2GB of RAM.

321
00:19:57,158 --> 00:20:00,958
0336 increase, but you

322
00:20:00,964 --> 00:20:05,114
get 4GB of RAM. So you can see that for each gigabyte

323
00:20:05,162 --> 00:20:10,720
increase you're spending approximately zero.

324
00:20:11,170 --> 00:20:15,294
Look at the CPU side of things. You see a CPU

325
00:20:15,342 --> 00:20:19,090
jump from two to four between T four large and T four extra

326
00:20:19,160 --> 00:20:22,834
large. Ironically, AWS doesn't seem to be charging extra for

327
00:20:22,872 --> 00:20:26,214
that CPU jump, even though they

328
00:20:26,252 --> 00:20:29,282
say that CPU is expensive.

329
00:20:29,346 --> 00:20:33,266
And all I've noticed the memory is how they're

330
00:20:33,298 --> 00:20:37,074
pricing their tiers. So as an architect,

331
00:20:37,122 --> 00:20:40,762
if you have a demand that you are projecting, you should keep that

332
00:20:40,816 --> 00:20:44,586
in mind and figure out how this insight will

333
00:20:44,608 --> 00:20:48,426
help you at some point. Ram does become expensive on

334
00:20:48,448 --> 00:20:52,494
the cloud and you need to figure out how you can optimize youll

335
00:20:52,532 --> 00:20:55,230
application based on this kind of an equation.

336
00:20:55,970 --> 00:20:59,210
I've written a few blocks around cloud economics,

337
00:20:59,290 --> 00:21:02,994
but that's something that I always keep in mind when it comes to

338
00:21:03,112 --> 00:21:07,026
projections. With that being said, I would

339
00:21:07,048 --> 00:21:10,242
like to go into the more complicated, according to me,

340
00:21:10,296 --> 00:21:14,370
way of achieving scalability. That is horizontal scalability

341
00:21:15,050 --> 00:21:18,802
for starters. Why is it that most people don't

342
00:21:18,946 --> 00:21:22,102
have horizontal scalability by default? Well,

343
00:21:22,156 --> 00:21:25,974
because for starters, your application needs to be ready to have

344
00:21:26,012 --> 00:21:29,766
horizontal scalability. Just because you add an extra server to the equation doesn't

345
00:21:29,798 --> 00:21:32,742
mean suddenly your application can start running faster,

346
00:21:32,806 --> 00:21:36,986
better, or process more requests. A fun joke one

347
00:21:37,008 --> 00:21:40,614
of my old boss used to tell me was nine couples can't

348
00:21:40,662 --> 00:21:44,622
have one baby in one month. If the baby takes

349
00:21:44,676 --> 00:21:47,280
nine months to be born. That's how it takes.

350
00:21:48,130 --> 00:21:51,594
That's how some applications might be. So you need to redesign

351
00:21:51,642 --> 00:21:55,870
the application in order to have horizontal scalability

352
00:21:55,950 --> 00:21:59,474
where that extra server should make a difference. With that

353
00:21:59,512 --> 00:22:03,122
said, let's assume you have an application that can actually

354
00:22:03,176 --> 00:22:06,702
do that. One way of doing it is of course you can over provision

355
00:22:06,766 --> 00:22:10,866
your entire system. Let's say you are suddenly going to expect a million requests

356
00:22:10,898 --> 00:22:14,166
per minute. Youll can assume that's what you're going to do.

357
00:22:14,188 --> 00:22:17,894
And right since day one you can provision your servers in that way where

358
00:22:17,932 --> 00:22:21,434
you have enough servers to handle 1 million requests. So if you hit

359
00:22:21,472 --> 00:22:24,140
that kind of a level that is not going to be a problem.

360
00:22:24,590 --> 00:22:28,710
What's the disadvantage of doing it that way? For starters,

361
00:22:28,790 --> 00:22:32,074
on day one where you're not getting a million requests, you have all these servers

362
00:22:32,122 --> 00:22:35,566
running and you're paying money for no reason.

363
00:22:35,668 --> 00:22:38,698
They are just running there without handling any requests.

364
00:22:38,874 --> 00:22:42,270
Then your load starts picking up. Day 50, day 100,

365
00:22:42,340 --> 00:22:46,462
whatever it is. Then each server starts becoming useful

366
00:22:46,606 --> 00:22:49,934
even though then this server here is still being wasted.

367
00:22:49,982 --> 00:22:53,566
But some of the others are now useful until you hit this limit

368
00:22:53,598 --> 00:22:56,926
where you have provisioned something. Once you cross this limit

369
00:22:56,958 --> 00:23:00,502
again now you are under provisioned because you don't have

370
00:23:00,556 --> 00:23:03,766
any server above this that you could provision. Now suddenly you

371
00:23:03,788 --> 00:23:07,058
might end up running to the market trying to buy new servers.

372
00:23:07,154 --> 00:23:10,574
I mean you live in the world of cloud so you're provisioning a new server

373
00:23:10,722 --> 00:23:13,866
but that's still a problem. You have to do something. You need to have

374
00:23:13,888 --> 00:23:17,770
someone to monitor the utilization before a new server is added.

375
00:23:18,190 --> 00:23:21,750
And that's the problem that horizontal scalability

376
00:23:21,830 --> 00:23:25,326
might have. I have at the bottom. This is something that I

377
00:23:25,348 --> 00:23:28,654
found online. Tried to give attribution wherever possible.

378
00:23:28,852 --> 00:23:32,954
If this is how your demand is going to increase. The blue

379
00:23:33,002 --> 00:23:36,930
line is how you want your servers to be provisioned.

380
00:23:37,830 --> 00:23:41,202
But in reality that's not how the world works, right? There's always

381
00:23:41,256 --> 00:23:44,546
these step increases. Anytime you go and get

382
00:23:44,568 --> 00:23:47,446
a new server you have to jump up a step. You might have to make

383
00:23:47,468 --> 00:23:51,062
a capital expenditure if it is on premise or in the cloud

384
00:23:51,116 --> 00:23:54,726
you can just provision a new server. Finally you can also

385
00:23:54,828 --> 00:23:58,610
start reducing your traffic

386
00:23:58,690 --> 00:24:02,250
and you might have to get rid of servers again. That is something

387
00:24:02,320 --> 00:24:06,342
that youll have to worry about. If you are under provisioned

388
00:24:06,486 --> 00:24:10,282
you might lose customers because you don't have the

389
00:24:10,336 --> 00:24:14,254
processing power to accept the request. If you're over provisioned your

390
00:24:14,292 --> 00:24:17,520
servers are running for no reason and you are losing money.

391
00:24:17,970 --> 00:24:21,306
A final point I would like to make is that of elasticity.

392
00:24:21,498 --> 00:24:25,854
Elasticity is very similar to scalability but in a very temporary setting.

393
00:24:25,982 --> 00:24:30,046
So what if normally speaking you get say 5000 requests

394
00:24:30,078 --> 00:24:33,666
a day? That number is going to be the same. But on

395
00:24:33,688 --> 00:24:36,982
the day of the Super bowl suddenly you get

396
00:24:37,036 --> 00:24:40,790
like a million requests. So that temporary spike,

397
00:24:41,130 --> 00:24:44,610
you might want to also have the ability

398
00:24:44,690 --> 00:24:48,620
to handle the traffic that comes in because you don't want to waste the

399
00:24:49,470 --> 00:24:53,014
turn away customers. Even if it is on a temporary basis.

400
00:24:53,142 --> 00:24:56,954
So sometimes while designing for scalability, you might also want to

401
00:24:56,992 --> 00:25:00,806
consider elasticity where you want the ability to add

402
00:25:00,848 --> 00:25:04,430
extra servers for 1 hour where you have that extra

403
00:25:04,500 --> 00:25:07,646
spike. So that's what

404
00:25:07,668 --> 00:25:12,094
you want to achieve. So what you want to achieve is to have servers being

405
00:25:12,132 --> 00:25:15,546
added in the way this blue line is added. When the spike

406
00:25:15,578 --> 00:25:18,798
increases, you want more servers. When it goes down, you want less servers.

407
00:25:18,974 --> 00:25:22,546
There are two ways. The first one is by using what is called

408
00:25:22,568 --> 00:25:26,086
auto scaling. What AWS allows you to do as part

409
00:25:26,108 --> 00:25:29,186
of the shared responsibility model is it allows

410
00:25:29,218 --> 00:25:33,062
you to teach it how to add new servers. By that

411
00:25:33,116 --> 00:25:36,662
it means you can specify events which when

412
00:25:36,716 --> 00:25:39,690
triggered will add an extra server to your cluster.

413
00:25:40,030 --> 00:25:44,362
These events are known AWS auto scaling triggers and

414
00:25:44,416 --> 00:25:48,294
they can be something simple like each time my CPU utilization

415
00:25:48,342 --> 00:25:51,850
hits 90% I want an extra server to be added.

416
00:25:52,190 --> 00:25:55,614
Or each time my Ram hits 85% I want

417
00:25:55,652 --> 00:25:57,950
an extra server to be added to the cluster.

418
00:25:59,090 --> 00:26:01,898
By ram I mean the average ram of the cluster.

419
00:26:02,074 --> 00:26:05,934
This way you can have logic that can teach Amazon

420
00:26:05,982 --> 00:26:09,410
to add extra servers and thus your application now

421
00:26:09,480 --> 00:26:12,846
starts scaling up or scaling down automatically. And that way you don't

422
00:26:12,878 --> 00:26:16,914
have to over provision or under provision. There is still the

423
00:26:16,952 --> 00:26:20,326
possibility because it's still a stepwise increase. You can see that

424
00:26:20,348 --> 00:26:23,542
there are still these pockets where you still have under

425
00:26:23,596 --> 00:26:27,074
or over provisioning. If your auto scaling logic is not aggressive

426
00:26:27,122 --> 00:26:30,506
enough, it will under provision and then you will have lost customers.

427
00:26:30,608 --> 00:26:33,866
Or you can aggressively auto provision, but then you

428
00:26:33,888 --> 00:26:37,530
might have more over provisioning or overcapacity.

429
00:26:37,950 --> 00:26:41,434
The second disadvantage of auto scaling is of course the fact

430
00:26:41,472 --> 00:26:45,514
that you are adding extra logic to the equation. That's going to increase the complexity

431
00:26:45,562 --> 00:26:49,274
of your application. You can't add, there is no free lunch.

432
00:26:49,402 --> 00:26:52,974
You still have to figure out how to add this logic. Sometimes this

433
00:26:53,012 --> 00:26:57,214
logic itself can be complicated. If it's as simple as Ram or CPU,

434
00:26:57,262 --> 00:27:00,754
that's one thing. But you might want to say okay, each time I see an

435
00:27:00,792 --> 00:27:04,194
upward sloping curve of the number of requests I

436
00:27:04,232 --> 00:27:08,258
want you to add and that's where your logic starts getting more and more complicated.

437
00:27:08,434 --> 00:27:11,270
So that's a disadvantage of auto scaling.

438
00:27:12,170 --> 00:27:16,322
The other way of doing it is a serverless application. What serverless

439
00:27:16,386 --> 00:27:19,914
does is it's the full service application

440
00:27:20,032 --> 00:27:24,234
that we talked about in the shared responsibility model where

441
00:27:24,352 --> 00:27:28,186
Amazon says we will handle everything for you as

442
00:27:28,208 --> 00:27:31,982
far as scalability goes, as long as you

443
00:27:32,116 --> 00:27:36,014
make your application run in the very specific way that

444
00:27:36,052 --> 00:27:38,734
the serverless application is designed to run.

445
00:27:38,932 --> 00:27:42,426
So within limits. Of course, you can't have like a trillion requests

446
00:27:42,458 --> 00:27:46,162
a second, but within limits. What Amazon says

447
00:27:46,216 --> 00:27:50,510
is we will increase the capacity and match your load

448
00:27:50,670 --> 00:27:54,740
as long as your application runs the way it is designed to run.

449
00:27:55,350 --> 00:27:59,206
One example is Lambda Lambda is something that runs a function

450
00:27:59,308 --> 00:28:02,274
for you. It's supposed to be very small functions,

451
00:28:02,322 --> 00:28:06,134
asynchronous functions generally, even though they can now run for 15 minutes,

452
00:28:06,252 --> 00:28:09,786
you're supposed to run small asynchronous functions. But if you

453
00:28:09,808 --> 00:28:13,254
can extract this function out and run it on an AWS

454
00:28:13,302 --> 00:28:16,294
lambda within region, within limits,

455
00:28:16,422 --> 00:28:20,422
Amazon will automatically provision resources for youll provision

456
00:28:20,486 --> 00:28:24,026
servers and your function will run on those servers so you don't

457
00:28:24,058 --> 00:28:27,594
have to think about scalability, adding auto scaling logic,

458
00:28:27,642 --> 00:28:31,594
et cetera, et cetera. Again, I keep repeating like a broken

459
00:28:31,642 --> 00:28:34,998
tape, as long as your application conforms

460
00:28:35,034 --> 00:28:38,962
to the way lambdas are supposed to run. So that then

461
00:28:39,016 --> 00:28:42,142
becomes a very effective way of doing, especially if you have big spikes,

462
00:28:42,206 --> 00:28:45,766
jumps and downs. Adding out the scaling logic might be hard,

463
00:28:45,788 --> 00:28:49,318
but lambdas are the rescuers. Postgres is another

464
00:28:49,484 --> 00:28:52,902
example. Aurora on AWS gives you an option

465
00:28:52,956 --> 00:28:57,090
of running your application in a serverless mode where Amazon handles

466
00:28:57,170 --> 00:29:01,058
all the scaling up and scaling down for you. I'm actually going to talk

467
00:29:01,084 --> 00:29:04,842
about postgres Aurora in the next slide where I'll talk about

468
00:29:04,896 --> 00:29:08,426
how Aurora can run either in postgres mode, it can also run

469
00:29:08,448 --> 00:29:11,618
in the auto scaling mode, or it can run in the fixed capacity mode,

470
00:29:11,654 --> 00:29:15,230
all three modes. So it's a wonderful case study to differentiate between

471
00:29:15,380 --> 00:29:18,090
all the different aspects of scaling.

472
00:29:18,250 --> 00:29:21,930
DynamoDB is another example where if you have a key value lookup,

473
00:29:22,090 --> 00:29:25,578
DynamodB gives you a serverless lookup. So as I

474
00:29:25,604 --> 00:29:29,458
said, Aurora is an example of an application on AWS that

475
00:29:29,464 --> 00:29:32,642
can run in the one at the bottom.

476
00:29:32,696 --> 00:29:36,370
That's the base mode where you can just say, okay, I just want one cluster,

477
00:29:36,710 --> 00:29:40,338
or you can have it run in an auto scaling mode,

478
00:29:40,434 --> 00:29:44,102
or it can also run serverless. So I want to talk about the three

479
00:29:44,156 --> 00:29:47,766
different scenarios where each one of these modes is the

480
00:29:47,788 --> 00:29:50,890
best option to go for and how you AWS architects can

481
00:29:50,960 --> 00:29:54,938
make that decision. The first mode is if

482
00:29:54,944 --> 00:29:58,138
you have demand that is sustained and fairly stable, it's a

483
00:29:58,144 --> 00:30:02,278
flat line you probably don't want need auto

484
00:30:02,294 --> 00:30:05,866
scaling. That's unnecessary complexity. Youll are going to get five requests

485
00:30:05,898 --> 00:30:09,374
per minute. That's it. No more, no less. So in

486
00:30:09,412 --> 00:30:13,018
such a situation, you want the thing at the bottom because it's cost efficient,

487
00:30:13,114 --> 00:30:17,026
it's extremely simple, and you don't need to worry about anything.

488
00:30:17,208 --> 00:30:20,386
Aurora serverless also gives you most

489
00:30:20,408 --> 00:30:23,230
of that. But Aurora serverless, you have to pay a premium.

490
00:30:23,390 --> 00:30:26,554
AWS doesn't give you serverless for free. You pay a premium

491
00:30:26,622 --> 00:30:30,194
for the auto scaling that it does on your behalf. And that is unnecessary

492
00:30:30,242 --> 00:30:34,440
in this situation because your demand is constant. The next part

493
00:30:35,130 --> 00:30:38,674
is where you have fairly constant demand,

494
00:30:38,722 --> 00:30:42,326
except certain times of the day when you need to add more resources.

495
00:30:42,358 --> 00:30:46,058
Let's say at lunchtime. Suddenly people want to sit on their desks and order,

496
00:30:46,144 --> 00:30:50,140
I don't know, cell phones or sunglasses from your website.

497
00:30:50,510 --> 00:30:54,218
That's where you have a very sustained demand and you have spikes

498
00:30:54,394 --> 00:30:57,774
when you can predict them. Such a situation,

499
00:30:57,892 --> 00:31:01,550
the best option youll have, first of all, your regular single

500
00:31:01,620 --> 00:31:05,614
instance, Aurora is not going to work because at

501
00:31:05,652 --> 00:31:08,658
lunchtime there is a spike and youll can't just get rid of customers,

502
00:31:08,744 --> 00:31:12,178
I'm assuming at that point. So you can either auto scale or

503
00:31:12,184 --> 00:31:15,330
you can use serverless. Serverless will still work,

504
00:31:15,480 --> 00:31:19,842
but AWS. I said you are paying an unnecessary premium to AWS

505
00:31:19,986 --> 00:31:23,186
when you can just have a time based auto scaling.

506
00:31:23,218 --> 00:31:26,934
You can just teach AWS to scale up at 11:00 a.m.

507
00:31:26,972 --> 00:31:30,466
In the morning and then scale down at 130 and that's

508
00:31:30,498 --> 00:31:33,818
the best option you have. Third part, what if your

509
00:31:33,824 --> 00:31:36,986
demand is bursty? You just can't predict when suddenly you're going to get a

510
00:31:37,008 --> 00:31:41,034
million requests and then you're not going to get something. This lunchtime spike

511
00:31:41,082 --> 00:31:44,730
was fun, but it's lunch

512
00:31:44,890 --> 00:31:48,286
at any given time of the day throughout the

513
00:31:48,308 --> 00:31:51,502
world. In such a situation, well,

514
00:31:51,556 --> 00:31:54,858
youll need to go for serverless because Amazon will handle the ups

515
00:31:54,874 --> 00:31:58,942
and downs and you don't need to have complicated logic that will scale

516
00:31:59,006 --> 00:32:02,514
up and down for you. Even though you could invest time

517
00:32:02,552 --> 00:32:05,666
and money in doing that, you don't want to reinvent the wheel. So in such

518
00:32:05,688 --> 00:32:09,734
a situation, serverless is the best option for you. The point

519
00:32:09,772 --> 00:32:13,574
of me doing this is as an architect, I think about these kind

520
00:32:13,612 --> 00:32:17,400
of trade offs every day and the answer

521
00:32:17,710 --> 00:32:20,950
to that problem is different depending

522
00:32:21,030 --> 00:32:24,758
on what the problem is that you're trying to solve.

523
00:32:24,934 --> 00:32:27,530
And that's just one way of achieving scalability.

524
00:32:28,190 --> 00:32:32,106
So as I said, there are many, many ways you can handle

525
00:32:32,138 --> 00:32:35,774
scalability. As an architect, your job

526
00:32:35,892 --> 00:32:39,358
is to make sure that you pick the right tool for

527
00:32:39,364 --> 00:32:43,310
the job. As I mentioned, scalability is

528
00:32:43,380 --> 00:32:47,022
not where you extract more out of the same number of resources.

529
00:32:47,086 --> 00:32:51,154
You do have to spend money on resources. You make

530
00:32:51,192 --> 00:32:54,546
a decision that it is better to have a resource that you

531
00:32:54,568 --> 00:32:58,422
are allocating for your application because it's important

532
00:32:58,476 --> 00:33:02,082
for the business and this way your application can handle more traffic,

533
00:33:02,146 --> 00:33:05,510
can handle more load, as your company

534
00:33:05,580 --> 00:33:08,966
becomes more and more popular and your product starts getting sold more and

535
00:33:08,988 --> 00:33:11,878
more. Secondly, as I mentioned,

536
00:33:11,964 --> 00:33:15,334
the scalability does not come for free. First of all, you have to spend money

537
00:33:15,372 --> 00:33:19,170
in the resources, plus it might lead to complexity.

538
00:33:19,250 --> 00:33:22,814
It can lead to do more loss of security or

539
00:33:22,852 --> 00:33:26,542
any of the other aspects. So you need to make the right trade off

540
00:33:26,596 --> 00:33:30,286
while trying to achieve scalability. With that said,

541
00:33:30,468 --> 00:33:34,538
I hope that I was able to show some newer

542
00:33:34,634 --> 00:33:37,838
aspects of scalability and shine some light

543
00:33:37,924 --> 00:33:40,990
on some of the more confusing aspects of scalability.

544
00:33:41,330 --> 00:33:44,220
Thank you again for your time and I hope you learned something.

