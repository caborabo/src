1
00:00:20,810 --> 00:00:25,200
Firstly, let's get some introduction, right? What are

2
00:00:25,610 --> 00:00:30,214
these data intensive distributed systems? So all

3
00:00:30,252 --> 00:00:34,374
our end users of this in our day to day life example,

4
00:00:34,572 --> 00:00:38,086
Netflix streaming, e commerce systems like

5
00:00:38,268 --> 00:00:40,898
Amazon.com, TikTok,

6
00:00:40,994 --> 00:00:44,598
Instagram shop photo upload systems like

7
00:00:44,684 --> 00:00:48,514
Instagram, and Tinder proximity

8
00:00:48,562 --> 00:00:52,238
system like Yelp, Google Maps, all of them

9
00:00:52,324 --> 00:00:55,470
are data intensive distributed systems in the backend.

10
00:00:55,810 --> 00:00:58,590
And what is an API?

11
00:00:59,570 --> 00:01:02,080
The term itself answers this question. Right,

12
00:01:03,190 --> 00:01:06,974
an interface for application programming. So there are two perspectives

13
00:01:07,022 --> 00:01:10,850
to this. One is the system or the server perspective.

14
00:01:11,670 --> 00:01:15,874
It is used for interaction between microservices

15
00:01:15,922 --> 00:01:21,014
in a system, or for interaction across two

16
00:01:21,052 --> 00:01:23,830
or more servers or software applications,

17
00:01:24,170 --> 00:01:29,126
and the communication between systems

18
00:01:29,238 --> 00:01:32,730
in simple terms. And the other perspective is

19
00:01:32,880 --> 00:01:36,694
the client perspective, which is API

20
00:01:36,742 --> 00:01:39,974
is seen as a way for a client to

21
00:01:40,032 --> 00:01:43,966
communicate to the server with all the

22
00:01:43,988 --> 00:01:46,990
inputs and requesting for some resources.

23
00:01:48,210 --> 00:01:52,458
It is like an abstraction. API is like an abstraction to

24
00:01:52,484 --> 00:01:56,206
the client, where the client uses it to fetch

25
00:01:56,238 --> 00:01:59,554
the resources without having to

26
00:01:59,592 --> 00:02:03,106
know the details of the underlying implementation. It's like

27
00:02:03,208 --> 00:02:06,840
API is like a steering in a car

28
00:02:07,290 --> 00:02:10,406
where the driver doesn't need to know how the

29
00:02:10,428 --> 00:02:14,578
engine works. So the details of the API implementation need not be known.

30
00:02:14,754 --> 00:02:18,922
So with this, let's get right into

31
00:02:19,056 --> 00:02:22,634
the aspects of what is needed. First and

32
00:02:22,672 --> 00:02:25,738
foremost, the design aspect we need

33
00:02:25,744 --> 00:02:29,206
to consider is rest for HTTP

34
00:02:29,318 --> 00:02:32,826
API calls and thrift for RPC API

35
00:02:32,858 --> 00:02:36,730
calls. Now let's understand a bit about HTTP,

36
00:02:36,890 --> 00:02:40,206
why and where. So now let

37
00:02:40,228 --> 00:02:44,242
me introduce an architectural diagram for any

38
00:02:44,296 --> 00:02:47,698
modern data intensive distributed system, and it's a

39
00:02:47,704 --> 00:02:51,794
very most simplistic way, like this

40
00:02:51,832 --> 00:02:55,434
diagram. Firstly, it shows a user

41
00:02:55,582 --> 00:02:59,926
who is using any system, like a payment system or

42
00:03:00,108 --> 00:03:04,838
Netflix or any other

43
00:03:04,924 --> 00:03:08,486
example I gave earlier, any real world example.

44
00:03:08,668 --> 00:03:12,358
So obviously the request goes through the load balancer and load balancer

45
00:03:12,374 --> 00:03:16,410
redirects to the right backend system. There will be multiple systems,

46
00:03:17,550 --> 00:03:21,386
and then again from the load balancer it goes out. If there

47
00:03:21,408 --> 00:03:24,974
is an integration needed with an external partner, say for example in

48
00:03:25,012 --> 00:03:29,294
payments, you might have to integrate with visa or

49
00:03:29,332 --> 00:03:32,560
stripe or paypal, any of those things as an example.

50
00:03:32,870 --> 00:03:36,574
Now as you can see, some of these calls are HTTP

51
00:03:36,622 --> 00:03:40,420
and some of these calls are RPC. And why?

52
00:03:40,950 --> 00:03:44,526
So firstly, HTTP is like a networking protocol

53
00:03:44,638 --> 00:03:48,374
used by the client most of the times. Or the end

54
00:03:48,412 --> 00:03:51,590
user to call or invoke a server.

55
00:03:53,210 --> 00:03:57,310
Or HTTP can also be used by one software

56
00:03:57,490 --> 00:04:00,950
system or one microservice to call another microservice.

57
00:04:01,110 --> 00:04:03,340
It's possible it's used in both ways,

58
00:04:05,230 --> 00:04:09,962
but the RPC is a protocol which is used only

59
00:04:10,016 --> 00:04:13,966
within the back end system, like within the services.

60
00:04:14,068 --> 00:04:17,546
As you can see here, microservice one calls microservice

61
00:04:17,578 --> 00:04:21,358
two with an RPC, and gateway calls microservice one with

62
00:04:21,364 --> 00:04:25,326
an RPC because they are within a particular back

63
00:04:25,348 --> 00:04:29,138
end server. And why? Because RPC is

64
00:04:29,144 --> 00:04:32,926
highly secure and RPC is remote.

65
00:04:32,958 --> 00:04:36,514
Procedural call, obviously. And it is more about invoking

66
00:04:36,642 --> 00:04:40,678
a function from one

67
00:04:40,764 --> 00:04:44,070
service to another service. So when you're invoking a function,

68
00:04:44,140 --> 00:04:47,986
you need to know the exact request and response

69
00:04:48,018 --> 00:04:51,770
to the point, right? And HTTP

70
00:04:52,430 --> 00:04:55,786
is more generic, or it is more on

71
00:04:55,808 --> 00:04:59,594
the web exposed to the external world with

72
00:04:59,632 --> 00:05:03,046
those put, get, post and all those port

73
00:05:03,088 --> 00:05:06,810
types get put, post and delete.

74
00:05:06,970 --> 00:05:10,474
So in summary, RPC and HTTP are both communication

75
00:05:10,522 --> 00:05:12,910
protocols used in distributed systems,

76
00:05:13,830 --> 00:05:17,826
but they have different design principles, communication patterns and

77
00:05:17,928 --> 00:05:22,018
typical use cases. RPC is focused on direct

78
00:05:22,104 --> 00:05:25,498
invocation of remote procedures or functions

79
00:05:25,694 --> 00:05:29,238
like a process running, say microservice two runs a

80
00:05:29,244 --> 00:05:33,174
process and microservice one needs to call that process. It is

81
00:05:33,212 --> 00:05:37,154
done using RPC, while HTTP is a more general purpose

82
00:05:37,202 --> 00:05:41,366
protocol for transferring data on the web or requesting

83
00:05:41,398 --> 00:05:45,558
data on the web. And that's the reason why the external gateways

84
00:05:45,654 --> 00:05:49,514
and one service to another service are

85
00:05:49,552 --> 00:05:53,422
usually called through HTTP. So now

86
00:05:53,476 --> 00:05:56,606
let's talk about the rest for

87
00:05:56,628 --> 00:06:02,640
HTTP and thrift for now.

88
00:06:04,630 --> 00:06:08,002
What is rest in the API world?

89
00:06:08,056 --> 00:06:10,820
Rest transfer representational state transfer.

90
00:06:11,270 --> 00:06:15,054
It is an architectural style for

91
00:06:15,192 --> 00:06:17,682
designing networked applications,

92
00:06:17,826 --> 00:06:21,302
particularly these web services like oh,

93
00:06:21,436 --> 00:06:25,426
web services. Just that the distributed systems

94
00:06:25,458 --> 00:06:28,940
which are published and used by the

95
00:06:29,470 --> 00:06:33,126
outside world. Now, restful APIs added

96
00:06:33,158 --> 00:06:36,998
to the principles of REST and API design to provide a standardized way for systems

97
00:06:37,014 --> 00:06:38,650
to communicate over HTTP.

98
00:06:41,090 --> 00:06:44,314
And now, as I mentioned, the restful

99
00:06:44,362 --> 00:06:47,738
APIs use the HTTP methods,

100
00:06:47,754 --> 00:06:51,598
which I just mentioned. And another important

101
00:06:51,684 --> 00:06:55,410
feature of the rest and why it should be used

102
00:06:55,560 --> 00:06:58,846
for HTTP is stateless communication.

103
00:06:58,958 --> 00:07:02,878
So what is it? These restful APIs

104
00:07:03,054 --> 00:07:06,182
are stateless, meaning that each request from

105
00:07:06,236 --> 00:07:09,490
a client or an end user coming to the server

106
00:07:09,570 --> 00:07:13,206
must contain all the information necessary for

107
00:07:13,228 --> 00:07:16,434
the server to fulfill that request. The server

108
00:07:16,482 --> 00:07:20,154
does not store any client state between

109
00:07:20,192 --> 00:07:24,060
the requests, like request one to request two doesn't store any states.

110
00:07:25,310 --> 00:07:29,578
The reason for that is it improves the scalability and

111
00:07:29,664 --> 00:07:33,440
simplifies the communication. Imagine the server has to store

112
00:07:33,970 --> 00:07:37,786
any information from the previous call and not keeping

113
00:07:37,818 --> 00:07:42,154
them independent. It adds a lot of overhead and unnecessary

114
00:07:42,202 --> 00:07:45,982
information needs to be saved and added, and you don't

115
00:07:46,046 --> 00:07:49,810
want any strings attached between the client and the server

116
00:07:50,950 --> 00:07:54,370
or client and the web service, right? So that's the reason

117
00:07:54,440 --> 00:07:58,200
why the stateless communication is very important

118
00:07:59,530 --> 00:08:03,160
in this HTTP, which is provided by the rest

119
00:08:04,170 --> 00:08:08,034
architecture. And the other one is resource oriented

120
00:08:08,082 --> 00:08:11,482
design, meaning say, when you are

121
00:08:11,536 --> 00:08:15,226
requesting, say you are using Instagram, and what do you do when

122
00:08:15,248 --> 00:08:18,140
you want to look at some comments or post?

123
00:08:18,830 --> 00:08:22,782
You just go to the user and click on, say, comments, right? What happens

124
00:08:22,836 --> 00:08:26,830
internally is it makes an API call through

125
00:08:26,900 --> 00:08:31,290
HTTP and it makes that the uri

126
00:08:31,370 --> 00:08:32,954
like a specific domain,

127
00:08:33,082 --> 00:08:36,610
www.instagram.com users user id

128
00:08:36,680 --> 00:08:40,466
post. And similarly, if you're looking at some comments of a post,

129
00:08:40,648 --> 00:08:44,194
it goes through instagram.com posts post id and

130
00:08:44,232 --> 00:08:47,974
comments. And so you see that the hierarchy of

131
00:08:48,092 --> 00:08:52,018
say, you have users user id and post or post post id and comments,

132
00:08:52,194 --> 00:08:55,990
that is called hierarchical structure, and that is also

133
00:08:56,060 --> 00:08:59,994
provided by this architecture of ReSt. And it

134
00:09:00,032 --> 00:09:05,174
helps you identify the resource in the most simplistic

135
00:09:05,222 --> 00:09:08,394
and smooth form so that the

136
00:09:08,432 --> 00:09:11,840
back end system can retrieve it and

137
00:09:12,370 --> 00:09:17,034
uniquely return that particular data. And returning

138
00:09:17,082 --> 00:09:20,990
or all of this data is represented

139
00:09:21,410 --> 00:09:25,922
in JSON or XML or any other format in

140
00:09:26,056 --> 00:09:29,010
rest architecture.

141
00:09:29,430 --> 00:09:32,770
And the other important feature provided by the rest

142
00:09:32,840 --> 00:09:38,214
architecture is in these API calls which are made

143
00:09:38,252 --> 00:09:41,862
through HTTP by the end user or anyone

144
00:09:41,916 --> 00:09:45,250
who is making HTTP calls. You can add authentication,

145
00:09:45,330 --> 00:09:48,682
authorization, rate limiting. All these things

146
00:09:48,736 --> 00:09:52,890
are not core logic. These are exterior things

147
00:09:52,960 --> 00:09:56,586
which just needed to be added. Like say for

148
00:09:56,608 --> 00:09:59,862
example, if you want to look at the number of likes

149
00:09:59,926 --> 00:10:03,450
on a particular comment, or number of likes

150
00:10:03,610 --> 00:10:07,354
or number of comments on a particular post, they require some computation,

151
00:10:07,402 --> 00:10:11,502
although it is as simple as adding things. But you

152
00:10:11,556 --> 00:10:15,170
don't want to include all that computation.

153
00:10:16,390 --> 00:10:20,162
You want to keep all that computation separate from things

154
00:10:20,216 --> 00:10:24,510
like external things, like additional things like authorization,

155
00:10:24,590 --> 00:10:28,134
authentication, rate limiting, and all of these things. So all these things are

156
00:10:28,172 --> 00:10:31,910
provided, especially when you're making calls

157
00:10:33,290 --> 00:10:36,630
over the web or over the mobile or

158
00:10:36,780 --> 00:10:40,026
whatever it is from external outside of

159
00:10:40,048 --> 00:10:43,626
the actual server. So these additional features are

160
00:10:43,648 --> 00:10:47,226
always provided by HTTP, which ensures that

161
00:10:47,328 --> 00:10:51,274
the RPC calls can have only the logic being computed

162
00:10:51,322 --> 00:10:54,990
by invoking the APS within the microservices.

163
00:10:55,490 --> 00:10:59,626
Now, talking about the thrift,

164
00:10:59,818 --> 00:11:03,726
why thrift for RPC? Thrift is what is thrift, first of all? So thrift refers

165
00:11:03,758 --> 00:11:07,374
to Apache thrift. It's a software

166
00:11:07,422 --> 00:11:11,300
framework and also protocol. It is developed by Facebook for

167
00:11:12,470 --> 00:11:16,414
scalable cross language services development. So scalable

168
00:11:16,462 --> 00:11:20,866
cross language services development, that's the key here. So I'll

169
00:11:20,898 --> 00:11:24,742
tell about it. Thrift is primarily used for defining and

170
00:11:24,796 --> 00:11:28,620
creating efficient and interoperable RPC services.

171
00:11:28,990 --> 00:11:32,106
Now, how do both these things happen?

172
00:11:32,288 --> 00:11:36,822
Interoperable RPC communication and cross

173
00:11:36,886 --> 00:11:41,180
language services development. How do these things happen? There is one important

174
00:11:41,490 --> 00:11:44,762
feature provided by thrift which is called code generation.

175
00:11:44,906 --> 00:11:48,746
So it's like you can create a thrift file,

176
00:11:48,938 --> 00:11:53,046
say you want one microservice to talk to another microservice through some API,

177
00:11:53,178 --> 00:11:56,274
through some RPC call, and you can create

178
00:11:56,312 --> 00:12:00,690
a thrift file containing the request response and the API

179
00:12:02,230 --> 00:12:06,186
with these request response parameters. You can define it in thrift

180
00:12:06,318 --> 00:12:09,782
and you can run commands depending on whatever you use,

181
00:12:09,836 --> 00:12:13,746
like Golang or Java or whatever you use, you have the specific commands

182
00:12:13,778 --> 00:12:17,422
generate code like maven or any kite

183
00:12:17,506 --> 00:12:21,382
or gin frameworks. If you use for go, it generates

184
00:12:21,446 --> 00:12:24,220
all the boilerplate code which is needed,

185
00:12:24,990 --> 00:12:28,700
like request objects, response objects, and all

186
00:12:29,390 --> 00:12:33,278
the API skeleton and

187
00:12:33,444 --> 00:12:36,794
the things needed for concurrent request

188
00:12:36,842 --> 00:12:40,250
handling. All these things are provided by thrift

189
00:12:40,330 --> 00:12:43,646
auto generated code. So this auto

190
00:12:43,678 --> 00:12:47,422
generated code can be generated for different languages.

191
00:12:47,486 --> 00:12:51,026
Say your one microservice runs on Java, another microservice runs on

192
00:12:51,048 --> 00:12:54,910
Python, and you can use thrift to generate

193
00:12:54,990 --> 00:12:57,830
auto generate code for these APIs.

194
00:12:58,330 --> 00:13:01,862
Say in microservice two, you auto generated the code as a

195
00:13:01,916 --> 00:13:05,298
server code, and in microservice one, you auto

196
00:13:05,314 --> 00:13:08,522
generated code using this thrift file as a client code.

197
00:13:08,576 --> 00:13:13,050
You can generate both. And now the client can call the server

198
00:13:13,790 --> 00:13:17,258
by whatever through doing that RPC call.

199
00:13:17,424 --> 00:13:21,162
And it is cross platform or cross

200
00:13:21,226 --> 00:13:24,430
language. It can work

201
00:13:24,580 --> 00:13:27,866
because if you're manually doing this right, if you're

202
00:13:27,898 --> 00:13:31,418
writing the implementation, everything in Java

203
00:13:31,514 --> 00:13:35,050
and in Python and in go three services now have to interact.

204
00:13:35,210 --> 00:13:38,514
There will be lot of incompatibility issues

205
00:13:38,632 --> 00:13:42,434
and there are a lot of manual effort which needs to be done.

206
00:13:42,552 --> 00:13:46,194
But with this thrift you don't have to worry about it. Cross language

207
00:13:46,322 --> 00:13:49,682
support is in itself provided by this code generation

208
00:13:49,746 --> 00:13:54,134
and all the features provided by the thrift, it is absolutely

209
00:13:54,252 --> 00:13:57,962
amazing. And another thing is for

210
00:13:58,016 --> 00:14:01,894
RPC, right, you want the communication

211
00:14:01,942 --> 00:14:05,754
to be as fast as possible, and that is supported by

212
00:14:05,952 --> 00:14:09,286
binary protocol, the data. So thrift uses

213
00:14:09,318 --> 00:14:13,050
this binary protocol

214
00:14:13,210 --> 00:14:17,214
for efficient communication between services. This binary protocol is

215
00:14:17,252 --> 00:14:21,194
optimized for performance and reduces both network

216
00:14:21,242 --> 00:14:25,502
overhead and serialization deserialization costs. It's really quick

217
00:14:25,636 --> 00:14:30,446
and really efficient. So it

218
00:14:30,468 --> 00:14:34,254
is a lot better compared to the text based protocols like JsON or XML.

219
00:14:34,302 --> 00:14:38,360
So for between microservices communication or

220
00:14:38,730 --> 00:14:42,134
between systems communication, it's always better

221
00:14:42,172 --> 00:14:45,890
to use thrift, which provides all these advantages.

222
00:14:45,970 --> 00:14:49,290
Oh, and another big advantage is scalability

223
00:14:50,510 --> 00:14:54,202
thrift. Like I mentioned a bit a few minutes earlier about

224
00:14:54,256 --> 00:14:57,814
the concurrent requests, the thrift software framework

225
00:14:57,942 --> 00:15:01,490
provides by generating the code like the APIs can handle concurrent

226
00:15:01,590 --> 00:15:05,440
requests, right? It has support for it.

227
00:15:06,290 --> 00:15:11,246
And with thrift you

228
00:15:11,268 --> 00:15:14,980
can do the development for asynchronous communication between

229
00:15:15,430 --> 00:15:18,866
different microservices and how that can be done.

230
00:15:18,968 --> 00:15:22,686
Or what is asynchronous communication I'll be covering in my next chapter.

231
00:15:22,878 --> 00:15:26,566
And now moving on to chapter two, as we are

232
00:15:26,588 --> 00:15:29,350
talking about asynchronous API calls.

233
00:15:30,250 --> 00:15:33,974
So now the second aspect of the

234
00:15:34,012 --> 00:15:37,646
design, the good API

235
00:15:37,698 --> 00:15:41,674
design choice is

236
00:15:41,712 --> 00:15:45,514
using callbacks with these

237
00:15:45,552 --> 00:15:49,430
API calls. So what is asynchronous API calls with callback?

238
00:15:49,590 --> 00:15:53,500
Let's take the same example, but zoom in a bit more into the

239
00:15:56,130 --> 00:15:59,598
imagine. Let's take a use case. Right? So if you are

240
00:15:59,604 --> 00:16:02,560
a user making a payment on an ecommerce platform,

241
00:16:03,250 --> 00:16:06,674
do you want to wait until you know your

242
00:16:06,712 --> 00:16:10,450
payment? Do you want to wait until all the processing in the back end

243
00:16:10,520 --> 00:16:14,162
to be done, like microservice one

244
00:16:14,216 --> 00:16:16,958
to two to three and then external channel,

245
00:16:17,064 --> 00:16:20,706
your visa or Mastercard is processing. It doesn't

246
00:16:20,738 --> 00:16:24,038
give a good user experience if you have to wait for such a long time.

247
00:16:24,204 --> 00:16:28,234
So what you have to, and also

248
00:16:28,272 --> 00:16:32,150
with the amount of requests which are computing in, it doesn't scale,

249
00:16:32,230 --> 00:16:36,054
right? You can't just have all the calls synchronously

250
00:16:36,102 --> 00:16:40,154
waiting with each other. So for

251
00:16:40,192 --> 00:16:43,354
that, what we need is a synchronous communication.

252
00:16:43,402 --> 00:16:47,086
And how that is achieved is say you as

253
00:16:47,108 --> 00:16:50,654
a user make a pay request at

254
00:16:50,692 --> 00:16:54,114
step number before step number one

255
00:16:54,232 --> 00:16:57,774
here on the slide, and that pay request

256
00:16:57,822 --> 00:17:01,282
is sent to a distributed queue like a

257
00:17:01,336 --> 00:17:04,686
Kafka or RocketMQ.

258
00:17:04,878 --> 00:17:08,934
And that's it. That's it for the microservice one. And microservice one

259
00:17:08,972 --> 00:17:12,694
sends a response back to the user saying that

260
00:17:12,732 --> 00:17:16,514
it's in processing. So the user knows that it is in processing.

261
00:17:16,642 --> 00:17:21,082
And then microservice two has like a consumer which

262
00:17:21,136 --> 00:17:24,566
reads from this message queue

263
00:17:24,678 --> 00:17:28,620
and takes it and does whatever processing and

264
00:17:29,870 --> 00:17:33,054
then again puts in a different distributed queue at step number

265
00:17:33,092 --> 00:17:36,446
three. Now when you have

266
00:17:36,468 --> 00:17:40,462
to make a call, external call again,

267
00:17:40,516 --> 00:17:44,100
there will be a consumer which will be reading from that

268
00:17:44,630 --> 00:17:48,014
kafka queue, from Kafka queue

269
00:17:48,062 --> 00:17:51,714
two and makes a HTTP call. Now how

270
00:17:51,752 --> 00:17:55,370
does the external partner, or all these microservices

271
00:17:55,470 --> 00:17:59,954
know that the processing is complete? That is called callback.

272
00:18:00,082 --> 00:18:04,166
Now when the external partner processes the

273
00:18:04,188 --> 00:18:07,190
request or the API call which it received,

274
00:18:07,550 --> 00:18:11,290
it is immediately going to send a response.

275
00:18:12,190 --> 00:18:16,570
After it processes, it is going to use that callback URL

276
00:18:17,070 --> 00:18:21,274
to send a response back to the microservice

277
00:18:21,322 --> 00:18:25,086
two. And how this actually happens is we can

278
00:18:25,188 --> 00:18:28,446
see in the code. Here is an example,

279
00:18:28,548 --> 00:18:34,626
as you can see on my screen in

280
00:18:34,648 --> 00:18:38,142
this, there is this function, you can see in the middle process async.

281
00:18:38,286 --> 00:18:42,146
And that is the API, say that is the API which

282
00:18:42,168 --> 00:18:46,066
is being called from microservice

283
00:18:46,098 --> 00:18:49,862
three to external partner from steps three,

284
00:18:49,916 --> 00:18:53,746
four and five, right? Say consumer picks up the distributed

285
00:18:53,778 --> 00:18:58,070
queue message which is about calling process

286
00:18:58,140 --> 00:19:01,914
async and it calls step number five at

287
00:19:01,952 --> 00:19:05,334
step number five to the external channel. And once it calls

288
00:19:05,382 --> 00:19:08,650
a post, you can see I just added a simple

289
00:19:08,720 --> 00:19:12,394
sleep showing that it is doing some asynchronous

290
00:19:12,442 --> 00:19:16,346
processing. It is doing some whatever, all the logic and algorithm

291
00:19:16,458 --> 00:19:23,426
implementation or whatever. Once that is done in

292
00:19:23,448 --> 00:19:27,042
the request, if you see at the bottom request data has something

293
00:19:27,096 --> 00:19:30,830
called callback URL. That means the request

294
00:19:30,910 --> 00:19:34,942
received at this endpoint already has a URL at

295
00:19:35,016 --> 00:19:38,978
which the processing

296
00:19:39,074 --> 00:19:42,534
of the API can send the response back.

297
00:19:42,732 --> 00:19:46,118
Now that's what invoke callback does.

298
00:19:46,204 --> 00:19:50,214
So inside the processor sync, if you see the invoke

299
00:19:50,262 --> 00:19:54,406
callback actually gets the callback

300
00:19:54,438 --> 00:19:58,598
URL, like requestdata get callback URL

301
00:19:58,774 --> 00:20:03,146
and it invokes. Now when this invoke callback

302
00:20:03,258 --> 00:20:04,320
is done,

303
00:20:06,850 --> 00:20:10,222
it actually calls the microservice two here.

304
00:20:10,276 --> 00:20:13,722
So that's what I have mentioned. In the third point,

305
00:20:13,876 --> 00:20:17,442
after the processing is complete, the server invokes a callback URL at step

306
00:20:17,496 --> 00:20:19,490
number six in the previous slide.

307
00:20:20,870 --> 00:20:24,386
And so once it receives, when microservice two receives that

308
00:20:24,408 --> 00:20:25,330
callback,

309
00:20:27,930 --> 00:20:31,414
it knows that, okay, the previous request I sent,

310
00:20:31,532 --> 00:20:35,400
I received the callback and this is complete.

311
00:20:35,770 --> 00:20:39,658
Now, microservice two also needs to inform microservice one

312
00:20:39,824 --> 00:20:43,450
about whatever the pay is complete or

313
00:20:43,520 --> 00:20:47,990
not. Now I added another queue here which is distributed

314
00:20:48,150 --> 00:20:51,926
message queue three. So imagine as

315
00:20:51,968 --> 00:20:55,610
part of once you receive the callback in a microservice,

316
00:20:55,770 --> 00:20:59,438
the microservice might have to do certain things like storing the state in a

317
00:20:59,444 --> 00:21:03,390
database or make another RPC call to a different service

318
00:21:03,460 --> 00:21:07,010
to update something. And what if during that

319
00:21:07,080 --> 00:21:10,306
process of callback handling there

320
00:21:10,328 --> 00:21:13,250
is a failure? There has to be a way to recover, right?

321
00:21:13,400 --> 00:21:16,706
There has to be a way to, the system has to

322
00:21:16,728 --> 00:21:20,934
be resilient enough or fault tolerant enough to recover from such states.

323
00:21:21,132 --> 00:21:24,454
So that's why we have this q three. So now at

324
00:21:24,492 --> 00:21:29,114
step number seven, when the callback is sent or

325
00:21:29,152 --> 00:21:32,662
put in the queue, microservice one picks up that callback

326
00:21:32,726 --> 00:21:36,694
from the queue and it tries to do processing

327
00:21:36,742 --> 00:21:39,740
like saving into the database and all those things.

328
00:21:40,050 --> 00:21:43,262
And if it fails, if that process

329
00:21:43,316 --> 00:21:47,034
fails, that callback handler in microservice

330
00:21:47,082 --> 00:21:53,214
one won't acknowledge that it

331
00:21:53,252 --> 00:21:57,338
received the callback. It received the callback from the distributed

332
00:21:57,354 --> 00:22:00,770
message queue three. So when it doesn't acknowledge,

333
00:22:01,110 --> 00:22:04,846
the message still remains in the queue. So the

334
00:22:04,968 --> 00:22:09,270
microservice one will again fetch or

335
00:22:09,340 --> 00:22:13,330
read that callback message from the queue

336
00:22:13,490 --> 00:22:17,518
to reprocess it again. So that way it retries

337
00:22:17,634 --> 00:22:21,466
and retries until the message is

338
00:22:21,488 --> 00:22:24,794
totally consumed, which means the entire callback handler is

339
00:22:24,832 --> 00:22:28,218
done. So that's how this whole concept works.

340
00:22:28,384 --> 00:22:31,614
And the key point to note here is the

341
00:22:31,652 --> 00:22:35,546
design aspect of the request containing

342
00:22:35,578 --> 00:22:39,438
the callback URL. So that's the whole point here.

343
00:22:39,524 --> 00:22:43,246
So in the processing callback also two steps here. One is

344
00:22:43,348 --> 00:22:46,882
you need to have that callback URL in the request. And the second

345
00:22:46,936 --> 00:22:50,750
part is making a call to that callback URL

346
00:22:50,830 --> 00:22:54,638
once all the processing is done by the callback handler.

347
00:22:54,814 --> 00:22:58,566
In this case, the callback handler is in the external partner and

348
00:22:58,588 --> 00:23:01,558
it sends a callback to the microservice too.

349
00:23:01,644 --> 00:23:05,254
So that's the example I have demonstrated. Now, apart from

350
00:23:05,292 --> 00:23:08,554
the callbacks, there is another way you can do

351
00:23:08,592 --> 00:23:12,780
this. Asynchronous processing with APIs is

352
00:23:13,630 --> 00:23:18,170
something called webhook. I think webhook is again a very generic term.

353
00:23:18,590 --> 00:23:21,854
Callbacks or webhooks are almost similar,

354
00:23:22,052 --> 00:23:26,080
but just that webhook is something,

355
00:23:29,170 --> 00:23:32,706
callback is something where you send a URL in

356
00:23:32,728 --> 00:23:36,382
the request, the caller sends a URL in the request to the collie

357
00:23:36,446 --> 00:23:41,506
and the collie calls back, right? Webhook is like you

358
00:23:41,528 --> 00:23:45,514
keep a process or a URL

359
00:23:45,662 --> 00:23:49,510
open and then the collie

360
00:23:50,810 --> 00:23:54,866
puts the data onto that URL, onto that placeholder. You can think of Webhook

361
00:23:54,898 --> 00:23:59,086
as a placeholder in the caller, where the collie

362
00:23:59,138 --> 00:24:02,614
puts the data. So now let's go into some details or differences

363
00:24:02,662 --> 00:24:06,570
here. So the callback is

364
00:24:06,640 --> 00:24:08,890
initiated by requests.

365
00:24:09,710 --> 00:24:13,382
As I mentioned here, like one system, the caller

366
00:24:13,446 --> 00:24:16,990
calls another system, the collie, and the caller

367
00:24:17,330 --> 00:24:20,558
includes a callback function or URL as part of the request, indicating where the

368
00:24:20,564 --> 00:24:25,140
callie should send the response or notification. Right? Now, webhook are

369
00:24:25,670 --> 00:24:28,946
typically initiated by events or triggers that occur in

370
00:24:28,968 --> 00:24:32,398
one system, especially the sender.

371
00:24:32,494 --> 00:24:36,086
And when the event occurs, the sender makes a

372
00:24:36,108 --> 00:24:39,474
HTTP request to a URL to the receiver.

373
00:24:39,522 --> 00:24:44,066
So receiver is microservice

374
00:24:44,258 --> 00:24:48,086
two in this example, and the sender is external

375
00:24:48,118 --> 00:24:55,146
partner. And now the

376
00:24:55,168 --> 00:24:58,746
receiver does not actively request for data. Instead it waits for

377
00:24:58,768 --> 00:25:02,126
the incoming request from the sender. So you can think

378
00:25:02,148 --> 00:25:05,614
of it as outbound communication. So as

379
00:25:05,652 --> 00:25:07,630
a receiver of the webhook,

380
00:25:11,010 --> 00:25:14,126
you are actually pulling the data,

381
00:25:14,228 --> 00:25:18,446
you have something open, you are actually pulling the data into it. That's Webhook.

382
00:25:18,558 --> 00:25:22,018
And in callback that's not the case. Callback is like

383
00:25:22,104 --> 00:25:25,598
you have sent a request to the external

384
00:25:25,614 --> 00:25:28,838
partner and external partner uses the URL to push the data.

385
00:25:28,924 --> 00:25:32,134
So it's a push model. And callback is

386
00:25:32,172 --> 00:25:35,506
obviously if it is push model, from the receiver

387
00:25:35,538 --> 00:25:38,898
side, it is all about the data coming to it. So it's

388
00:25:38,914 --> 00:25:42,874
inbound communication right? Now, I know these

389
00:25:42,912 --> 00:25:46,330
terms are a bit computing to understand, but let me give an example.

390
00:25:46,400 --> 00:25:49,974
It's simpler. So the example I just gave for callback, as I demonstrated,

391
00:25:50,022 --> 00:25:52,400
is for a payment system,

392
00:25:53,170 --> 00:25:56,734
the external partner can be visa and it got the URL, it processed and

393
00:25:56,772 --> 00:26:00,474
sent back. Now let's take an example for webhook

394
00:26:00,522 --> 00:26:04,302
for clarity. What are these events? So imagine

395
00:26:04,366 --> 00:26:06,980
there is slack application, like a chat application,

396
00:26:07,830 --> 00:26:12,114
which is you often see at work as

397
00:26:12,152 --> 00:26:16,078
a developer, right? When there is a GitHub activity, pull request has

398
00:26:16,104 --> 00:26:20,182
been created, pull request has been merged, comments have been made, you get this

399
00:26:20,236 --> 00:26:23,240
notification onto the slack. How is that happening?

400
00:26:23,610 --> 00:26:27,170
That's because say creating a pull request

401
00:26:27,250 --> 00:26:31,254
is an event and that event is happening. And the slack

402
00:26:31,382 --> 00:26:34,746
is the microservice two here, or you can think of

403
00:26:34,768 --> 00:26:38,118
microservice two and one. All of this system is slack,

404
00:26:38,214 --> 00:26:42,138
and external partner is GitHub. And whenever there is an event on the external

405
00:26:42,154 --> 00:26:46,110
partner like GitHub, when that

406
00:26:46,180 --> 00:26:49,520
event is triggered, it actually

407
00:26:49,890 --> 00:26:53,822
sends web books are initiated by those events.

408
00:26:53,966 --> 00:26:57,714
And then the sender makes a HTTP call,

409
00:26:57,832 --> 00:27:02,098
which is the sender here is GitHub. It makes a HTTP call to the

410
00:27:02,264 --> 00:27:05,322
defined URL onto the receiver, which is slack,

411
00:27:05,486 --> 00:27:09,400
passing all the data onto it. And that's how

412
00:27:10,730 --> 00:27:14,214
the slack gets to know that, okay, there is a pull

413
00:27:14,252 --> 00:27:17,686
request update or whatever has happened. And as

414
00:27:17,708 --> 00:27:21,366
you can see, webhooks are always asynchronous. You're not waiting

415
00:27:21,398 --> 00:27:24,966
on anything, but the callbacks

416
00:27:24,998 --> 00:27:28,086
can sometimes be synchronous. Like once you send the request to a third party,

417
00:27:28,118 --> 00:27:31,550
it is possible that you can wait and you can get back the response.

418
00:27:32,450 --> 00:27:35,274
So moving on to the next chapter.

419
00:27:35,322 --> 00:27:39,226
Now is another aspect of APIs is rate limiting.

420
00:27:39,338 --> 00:27:43,090
Now designing rate limiting for APIs. So what is

421
00:27:43,160 --> 00:27:46,766
rate limiting and why? And the term

422
00:27:46,798 --> 00:27:50,018
itself says you have to limit the rate.

423
00:27:50,184 --> 00:27:53,780
So say if you are a user using,

424
00:27:54,230 --> 00:27:58,146
doing some payments on the payment system, or you're

425
00:27:58,178 --> 00:28:01,606
using again uploading lot of pictures or accessing lot

426
00:28:01,628 --> 00:28:04,854
of comments. You can click on, say,

427
00:28:04,892 --> 00:28:08,070
comments multiple times as a user, or you can

428
00:28:08,140 --> 00:28:11,754
actually click on too many pay button or

429
00:28:11,792 --> 00:28:15,466
payments on a payment system. And there has to

430
00:28:15,488 --> 00:28:18,502
be a way to limit, or you're trying to do a lot of purchases,

431
00:28:18,566 --> 00:28:21,722
right? So there has to be a way in the system to limit it.

432
00:28:21,856 --> 00:28:25,326
And how can you do it at the API level and why should you

433
00:28:25,348 --> 00:28:28,894
limit it? So it's like limiting the total number of requests coming from

434
00:28:28,932 --> 00:28:33,402
a client in a specific time window. Say you're

435
00:28:33,466 --> 00:28:37,518
making a request, API request in say ten requests in

436
00:28:37,604 --> 00:28:41,486
say 30 minutes, 40 minutes, that's fine. But you need to know it's

437
00:28:41,518 --> 00:28:44,340
a two dimensional thing. Ten requests in 1 second.

438
00:28:45,430 --> 00:28:48,760
So those are the things that need to be defined as a system

439
00:28:49,290 --> 00:28:52,886
capacity and things like that. Now why

440
00:28:52,908 --> 00:28:56,198
is it needed? I wrote it here. Obviously you want

441
00:28:56,204 --> 00:28:59,570
to prevent abuse and there might be a lot of other users who

442
00:28:59,580 --> 00:29:03,146
are using the same endpoint. So you want to have fair access to

443
00:29:03,168 --> 00:29:06,438
these resources and you don't want API to be overwhelmed

444
00:29:06,534 --> 00:29:10,650
by these excessive requests. And this also promotes

445
00:29:12,110 --> 00:29:15,458
the stability for the system and of the distributed systems.

446
00:29:15,494 --> 00:29:19,786
And also the reliability is guaranteed

447
00:29:19,898 --> 00:29:23,198
with you saying that, okay, you're not abusing the system. And you

448
00:29:23,204 --> 00:29:26,482
can see in this diagram, when there are a lot of requests which are coming

449
00:29:26,536 --> 00:29:29,714
onto the system, the rate

450
00:29:29,752 --> 00:29:33,042
limiter sends immediately 429 saying that, okay,

451
00:29:33,096 --> 00:29:36,594
you have exceeded certain limit on the number

452
00:29:36,632 --> 00:29:40,646
of requests that can go. And this logic can either be

453
00:29:40,668 --> 00:29:44,386
written at the gateway or it can be like at the HTTP

454
00:29:44,418 --> 00:29:48,230
level, or it can be written in the back end system itself.

455
00:29:48,380 --> 00:29:52,854
But I personally always designed where the systems

456
00:29:52,982 --> 00:29:56,854
do the rate limiting at the gateway layer. And again, this is a vast topic.

457
00:29:56,902 --> 00:30:00,922
It's a trade off. Again, we can discuss pros and cons in any different session.

458
00:30:01,066 --> 00:30:05,294
Now let's go to the implementation of this. It's quite simple.

459
00:30:05,492 --> 00:30:08,986
I took the same similar language example I'm

460
00:30:09,018 --> 00:30:12,522
using. Like the Java spring boot application. You can see

461
00:30:12,596 --> 00:30:16,382
a rate limit API here. The base URI

462
00:30:16,446 --> 00:30:20,286
is API and base path

463
00:30:20,318 --> 00:30:24,222
is API. And then for any specific resource,

464
00:30:24,366 --> 00:30:29,622
you have resource as the

465
00:30:29,676 --> 00:30:33,442
extended URI. And whenever someone calls

466
00:30:33,506 --> 00:30:37,126
at this endpoint, you can

467
00:30:37,148 --> 00:30:40,534
actually just annotate it. Say you see here, the annotation

468
00:30:40,582 --> 00:30:45,258
here is limit five duration 60. That means one

469
00:30:45,424 --> 00:30:49,786
client can't request or call this API at

470
00:30:49,808 --> 00:30:53,534
this endpoint for more than

471
00:30:53,652 --> 00:30:57,838
five times in 60 seconds. So if

472
00:30:57,924 --> 00:31:01,262
the client is making a request more than five times in 60

473
00:31:01,316 --> 00:31:04,874
seconds, that means he will be rate limited. He or she won't

474
00:31:04,922 --> 00:31:08,434
be able to get a response saying 429 or saying that

475
00:31:08,472 --> 00:31:12,642
yeah, you can't access more than this or rate limited whatever,

476
00:31:12,696 --> 00:31:15,950
be the message. That is debatable. So it's just about annotating.

477
00:31:16,030 --> 00:31:19,926
So ensure when you're designing APIs and we're implementing, you need to

478
00:31:20,028 --> 00:31:23,542
have that rate limiting aspect in your mind as

479
00:31:23,596 --> 00:31:27,838
a very important one in these large data intensive applications

480
00:31:27,954 --> 00:31:31,290
when there might be lots and lots of requests you can't even imagine.

481
00:31:31,630 --> 00:31:35,654
Now the last aspect of the API design is idempotency.

482
00:31:35,702 --> 00:31:38,410
Now what is idempotency?

483
00:31:39,550 --> 00:31:43,566
Now I'll take the payment example again. Payment system, say you

484
00:31:43,588 --> 00:31:47,326
are an end user and you did a

485
00:31:47,428 --> 00:31:51,086
payment, right? So what happens when you make a payment?

486
00:31:51,268 --> 00:31:54,690
The request goes to the HTTP request goes to like a post

487
00:31:54,760 --> 00:31:58,418
pay request goes to a payment system. And what if

488
00:31:58,504 --> 00:32:01,380
you immediately attempted a pay the second time?

489
00:32:02,150 --> 00:32:06,210
Immediately, instantly, because the button is still enabled due to some UI

490
00:32:06,370 --> 00:32:10,086
issue or whatever, be the reason, right? Do you want your money to

491
00:32:10,108 --> 00:32:16,774
be deducted twice or what?

492
00:32:16,892 --> 00:32:20,230
No matter how many times you perform the

493
00:32:20,300 --> 00:32:23,622
activity of, say, pay or any other

494
00:32:23,676 --> 00:32:27,066
activity which are supposed to be idempotent, not all aps are

495
00:32:27,088 --> 00:32:30,890
idempotent. So that's an important one. So pay is definitely idempotent.

496
00:32:32,030 --> 00:32:35,658
The response should be same. Here in this example you see the first attempt

497
00:32:35,754 --> 00:32:39,466
payment and second payment retry both have the same response.

498
00:32:39,498 --> 00:32:43,034
Payment succeeded and there won't be any additional operation.

499
00:32:43,082 --> 00:32:46,450
In the first operation the money gets deducted from your account in the payment

500
00:32:46,520 --> 00:32:50,066
system and all the processing happens. And the second

501
00:32:50,248 --> 00:32:53,922
retry. In the retry, all that doesn't happen, the money

502
00:32:53,976 --> 00:32:56,850
doesn't get deducted. And how this can be prevented,

503
00:32:56,930 --> 00:33:00,760
how can this be done? It's simple. It's as simple as

504
00:33:02,570 --> 00:33:05,734
you can have a database. I mentioned

505
00:33:05,772 --> 00:33:09,370
it in purple box here. Every request

506
00:33:10,350 --> 00:33:14,380
should be associated with an item potency key, a unique key

507
00:33:14,830 --> 00:33:18,534
associated with a specific client, and this item

508
00:33:18,582 --> 00:33:21,530
potency key need not be added by the client.

509
00:33:21,950 --> 00:33:25,806
And for simplicity, I just didn't put any boxes in between client and

510
00:33:25,828 --> 00:33:29,790
payment system, but this can be handled by a separate service

511
00:33:29,860 --> 00:33:33,390
within the back end system itself or at the gateway. Again,

512
00:33:33,460 --> 00:33:36,130
that's debatable. It's a design choice.

513
00:33:36,470 --> 00:33:39,922
So let's assume that is sorted out and for

514
00:33:39,976 --> 00:33:43,906
every request, unique request which is coming from a specific client will

515
00:33:43,928 --> 00:33:47,810
have an item put in c key. And it's like a UUId.

516
00:33:47,890 --> 00:33:51,622
I gave that example. One, two, three, ABC. When the first payment

517
00:33:51,676 --> 00:33:55,490
is made that gets entered into the database

518
00:33:55,650 --> 00:33:59,718
and you can see when the second attempt, the payment retry

519
00:33:59,894 --> 00:34:03,770
happens. The backend system checks.

520
00:34:04,270 --> 00:34:07,706
Is there any entry in the database? It's like

521
00:34:07,728 --> 00:34:11,178
a simple key value. It can be a map or any key value like

522
00:34:11,184 --> 00:34:14,590
a redis cache or whatever it is, right? Again, that's a design choice.

523
00:34:15,010 --> 00:34:18,526
The system will check whether there is an existing key

524
00:34:18,548 --> 00:34:22,094
in the db or not. So it doesn't process the same

525
00:34:22,132 --> 00:34:25,470
request again the moment it finds that key in the DB.

526
00:34:25,630 --> 00:34:29,154
And once it checks and oh, there is already

527
00:34:29,192 --> 00:34:32,446
this existing one and then boom, sends the same response

528
00:34:32,478 --> 00:34:36,038
again without any additional processing. Let's take an example

529
00:34:36,124 --> 00:34:40,006
again like spring boot application I was showing you earlier. And the

530
00:34:40,028 --> 00:34:44,726
same example, you can see this

531
00:34:44,748 --> 00:34:48,250
is another API API handler like user

532
00:34:48,670 --> 00:34:52,214
controller. Say it's like update user.

533
00:34:52,262 --> 00:34:55,754
I took an example, update user. Someone is making

534
00:34:55,792 --> 00:34:59,050
a call to update some details of a user

535
00:34:59,970 --> 00:35:03,370
and when in the request,

536
00:35:03,530 --> 00:35:06,862
the user id, when it is obtained you can see

537
00:35:06,916 --> 00:35:10,030
the implementation. You are

538
00:35:10,100 --> 00:35:13,914
actually accessing the db. Here I use DB

539
00:35:13,962 --> 00:35:17,706
as a user map, as the dB dal get dB

540
00:35:17,738 --> 00:35:21,678
table data access layer gets the table and in

541
00:35:21,764 --> 00:35:25,720
user map you check whether that

542
00:35:26,650 --> 00:35:30,646
key is already contained or not. And this user id is the

543
00:35:30,748 --> 00:35:34,662
idempotent key and whatever

544
00:35:34,716 --> 00:35:39,170
the UUID I gave in the previous example. And if it is already contained

545
00:35:39,330 --> 00:35:43,398
then you just send that response saying user information is already contained

546
00:35:43,414 --> 00:35:46,700
or whatever, the payment is already succeeded and you don't have to do anything.

547
00:35:47,070 --> 00:35:50,780
Only if it is not contained in the DB, then you go ahead with

548
00:35:51,630 --> 00:35:55,340
whatever the database update or payment

549
00:35:55,950 --> 00:35:59,040
calculation by deducting from the account and things like that.

550
00:35:59,490 --> 00:36:02,946
So yes, that's it. So these

551
00:36:02,968 --> 00:36:06,786
are the four, some of

552
00:36:06,808 --> 00:36:11,890
the important design aspects that needs to be considered

553
00:36:12,230 --> 00:36:15,826
while designing APIs

554
00:36:15,858 --> 00:36:19,640
for data intensive applications. And there are many more

555
00:36:20,410 --> 00:36:25,206
security aspects of the system and

556
00:36:25,388 --> 00:36:28,934
pagination and filtering that can be done when you have

557
00:36:28,972 --> 00:36:32,186
lot of data coming from the server. And how do

558
00:36:32,208 --> 00:36:36,380
you do pagination and in the APIs and how do you implement that and

559
00:36:37,150 --> 00:36:40,538
how do you incorporate the security and other aspects of

560
00:36:40,544 --> 00:36:43,990
the system and error handling, because you have lots and

561
00:36:44,000 --> 00:36:47,134
lots of requests coming. You obviously have lots and lots of errors also

562
00:36:47,252 --> 00:36:51,386
coming. And how do you write the APIs in such a way that the response

563
00:36:51,498 --> 00:36:55,026
also contains the proper error message and error handling is in

564
00:36:55,048 --> 00:36:58,546
the right way in the API contract. So these are some of

565
00:36:58,568 --> 00:37:01,842
the other things which I couldn't cover

566
00:37:01,896 --> 00:37:06,102
in this session because I wanted to keep it short

567
00:37:06,236 --> 00:37:10,054
and maybe I

568
00:37:10,092 --> 00:37:13,542
can have some other opportunity to talk more

569
00:37:13,596 --> 00:37:17,334
in details about this. But yeah, thanks a lot

570
00:37:17,452 --> 00:37:21,480
for this opportunity. I really thank the Conf

571
00:37:22,650 --> 00:37:26,870
42 Python team for providing me this opportunity to speak.

572
00:37:27,020 --> 00:37:29,998
And any questions anyone have,

573
00:37:30,044 --> 00:37:33,280
has, can reach out to me.

574
00:37:33,810 --> 00:37:37,226
I'm Santosh. Nikhil Kumar,

575
00:37:37,418 --> 00:37:40,766
available on LinkedIn. And, yeah, thanks a lot

576
00:37:40,788 --> 00:37:41,500
for watching the video.

