1
00:00:25,090 --> 00:00:29,186
Everyone, my name is Sohan Maheshwar. I'm a dev advocate at Fermion

2
00:00:29,298 --> 00:00:33,142
and I'm here to talk to you about why the future of the cloud is

3
00:00:33,196 --> 00:00:36,630
webassembly. Now, if you haven't heard of Webassembly before, no problem.

4
00:00:36,700 --> 00:00:40,040
That's what I'm here for. So let's dive straight in.

5
00:00:40,570 --> 00:00:43,846
I've worked in cloud computing for a while. My previous role wasm in

6
00:00:43,868 --> 00:00:48,402
Amazon Web services, or AWS. So I've really seen the evolution of cloud computing.

7
00:00:48,546 --> 00:00:52,302
I'm old enough to remember a time when the pre cloud days,

8
00:00:52,356 --> 00:00:56,250
when there was a server room in every office which had an air condition.

9
00:00:56,410 --> 00:00:59,566
It was locked, heavy security, no one was allowed to enter.

10
00:00:59,748 --> 00:01:02,954
It was a different time. And then finally, with the release

11
00:01:03,002 --> 00:01:06,562
of things like EC two, we actually saw virtualization and

12
00:01:06,616 --> 00:01:10,418
widespread adoption of virtual machines. But us,

13
00:01:10,504 --> 00:01:13,730
we as us as developers, we still had to use

14
00:01:13,880 --> 00:01:17,466
or we had to take care of things like the kernel, the drivers, the operating

15
00:01:17,518 --> 00:01:20,994
system, the utilities, and of course the business logic

16
00:01:21,042 --> 00:01:24,274
that made up your app that ran on this virtual machine.

17
00:01:24,402 --> 00:01:28,406
Containers took that a step forward in sort of removing some of

18
00:01:28,428 --> 00:01:32,138
that effort that you required. You still had to configure things like

19
00:01:32,224 --> 00:01:35,834
either docker or kubernetes for orchestration while still looking at

20
00:01:35,872 --> 00:01:39,740
things like your OS and utilities and building your app.

21
00:01:40,270 --> 00:01:43,934
Of course, the latest and greatest in computing is

22
00:01:43,972 --> 00:01:47,994
serverless, where you can solely focus on your business logic

23
00:01:48,042 --> 00:01:51,646
and the platform really takes care of the rest. So where

24
00:01:51,668 --> 00:01:55,666
I'd assume most of us right now are, are at the containers or the

25
00:01:55,688 --> 00:01:59,042
serverless stage. And with the current

26
00:01:59,096 --> 00:02:02,782
state of containers and serverless, there are a couple of problems that really plague

27
00:02:02,846 --> 00:02:06,134
the ecosystem. One is

28
00:02:06,252 --> 00:02:09,622
that containers are just too expensive. They over

29
00:02:09,676 --> 00:02:13,842
consume resources. We do know that containers can get complicated,

30
00:02:13,906 --> 00:02:17,606
but teams have built out large platform engineering teams and DevOps to

31
00:02:17,628 --> 00:02:21,802
be able to run these containers. But the thing is, when we're provisioning for

32
00:02:21,856 --> 00:02:25,690
a container or for a workload, we actually look at what

33
00:02:25,760 --> 00:02:29,594
the peak of that consumption is, even though our average is

34
00:02:29,632 --> 00:02:33,646
much lower. So as a result, we end up over provisioning containers all

35
00:02:33,668 --> 00:02:37,530
the time. And these containers sit idle. They're running, they're consuming

36
00:02:37,610 --> 00:02:40,714
electricity, so they're not sustainable, they're also costly,

37
00:02:40,762 --> 00:02:44,998
and they leave systems idling. Right? And this report at Andersine

38
00:02:45,034 --> 00:02:48,690
Horowitz actually estimates about 100 billion of market value

39
00:02:48,840 --> 00:02:52,434
being lost purely because of this, which is pretty

40
00:02:52,472 --> 00:02:56,446
insane. Secondly, app configs are complex.

41
00:02:56,558 --> 00:03:00,694
I think we know this. If you're a small company, you don't necessarily need

42
00:03:00,732 --> 00:03:04,822
like a huge Kubernetes orchestration all the time, but because

43
00:03:04,876 --> 00:03:08,182
this gets complex and more complex, the bigger your

44
00:03:08,236 --> 00:03:12,058
app becomes. And honestly, modern apps do comprise a large number of

45
00:03:12,064 --> 00:03:15,754
frameworks, language dependencies, libraries, all of which need

46
00:03:15,792 --> 00:03:19,258
to be shipped alongside your containers and your code in the

47
00:03:19,264 --> 00:03:22,526
cloud. So this just increases the complexity, so the

48
00:03:22,548 --> 00:03:25,246
portability of your workload or your code base,

49
00:03:25,348 --> 00:03:28,974
and the simplicity is often sacrificed so

50
00:03:29,012 --> 00:03:32,774
that you can actually support a variety of architectures

51
00:03:32,842 --> 00:03:37,134
and platforms. And specifically with serverless.

52
00:03:37,262 --> 00:03:40,594
One big problem that we see and we hear from customers is that

53
00:03:40,632 --> 00:03:43,218
serverless does have a cold started problem.

54
00:03:43,384 --> 00:03:46,566
So roughly how serverless works is an

55
00:03:46,588 --> 00:03:50,146
event occurs. This event basically pings some compute

56
00:03:50,178 --> 00:03:53,474
resource that's running in the cloud, say AWS, lambda,

57
00:03:53,522 --> 00:03:57,090
azure functions, whatever. So there is a finite

58
00:03:57,170 --> 00:04:00,578
start, a finite amount of time for that

59
00:04:00,764 --> 00:04:03,578
function running in that compute in the cloud to start up,

60
00:04:03,664 --> 00:04:07,034
execute the program and send a response back. And that is

61
00:04:07,072 --> 00:04:10,646
called a cold start time. So solutions like lambda

62
00:04:10,678 --> 00:04:14,090
or Azure functions, they take about two to 3 seconds

63
00:04:14,170 --> 00:04:17,822
and on an average we see about 250 to 500 milliseconds of

64
00:04:17,876 --> 00:04:21,770
cold start time. Now for applications where this is vital,

65
00:04:21,930 --> 00:04:25,258
this could be a problem. So there are ways to

66
00:04:25,284 --> 00:04:28,622
work around this of course by keeping the instance warm,

67
00:04:28,686 --> 00:04:32,180
for instance. But this cost is borne by you as a dev.

68
00:04:32,950 --> 00:04:36,222
So keeping all of this in mind, I'm going to make a bold

69
00:04:36,286 --> 00:04:39,906
statement, which is the next wave of cloud compute will be powered

70
00:04:39,938 --> 00:04:43,554
by webassembly, specifically serverless webassembly.

71
00:04:43,682 --> 00:04:47,282
And honestly, if you don't believe me, I'm just a random person on the Internet.

72
00:04:47,426 --> 00:04:51,366
Take a look at this tweet from, I think it was mid 2010s

73
00:04:51,388 --> 00:04:54,486
or at least 2018 or 19 by Solomon

74
00:04:54,518 --> 00:04:57,754
hikes. Now he's the founder of Docker and

75
00:04:57,792 --> 00:05:01,590
he actually mentions if WASM, which is Webassembly, plus WaSM,

76
00:05:01,670 --> 00:05:05,594
I'll explain that existed in 2008, we wouldn't have needed to create Docker.

77
00:05:05,642 --> 00:05:09,386
That's how important it is. So if Solomon

78
00:05:09,418 --> 00:05:13,086
Hicks has an insight into tech, the next wave of

79
00:05:13,108 --> 00:05:15,810
cloud computing will be powered by webassembly.

80
00:05:16,230 --> 00:05:19,918
Let's talk a bit about that. Right, so what actually is webassembly?

81
00:05:20,014 --> 00:05:23,838
Now the boring answer is it's just another bytecode format.

82
00:05:23,934 --> 00:05:26,814
So for a program to run on a piece of hardware,

83
00:05:26,862 --> 00:05:31,158
it has to be written in an intermediate type code or a low level code

84
00:05:31,244 --> 00:05:34,886
that a computer can understand. And essentially that's what a

85
00:05:34,908 --> 00:05:39,430
bytecode format is. So WebAssembly is just another bytecode format.

86
00:05:40,170 --> 00:05:43,594
The interesting thing for you to know is this technology,

87
00:05:43,792 --> 00:05:47,414
it's a general tech, it's not owned by any company. It was developed

88
00:05:47,462 --> 00:05:50,618
sometime in the mid 2010s by a bunch of companies

89
00:05:50,704 --> 00:05:54,218
working in the browser and front end space. So I think Mozilla

90
00:05:54,314 --> 00:05:57,694
and few others. And the idea was for

91
00:05:57,732 --> 00:06:01,498
it to be able to run any program on a browser

92
00:06:01,674 --> 00:06:05,410
and hence the name Webassembly. And it wasm

93
00:06:05,480 --> 00:06:09,406
designed from the ground up as a portable compilation target.

94
00:06:09,598 --> 00:06:13,262
And this means that you could write code in any language,

95
00:06:13,326 --> 00:06:17,282
say Python, Java, JavaScript, ideally any language that could compile

96
00:06:17,346 --> 00:06:20,870
to Webassembly and that could

97
00:06:20,940 --> 00:06:23,446
run in any browser. So that was the idea.

98
00:06:23,628 --> 00:06:28,114
You'll hear me say wasm a lot. And wasm is just short for webassembly.

99
00:06:28,242 --> 00:06:32,298
So how this would work essentially is in a way similar

100
00:06:32,384 --> 00:06:35,978
to how the Java virtual machine worked from back in

101
00:06:35,984 --> 00:06:39,370
the day. So you wrote a program in Java, this compiled to

102
00:06:39,440 --> 00:06:43,214
something called Java Bytecode, the thing that I mentioned earlier. And this

103
00:06:43,252 --> 00:06:47,226
Java bytecode could execute in any Java virtual machine.

104
00:06:47,338 --> 00:06:51,534
And these Java virtual machines could run on Arm processors and x 86

105
00:06:51,572 --> 00:06:54,834
processors. They could run on windows and Linux as

106
00:06:54,872 --> 00:06:58,114
well. The cool thing about Webassembly is you can

107
00:06:58,152 --> 00:07:01,470
write any program in any language, again ideally,

108
00:07:01,630 --> 00:07:05,042
and compile this to a WaSM module which is

109
00:07:05,096 --> 00:07:08,178
in the format of the webassembly bytecode that I spoke

110
00:07:08,194 --> 00:07:12,034
about. Now this WaSm bytecode can execute in any runtime

111
00:07:12,082 --> 00:07:15,366
that supports WaSM. The industry standard or the most

112
00:07:15,388 --> 00:07:18,346
popular one right now is a runtime called WaSM Time.

113
00:07:18,448 --> 00:07:22,406
So any wasm bytecode can run on a webassembly runtime.

114
00:07:22,518 --> 00:07:25,814
And this runtime is designed to run across architecture.

115
00:07:25,862 --> 00:07:29,894
So Arm x 86 whatever operating

116
00:07:29,942 --> 00:07:33,422
system, so windows, Mac, Linux, et cetera. But you can also run it

117
00:07:33,476 --> 00:07:37,310
on Kubernetes, on Raspberry PI and so on.

118
00:07:37,380 --> 00:07:41,390
Literally any place that has support for a webassembly runtime.

119
00:07:41,730 --> 00:07:45,326
A couple of other things to know about WebAssembly is, like I

120
00:07:45,348 --> 00:07:48,738
said, it originated from the browser, but now is available outside

121
00:07:48,824 --> 00:07:52,414
as well. And really the idea was for you to be able to compile

122
00:07:52,462 --> 00:07:55,966
it once and run that code on any number of targets. So once

123
00:07:56,008 --> 00:07:59,746
you've compiled from a program, say in Python to a WASM

124
00:07:59,778 --> 00:08:03,494
format or a webassembly module, this webassembly module should

125
00:08:03,532 --> 00:08:07,080
be able to run anywhere. And that was the idea.

126
00:08:07,610 --> 00:08:11,814
Another cool thing about webassembly is it's security sandboxed

127
00:08:11,862 --> 00:08:15,962
by default. This is very different from the

128
00:08:16,096 --> 00:08:20,250
different ways we have been coding in the past where you had to specify

129
00:08:21,550 --> 00:08:25,754
what you had, resources you could deny it wasn't sandboxed by default.

130
00:08:25,882 --> 00:08:29,658
Webassembly, though, is the other way around. It's completely sandboxed by default.

131
00:08:29,754 --> 00:08:33,310
So for anything to access a webassembly module, you have to

132
00:08:33,380 --> 00:08:36,658
explicitly give it permissions. This is

133
00:08:36,664 --> 00:08:39,906
how you would compile and run a Webassembly module. You'd write code in

134
00:08:39,928 --> 00:08:43,506
any language, you would compile that to Webassembly, and Webassembly would

135
00:08:43,528 --> 00:08:47,458
then run in a, let's call it virtual machine, but any WaSM

136
00:08:47,554 --> 00:08:51,538
runtime. Now, all of these things, right, the portability,

137
00:08:51,714 --> 00:08:55,494
the security sandbox, the fact that you could write

138
00:08:55,532 --> 00:08:58,694
once, compile once, and run it anywhere, all of these

139
00:08:58,732 --> 00:09:01,946
things made it very good for the browser. People were

140
00:09:01,968 --> 00:09:05,366
like, hey, hold on, this could actually make it ideal for server

141
00:09:05,398 --> 00:09:09,034
side, but for anything to run on a server, you need things

142
00:09:09,072 --> 00:09:12,702
like access to files and file systems, you need access to a system

143
00:09:12,756 --> 00:09:16,046
clock, you need access to the network as well.

144
00:09:16,148 --> 00:09:19,166
So what happened was sometime in 20,

145
00:09:19,188 --> 00:09:23,194
18, 19, something called Wozi was introduced, and Wozi stood

146
00:09:23,242 --> 00:09:26,766
for a new kind of system interface, or Webassembly systems

147
00:09:26,798 --> 00:09:30,286
interface. In short, it allowed you to run webassembly

148
00:09:30,398 --> 00:09:34,258
outside of the browser. And the cool thing is it gave you access

149
00:09:34,344 --> 00:09:36,910
to all your operating system like features,

150
00:09:36,990 --> 00:09:40,454
including files and file systems, clocks, random numbers and so

151
00:09:40,492 --> 00:09:43,894
on. The good thing is it wasn't tied to any

152
00:09:43,932 --> 00:09:47,250
browser or front end or web API or JavaScript.

153
00:09:47,330 --> 00:09:51,626
You can literally run it on a server side, and it extends this security

154
00:09:51,728 --> 00:09:55,722
sandboxing to include things like input output. So you

155
00:09:55,776 --> 00:10:00,506
still have the default security sandbox if

156
00:10:00,528 --> 00:10:04,214
you take a look at it, among the top 20 languages in Redmonks

157
00:10:04,262 --> 00:10:07,598
ranking, which by the way, I think they released a new one a couple of

158
00:10:07,604 --> 00:10:11,054
days ago. So I should update this slide the top 20 rankings, that is,

159
00:10:11,172 --> 00:10:14,978
as you can see, Webassembly supported by most of

160
00:10:14,984 --> 00:10:18,114
the languages. Of course, things like CSS don't really apply here,

161
00:10:18,152 --> 00:10:21,554
but JavaScript, Python, Java, Php Net,

162
00:10:21,592 --> 00:10:24,754
C plus plus, typescript, Ruby, but also Zig C,

163
00:10:24,872 --> 00:10:28,774
Rust, all of them have good or very

164
00:10:28,812 --> 00:10:32,626
good levels of support when you write code in WebAssembly and compile

165
00:10:32,658 --> 00:10:36,054
it to these languages. So now this,

166
00:10:36,092 --> 00:10:39,414
I know you're a technical person and you're seeing this, so let's get into some

167
00:10:39,452 --> 00:10:43,094
code, right? How do you write your first WebAssembly app on the server

168
00:10:43,142 --> 00:10:46,970
side? And then we'll talk about why this will be the future of

169
00:10:47,040 --> 00:10:50,186
the cloud. I'm going to show you this through an

170
00:10:50,208 --> 00:10:54,106
open source project called Spin. Spin is the open source

171
00:10:54,138 --> 00:10:57,422
tool for building webassembly serverless apps with

172
00:10:57,476 --> 00:11:01,726
three commands that you see on the screen here. I'm actually going to build

173
00:11:01,828 --> 00:11:05,602
and test spin app locally and with the fourth command we will also

174
00:11:05,656 --> 00:11:09,570
deploy it to the cloud. Spin, just to

175
00:11:09,640 --> 00:11:13,474
reiterate, is completely open source and we have a commitment for it to be open

176
00:11:13,512 --> 00:11:16,934
source. It supports 15 plus languages. Right now we have

177
00:11:16,972 --> 00:11:20,806
about 4.6 thousand stars on GitHub. We also

178
00:11:20,828 --> 00:11:24,374
have a discord server, so join in there and

179
00:11:24,572 --> 00:11:28,038
at least I personally think that the developer experience is really good.

180
00:11:28,124 --> 00:11:31,866
So let's just jump into the CLI and try

181
00:11:31,888 --> 00:11:35,542
it out. So I've already installed the CLI, so I'm just going to say spin

182
00:11:35,606 --> 00:11:39,734
new and you can see on the left, you can see HTTP

183
00:11:39,782 --> 00:11:43,134
and redis on the left, which is basically the

184
00:11:43,172 --> 00:11:46,142
trigger to run your serverless function. Remember,

185
00:11:46,196 --> 00:11:49,546
serverless is all event driven, right? So it has to be triggered

186
00:11:49,578 --> 00:11:53,314
by something. And right now spin supports HTTP and

187
00:11:53,432 --> 00:11:57,502
redis, but there are also community created triggers for MQtT

188
00:11:57,566 --> 00:12:01,342
and SQs. On the right you'll see languages

189
00:12:01,406 --> 00:12:05,066
such as C, go, grain, pHp, Python, rust, Swift,

190
00:12:05,118 --> 00:12:08,850
et cetera. Let's just choose rust. These are the different languages

191
00:12:08,930 --> 00:12:13,160
that are supported. I will call it conf 42.

192
00:12:13,530 --> 00:12:16,806
Rust description and this is

193
00:12:16,908 --> 00:12:20,266
the HTTP path. You can specify when

194
00:12:20,368 --> 00:12:24,442
your serverless function is triggered. So say checkout or

195
00:12:24,576 --> 00:12:28,026
resize or whatever. I can leave it blank, which means this is

196
00:12:28,048 --> 00:12:31,680
default and it will be triggered when this path is hit.

197
00:12:32,290 --> 00:12:36,430
So let's go into the folder

198
00:12:37,170 --> 00:12:41,146
and I will open it in my favorite code editor, which is vs

199
00:12:41,178 --> 00:12:45,294
code. Just two things you need to know about a serverless

200
00:12:45,342 --> 00:12:48,914
webassembly app using spin. The first one is something called

201
00:12:48,952 --> 00:12:52,242
the application manifest, which is this,

202
00:12:52,376 --> 00:12:55,774
right? So this think of it as a manifest file. It's written

203
00:12:55,822 --> 00:12:59,474
in a toml format. All you need to know is this is a trigger

204
00:12:59,522 --> 00:13:02,854
which we just specified. So by default this

205
00:13:02,892 --> 00:13:06,594
particular component will be triggered. You can actually specify multiple

206
00:13:06,642 --> 00:13:09,994
routes and have different components for each. So say

207
00:13:10,032 --> 00:13:13,642
for example you're writing a calculator. So maybe the

208
00:13:13,696 --> 00:13:17,254
plus root will trigger a plus component. The subtraction

209
00:13:17,302 --> 00:13:20,766
route will trigger a subtraction component, and given that this

210
00:13:20,788 --> 00:13:24,874
is webassembly, you can write each of these in a different programming

211
00:13:24,922 --> 00:13:29,402
language. So you can write addition in Python and subtraction in JavaScript

212
00:13:29,466 --> 00:13:31,120
and this would still work.

213
00:13:32,290 --> 00:13:36,046
And as you can see, this is the wasm file that it eventually compiles to,

214
00:13:36,068 --> 00:13:39,362
which I will show you in a bit. Looking at the source code,

215
00:13:39,416 --> 00:13:42,994
it's fairly straightforward. You don't need to worry too much about rust itself.

216
00:13:43,112 --> 00:13:46,546
All you need to know is there's a request that comes in, right? So when

217
00:13:46,568 --> 00:13:50,726
an event is triggered, this particular function, this is the request that comes in

218
00:13:50,828 --> 00:13:54,242
and you send a response back. We can just modify

219
00:13:54,306 --> 00:13:57,320
that into sing. Hello Conf 42.

220
00:13:58,410 --> 00:14:01,866
And yeah, this is the response that's being sent back.

221
00:14:01,968 --> 00:14:06,038
So I promise that with three commands,

222
00:14:06,134 --> 00:14:09,306
we'll get like an app up and running. I've said one, which is pin new.

223
00:14:09,408 --> 00:14:12,158
I will say the second one, which is spin build.

224
00:14:12,244 --> 00:14:15,646
So this is command number two. It's rust, and this

225
00:14:15,668 --> 00:14:17,630
is a one time sort of compilation.

226
00:14:18,610 --> 00:14:22,382
All the crates are compiled in rust. And then we will use

227
00:14:22,436 --> 00:14:25,714
our third command, which is spin up. Right,

228
00:14:25,752 --> 00:14:27,140
which basically,

229
00:14:29,030 --> 00:14:32,466
there we go. What it does is it creates a local instance for you to

230
00:14:32,488 --> 00:14:37,566
test out your app, thereby giving you pretty good developer

231
00:14:37,598 --> 00:14:40,610
experience, because you can test out your app locally.

232
00:14:40,770 --> 00:14:44,374
There we go. And yeah, I just did a curl to that thing that Wasm

233
00:14:44,412 --> 00:14:48,562
running here and you can see hello Conf 42. Right? So three commands.

234
00:14:48,626 --> 00:14:51,706
Got a serverless webassembly app from scratch up

235
00:14:51,728 --> 00:14:55,242
and running to test locally. I'm just going to close

236
00:14:55,296 --> 00:14:59,290
this. I did say with the fourth command I could deploy this to

237
00:14:59,360 --> 00:15:03,374
the cloud. So fermyon does have a fermyon cloud with both free

238
00:15:03,412 --> 00:15:06,686
and paid tiers. I've already logged in here on

239
00:15:06,708 --> 00:15:10,286
my ClI, but with just one command of Spindeploy, you can

240
00:15:10,308 --> 00:15:13,806
see that this particular app will be deployed to the

241
00:15:13,828 --> 00:15:16,978
cloud and we can actually test that out as well.

242
00:15:17,144 --> 00:15:20,514
So, yeah, that's it. I can view the

243
00:15:20,552 --> 00:15:24,226
application here and I can manage it too here. I'm just

244
00:15:24,248 --> 00:15:27,874
going to do the same curl here and we got

245
00:15:27,912 --> 00:15:30,966
the same result. You can feel free to open this app on your browser and

246
00:15:30,988 --> 00:15:33,320
you will see literally the same result again.

247
00:15:33,690 --> 00:15:37,426
So super easy to go from nothing to creating

248
00:15:37,458 --> 00:15:41,658
a serverless webassembly app that's running in the cloud. Just going to close

249
00:15:41,744 --> 00:15:46,214
this and open spin.

250
00:15:46,262 --> 00:15:50,314
Like I said, it's completely open source. And with this SDK, you get access to

251
00:15:50,352 --> 00:15:54,394
a large language model, which is the llama two model. So you can do serverless

252
00:15:54,442 --> 00:15:57,822
AI. So you don't need a large language model running in the cloud and

253
00:15:57,876 --> 00:16:00,894
paying lots of resources. You also get a key value store,

254
00:16:00,932 --> 00:16:04,658
a NoSQL database, custom domains, bunch of other cool things.

255
00:16:04,744 --> 00:16:08,274
So do check it out. So I showed you

256
00:16:08,312 --> 00:16:11,586
the experience of building a webassembly app for

257
00:16:11,608 --> 00:16:15,346
the server side. The four things that really make it suited or

258
00:16:15,368 --> 00:16:19,510
make it ideal for doing this is this, right. So one is

259
00:16:19,580 --> 00:16:23,414
binary size. A simple rust hollow world is only two

260
00:16:23,452 --> 00:16:26,742
MB and ahead of time. Compiled Rust hello World

261
00:16:26,796 --> 00:16:30,246
is about 300 kB. The app that I showed you now,

262
00:16:30,268 --> 00:16:33,866
which is a simple HTTP API written in Rust, is about 2.3

263
00:16:33,888 --> 00:16:37,574
MB, just in time compilation and ahead of time. If you compile

264
00:16:37,622 --> 00:16:41,566
it, you can bring that down to about 1.1 mB. And I can

265
00:16:41,588 --> 00:16:45,658
also show it to you. Let me do CD.

266
00:16:45,834 --> 00:16:48,782
I think it's. Let me do an Ls first.

267
00:16:48,916 --> 00:16:51,630
Yeah, CD target.

268
00:16:51,970 --> 00:16:55,922
Right. And yeah, you can see that this is the

269
00:16:55,976 --> 00:16:59,230
wasm file that you can see it's about two MB,

270
00:16:59,310 --> 00:17:02,930
right. So it's pretty small. I can actually

271
00:17:03,000 --> 00:17:06,758
do. And this is

272
00:17:06,764 --> 00:17:10,310
the bytecode basically, right? Yeah.

273
00:17:10,380 --> 00:17:14,086
So we can't understand most of this stuff. So that is

274
00:17:14,108 --> 00:17:16,120
the wasm bytecode that you're looking at.

275
00:17:17,450 --> 00:17:20,530
The startup times are comparable to near native.

276
00:17:20,610 --> 00:17:24,374
So in the benchmark that you see there, it's about 2.3 x slower

277
00:17:24,422 --> 00:17:28,086
than native. I think that's where there is a bit of a trade

278
00:17:28,118 --> 00:17:31,930
off in terms of binary size versus startup time, but it is

279
00:17:32,000 --> 00:17:35,226
still comparable, and it is near native performance for something that's

280
00:17:35,258 --> 00:17:38,586
not written in rust. The portability we spoke

281
00:17:38,618 --> 00:17:42,266
about where you can build once and run this anywhere. Right. So that wasm

282
00:17:42,298 --> 00:17:45,798
file that you saw should theoretically run on any wasm

283
00:17:45,834 --> 00:17:49,474
time, sorry, on any webassembly runtime out there.

284
00:17:49,672 --> 00:17:52,926
And lastly, there is a security sandbox that I spoke

285
00:17:52,958 --> 00:17:57,126
about. It's completely a capability based security model. In fact,

286
00:17:57,308 --> 00:18:00,710
if you look at the spin toml, you can actually see

287
00:18:00,780 --> 00:18:04,790
something called an allowed outbound host. So if this

288
00:18:04,940 --> 00:18:08,582
model, sorry, if this module had to make a HTTP call,

289
00:18:08,636 --> 00:18:12,138
for instance, you had to explicitly allow it to make a

290
00:18:12,144 --> 00:18:15,642
HTTP call to a particular URL, only then

291
00:18:15,696 --> 00:18:19,258
will it work. Similarly, if you want a file to access

292
00:18:19,344 --> 00:18:23,354
this particular module, you have to give it access to this particular module.

293
00:18:23,482 --> 00:18:26,910
So it is security sandboxed by default.

294
00:18:27,410 --> 00:18:30,942
So the big question is, how is this going to change cloud

295
00:18:30,996 --> 00:18:34,698
computing? And my answer to that is gradually

296
00:18:34,794 --> 00:18:38,562
and then suddenly 2023,

297
00:18:38,616 --> 00:18:41,954
everyone said, is going to be the year of Webassembly. And it didn't really take

298
00:18:41,992 --> 00:18:45,634
off in the way that people expected it to. But now

299
00:18:45,672 --> 00:18:48,846
in 2024, we are seeing so much about webassembly.

300
00:18:48,958 --> 00:18:52,294
Part of my job is to speak at conferences, and I do that maybe three,

301
00:18:52,332 --> 00:18:55,446
four times a month. And there's just so much of an increase in the

302
00:18:55,468 --> 00:18:59,034
number of talks and the number of questions and queries about this

303
00:18:59,072 --> 00:19:02,554
thing of running Webassembly on the server side and in the

304
00:19:02,592 --> 00:19:06,106
cloud. The key to understanding the success of the

305
00:19:06,128 --> 00:19:10,086
cloud is to understand this concept of multitenancy,

306
00:19:10,278 --> 00:19:13,566
which essentially is how multiple applications can run in

307
00:19:13,588 --> 00:19:16,714
a started environment. Now, I'm not going to go into the science

308
00:19:16,762 --> 00:19:20,362
of this, but the analogy is like an apartment

309
00:19:20,426 --> 00:19:24,026
building, right? So instead of one small family, or like few

310
00:19:24,068 --> 00:19:27,282
people staying in a really large building, you break that down

311
00:19:27,336 --> 00:19:30,562
into multiple houses in the same plot of land,

312
00:19:30,696 --> 00:19:33,986
which many tenants can inhabit. And that's the

313
00:19:34,088 --> 00:19:37,638
general idea of cloud computing. The idea,

314
00:19:37,724 --> 00:19:41,382
again, is that any of these tenants that are hosted in

315
00:19:41,436 --> 00:19:44,374
your piece of hardware shouldn't interfere with the other,

316
00:19:44,492 --> 00:19:48,582
intentionally or unintentionally. And that's the key to success for cloud

317
00:19:48,636 --> 00:19:52,074
computing. Now, people have driven, or companies have

318
00:19:52,112 --> 00:19:55,834
driven more and more towards bringing the cost closer to

319
00:19:55,872 --> 00:19:59,242
value, which means increasing the number of tenants in the same

320
00:19:59,296 --> 00:20:03,002
piece of hardware. Because the value of this piece of hardware

321
00:20:03,066 --> 00:20:06,494
is based on your long term average traffic, and the

322
00:20:06,532 --> 00:20:09,802
cost of running the system is based on short term peak

323
00:20:09,866 --> 00:20:13,338
traffic. So the more value you can extract

324
00:20:13,514 --> 00:20:16,994
out of the system, that means you have got more bang for your buck for

325
00:20:17,032 --> 00:20:20,660
that hardware itself. If you look at again,

326
00:20:21,350 --> 00:20:24,946
the waves of cloud computing, when we first started off with

327
00:20:24,968 --> 00:20:28,614
just virtual machines, we could run very few apps on the same

328
00:20:28,652 --> 00:20:32,134
hardware. But I think with containers, you slowly increase the

329
00:20:32,172 --> 00:20:35,430
number of apps you could run on, say, a Kubernetes cluster.

330
00:20:35,930 --> 00:20:39,190
In this final form of serverless webassembly,

331
00:20:39,270 --> 00:20:43,526
you can really pack and have dense workloads

332
00:20:43,558 --> 00:20:47,046
with multiple functions running in the same piece of hardware.

333
00:20:47,238 --> 00:20:50,494
The analogy I love to draw when I'm talking about this

334
00:20:50,532 --> 00:20:54,670
is think of how atoms and molecules think of how molecules are

335
00:20:54,820 --> 00:20:58,010
structured in liquids, solids and gases.

336
00:20:58,170 --> 00:21:01,914
So on your left, what you see is like a gas,

337
00:21:02,042 --> 00:21:05,346
where you have molecules that are kind of loose, and then in

338
00:21:05,368 --> 00:21:08,606
a liquid they are maybe a little closer to each other, but they're

339
00:21:08,638 --> 00:21:12,626
really densely packed in a solid, which gives it its shape and

340
00:21:12,648 --> 00:21:16,194
texture and format. And that's how serverless

341
00:21:16,242 --> 00:21:20,322
webassembly will look. You can really have a high density

342
00:21:20,386 --> 00:21:24,360
of functions in a workload. In fact,

343
00:21:25,290 --> 00:21:29,206
as a serverless unit, webassembly is so ideally suited,

344
00:21:29,318 --> 00:21:32,854
because the people who created the Firecracker VM,

345
00:21:32,902 --> 00:21:36,982
which is the base for AWS lambda,

346
00:21:37,046 --> 00:21:40,778
essentially wrote a paper, and I highly suggest you read that paper that I've linked

347
00:21:40,794 --> 00:21:44,122
at the bottom here, about the characteristics of an ideal

348
00:21:44,186 --> 00:21:48,410
serverless unit. And they define six characteristics which included

349
00:21:48,490 --> 00:21:52,074
isolation. I mentioned it, you could run multiple functions

350
00:21:52,122 --> 00:21:55,854
on the same piece of hardware, overhead and density,

351
00:21:55,902 --> 00:21:59,010
where you can run thousands of functions on a machine with

352
00:21:59,080 --> 00:22:03,234
minimal waste. Three is performance. You should

353
00:22:03,272 --> 00:22:06,600
have consistent and near native performance at all times.

354
00:22:07,610 --> 00:22:10,278
Four is the ability to switch quickly,

355
00:22:10,364 --> 00:22:13,830
right? Essentially not have cloud start times, but open

356
00:22:13,900 --> 00:22:17,094
a serverless unit, run something, shut it down,

357
00:22:17,132 --> 00:22:20,534
and then switch to something else. The ability

358
00:22:20,582 --> 00:22:24,266
to allocate or soft allocations, where if there is a spike in one

359
00:22:24,288 --> 00:22:27,414
of the tenants, you should be able to overcommit resources,

360
00:22:27,462 --> 00:22:32,006
CPU, memory and so on. And lastly, it's compatibility.

361
00:22:32,118 --> 00:22:35,546
I think we as devs we want to use our favorite libraries, our favorite

362
00:22:35,578 --> 00:22:39,086
frameworks, hosts, et cetera. So it has to be compatible with a

363
00:22:39,108 --> 00:22:42,430
bunch of things. We sort of compared

364
00:22:43,250 --> 00:22:46,754
a microvm such as firecracker to webassembly with

365
00:22:46,792 --> 00:22:50,542
these six parameters. So in terms of isolation both are sandboxed.

366
00:22:50,606 --> 00:22:54,718
So a microVM is sandboxed via the Firecracker KVM,

367
00:22:54,814 --> 00:22:58,840
and webassembly sandboxed via its own security sandbox model.

368
00:22:59,370 --> 00:23:03,234
There are two places where at least I personally think webassembly really shines

369
00:23:03,282 --> 00:23:07,682
compared to a microvM. The first one is overhead and density,

370
00:23:07,826 --> 00:23:11,574
right? So to run thousands per node on a microvm you needed

371
00:23:11,612 --> 00:23:15,818
a 48 core 382 GB RAM with 3360

372
00:23:15,904 --> 00:23:19,722
GB disk. So that's your hardware spec. But you could do the same thing

373
00:23:19,776 --> 00:23:23,146
with an eight conf 42 GB RAM 100 GB disk

374
00:23:23,178 --> 00:23:26,462
if you use webassembly, because it is so lightweight and

375
00:23:26,516 --> 00:23:30,046
performant performance in

376
00:23:30,148 --> 00:23:33,934
both are near native, so nothing to compare there.

377
00:23:34,132 --> 00:23:37,522
Fast switching, I think is the second thing where webassembly really

378
00:23:37,576 --> 00:23:41,122
shines. We did mention microvms do have cold start times

379
00:23:41,176 --> 00:23:45,074
from 125 to even 500 milliseconds, whereas with

380
00:23:45,112 --> 00:23:48,962
webassembly that's down to about a millisecond. Right? And you can scale

381
00:23:49,026 --> 00:23:52,246
up to like thousands of functions in that

382
00:23:52,268 --> 00:23:56,038
node and then scale back down to zero in under a

383
00:23:56,044 --> 00:23:59,966
millisecond, which is very impressive in terms of soft allocation.

384
00:24:00,018 --> 00:24:03,766
I think with things like Lambda and even azure functions, they've been tried and tested

385
00:24:03,798 --> 00:24:07,398
that you can run these in production in enterprise grade

386
00:24:07,494 --> 00:24:10,826
with oversubscription ratios as high as ten X.

387
00:24:10,928 --> 00:24:14,318
Webassembly is new, so it's untested. But I have a feeling by the end

388
00:24:14,324 --> 00:24:17,706
of this year we'll really get to see how software

389
00:24:17,738 --> 00:24:21,310
allocation would work when it comes to Webassembly.

390
00:24:22,290 --> 00:24:26,014
In terms of compatibility, microvms are Linux and KVM

391
00:24:26,062 --> 00:24:30,030
only. Most software is compatible unless it has very specific hardware

392
00:24:30,110 --> 00:24:34,100
requirements. Webassembly, like we said, was designed to be

393
00:24:34,470 --> 00:24:38,230
compiled once, run anywhere. So it supports a bunch of all

394
00:24:38,300 --> 00:24:41,880
OSS platforms, architectures and so on.

395
00:24:42,330 --> 00:24:46,310
Now, just a few days ago we launched something called

396
00:24:46,380 --> 00:24:50,486
Spincube, and I'm super excited to talk about this because it ties into so

397
00:24:50,508 --> 00:24:53,782
many of the things that we just spoke about, which is things like density,

398
00:24:53,846 --> 00:24:57,466
performance and binary size. I'm sure many of

399
00:24:57,488 --> 00:25:00,546
us are either familiar with or work on Kubernetes.

400
00:25:00,678 --> 00:25:04,746
So Spincube is a completely open source project with contributions

401
00:25:04,778 --> 00:25:09,018
from companies like Microsoft, Liquid Reply, souser and Fermion,

402
00:25:09,194 --> 00:25:13,214
and essentially gives you hyper efficient serverless on kubernetes,

403
00:25:13,342 --> 00:25:15,886
completely powered by Webassembly,

404
00:25:16,078 --> 00:25:20,114
it's again fully open source and it just streamlines the development and

405
00:25:20,152 --> 00:25:23,394
deployment process of webassembly workloads on

406
00:25:23,432 --> 00:25:27,074
Kubernetes. You should check out Spincube dev for more

407
00:25:27,112 --> 00:25:31,282
info and the slash spincube. But essentially

408
00:25:31,346 --> 00:25:34,946
when you build a webassembly app that's deployed in Spincube,

409
00:25:35,058 --> 00:25:38,442
these artifacts are significantly smaller in size compared to

410
00:25:38,496 --> 00:25:41,994
a typical container image. So again, think of the

411
00:25:42,032 --> 00:25:45,814
costs, think of your carbon footprint, think of performance

412
00:25:45,942 --> 00:25:49,094
when this actually happens. And these artifacts

413
00:25:49,142 --> 00:25:52,618
can be fetched over the network and started much faster than running a

414
00:25:52,624 --> 00:25:56,234
typical container image. Which also means that substantially fewer

415
00:25:56,282 --> 00:25:59,902
resources are required during times when your container is actually

416
00:25:59,956 --> 00:26:03,514
idling because these webassembly functions

417
00:26:03,562 --> 00:26:07,586
can scale back down to zero in no time. Just to

418
00:26:07,608 --> 00:26:11,410
give you a quick overview of how it works, here's a slightly complicated

419
00:26:11,750 --> 00:26:14,914
architecture diagram. Now if you look at the

420
00:26:14,952 --> 00:26:18,086
bottom here, this is the core of the project, which is

421
00:26:18,108 --> 00:26:22,262
the container D shim spin. Right? So this

422
00:26:22,396 --> 00:26:26,098
uses something called run vazi. And this essentially,

423
00:26:26,274 --> 00:26:29,786
sorry, I need to look at my computer there, enables containerd to sort of

424
00:26:29,808 --> 00:26:33,158
run spin webassembly apps in a Kubernetes cluster.

425
00:26:33,254 --> 00:26:37,162
And it provides all these capabilities needed to pull

426
00:26:37,216 --> 00:26:40,654
an application from a registry to start the application

427
00:26:40,772 --> 00:26:44,446
and so on. Now something called a

428
00:26:44,468 --> 00:26:48,042
runtime class manager. This deploys pre configured images

429
00:26:48,106 --> 00:26:51,902
that can run webassembly workloads. And this works with the container D

430
00:26:51,956 --> 00:26:55,674
shim spin the runtime class manager

431
00:26:55,722 --> 00:26:59,938
was contributed by liquid reply and Sousa. And you

432
00:26:59,944 --> 00:27:03,054
can do things like annotate your nodes, install and configure

433
00:27:03,102 --> 00:27:06,906
container D with this shim. Now something that fermion,

434
00:27:06,958 --> 00:27:10,834
the company I work for, contributed towards this project is this spin

435
00:27:10,882 --> 00:27:14,482
operator here. And spin operator essentially is used to schedule

436
00:27:14,546 --> 00:27:17,838
and manage your spin apps as custom resources.

437
00:27:17,954 --> 00:27:21,974
So what it does is it looks at a custom resource

438
00:27:22,022 --> 00:27:25,706
definition of a spin app for any changes and

439
00:27:25,808 --> 00:27:29,398
it speaks to and creates

440
00:27:29,414 --> 00:27:33,230
a spin app using a specified executor. So you can specify that using

441
00:27:33,300 --> 00:27:37,134
the operator. And lastly, Spin itself has an

442
00:27:37,172 --> 00:27:40,554
ability for anyone to write plugins for it. So there's a plugin

443
00:27:40,602 --> 00:27:44,206
called Cube which essentially scaffolds your spin

444
00:27:44,238 --> 00:27:48,194
app and creates a deployment yaml, which can

445
00:27:48,232 --> 00:27:52,014
then be used by your CRD to sort of deploy into Kubernetes.

446
00:27:52,142 --> 00:27:56,306
So Spincube is all of this combined where you have like the

447
00:27:56,328 --> 00:28:00,470
container d shim, you have runtime class manager, a spin operator and

448
00:28:00,540 --> 00:28:03,926
a spin plugin. Now if you think this is

449
00:28:03,948 --> 00:28:07,474
exciting, we have taken the concept of Spincube and we have amped

450
00:28:07,522 --> 00:28:10,982
it up and we've released something for enterprises called fermion

451
00:28:11,046 --> 00:28:14,918
platform for Kubernetes. Now with this, and I'm

452
00:28:14,934 --> 00:28:18,502
not joking, you can actually get a 50 x increase in workload

453
00:28:18,566 --> 00:28:21,898
density. That's right. You can actually run 5000

454
00:28:21,984 --> 00:28:25,486
serverless apps in one Kubernetes node. Typically that

455
00:28:25,588 --> 00:28:29,146
limit used to be around I think 256 if I'm not mistaken.

456
00:28:29,178 --> 00:28:32,366
That was the maximum you could. But because of webassembly you

457
00:28:32,388 --> 00:28:35,842
can actually run 5000 in one node. I'm showing you a demo

458
00:28:35,896 --> 00:28:39,266
in the next slide. I think that's pretty awesome. And you

459
00:28:39,288 --> 00:28:43,042
get massive reductions in your serverless cold start delays as well.

460
00:28:43,096 --> 00:28:45,700
Again because of how webassembly is built,

461
00:28:46,070 --> 00:28:49,922
because of this you're saving a bunch of costs because you're increasing your capacity

462
00:28:49,986 --> 00:28:52,594
and your efficiency of resources.

463
00:28:52,642 --> 00:28:56,066
So the infra that you spend or your platform team spends

464
00:28:56,098 --> 00:28:59,542
is going to be so much lower. And again, this is highly portable.

465
00:28:59,606 --> 00:29:03,546
So there's no vendor lock into one public cloud. You can run this

466
00:29:03,728 --> 00:29:06,970
in different places in different architectures, OSs,

467
00:29:07,310 --> 00:29:10,794
there's absolutely no lock in there. Here's the quick

468
00:29:10,832 --> 00:29:14,574
demo of platform for kubernetes. It's a prerecorded video because well,

469
00:29:14,612 --> 00:29:18,234
you have to ping 5000 apps. So this is an Azure Kubernetes cluster

470
00:29:18,282 --> 00:29:21,502
running 5000 apps, right? You can see the number

471
00:29:21,556 --> 00:29:25,982
here, we've just done a count, 5000 and

472
00:29:26,116 --> 00:29:29,954
you can see instantly how you get a response. Hello number twelve.

473
00:29:30,072 --> 00:29:33,490
So I just changed the number. You instantly get a response. So it's that quick.

474
00:29:33,560 --> 00:29:37,542
So the cold start time is sub one millisecond within

475
00:29:37,596 --> 00:29:41,286
this Azure Kubernetes cluster. And just to give

476
00:29:41,308 --> 00:29:44,626
you an idea of how this works, you can write your webassembly apps

477
00:29:44,658 --> 00:29:48,006
using spin open source. You can self host in your

478
00:29:48,028 --> 00:29:51,686
Kubernetes using Spincube which is open source. So if you want an enterprise grade

479
00:29:51,718 --> 00:29:55,386
one, this platform for Kubernetes, get in touch with us about that.

480
00:29:55,488 --> 00:29:58,890
Or you can also host your spin apps on cloud.

481
00:29:59,040 --> 00:30:02,300
There are paid and free tiers there as well.

482
00:30:02,910 --> 00:30:05,758
All right, well, I hope you learned something new today.

483
00:30:05,844 --> 00:30:09,134
For next step, check out and build your first spin app.

484
00:30:09,252 --> 00:30:13,022
Check out spincube as well. If you're into the Kubernetes space,

485
00:30:13,156 --> 00:30:16,206
there are a bunch of tutorials on our YouTube, too, so feel free to

486
00:30:16,228 --> 00:30:19,678
jump in there. We have a discord, so join us there. Or hit me up

487
00:30:19,684 --> 00:30:22,526
on LinkedIn if you have any questions, or if you had any feedback about the

488
00:30:22,548 --> 00:30:25,874
stock, I'd love to hear what you're building in the webassembly

489
00:30:25,922 --> 00:30:28,978
space. So yeah, get in touch and enjoy the rest of the conference.

490
00:30:29,074 --> 00:30:29,460
Thank you.

