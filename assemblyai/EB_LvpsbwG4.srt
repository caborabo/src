1
00:00:24,650 --> 00:00:28,070
Alright, welcome to Conf 42 Cloud native and

2
00:00:28,140 --> 00:00:31,640
welcome to my talk about the serverless development and some

3
00:00:32,010 --> 00:00:35,990
patterns for having an efficient development workflow for

4
00:00:36,140 --> 00:00:40,182
serverless. So let me start the slide right

5
00:00:40,236 --> 00:00:44,034
here. So yeah, this is the patterns for efficient serverless

6
00:00:44,082 --> 00:00:47,042
development. A quick introduction my name is Yen Trey.

7
00:00:47,106 --> 00:00:50,046
I've been AWS user since 2010.

8
00:00:50,188 --> 00:00:53,870
Nowadays I work as a developer advocate for Lumigo and

9
00:00:53,940 --> 00:00:57,502
Lumigo is probably the best observability platform for

10
00:00:57,556 --> 00:01:01,546
serverless. The other half my time I work as an independent consultant

11
00:01:01,658 --> 00:01:05,466
where I help other companies go faster for less by helping

12
00:01:05,498 --> 00:01:09,646
them adopt serverless. And when it comes to having an efficient

13
00:01:09,758 --> 00:01:13,682
development workflow for serverless, I think you really need three

14
00:01:13,736 --> 00:01:17,958
things. Number one, you need to have a good testing approach and

15
00:01:18,044 --> 00:01:21,526
you need to be able to deploy your application easily, and you

16
00:01:21,548 --> 00:01:24,546
also need a way to manage your environment efficiently.

17
00:01:24,658 --> 00:01:27,906
And all three of these things should really help

18
00:01:27,948 --> 00:01:30,902
each other. And as a consultant,

19
00:01:30,966 --> 00:01:34,202
the number one question I get is how do I

20
00:01:34,256 --> 00:01:37,914
test my serverless architecture? And the number

21
00:01:37,952 --> 00:01:41,194
one way that I prefer to do this, especially when

22
00:01:41,232 --> 00:01:44,506
it comes to testing my lambda functions, is what

23
00:01:44,528 --> 00:01:48,366
I would call remote code testing, which is a

24
00:01:48,388 --> 00:01:51,914
big part of my, I guess the day to day workflow

25
00:01:51,962 --> 00:01:55,586
when it comes to serverless architectures and how I test them.

26
00:01:55,768 --> 00:01:59,458
When you think about the local testing where you run your code

27
00:01:59,544 --> 00:02:03,522
locally against mocks, it lets you use debuggers to

28
00:02:03,576 --> 00:02:07,074
step through the code, which is very useful, and you can

29
00:02:07,112 --> 00:02:10,802
test your code without having to wait for full deployment

30
00:02:10,866 --> 00:02:14,450
cycle, and that gives you a really fast feedback loop.

31
00:02:14,610 --> 00:02:18,006
But a problem with testing against mocks locally is that

32
00:02:18,108 --> 00:02:21,866
what you're asking is, is my code doing what I expect it

33
00:02:21,888 --> 00:02:25,820
to do? Not if my code is actually working.

34
00:02:26,190 --> 00:02:29,594
There is a subtle difference there in that one is

35
00:02:29,632 --> 00:02:33,706
based on reality and the other is based on your expectations

36
00:02:33,818 --> 00:02:36,618
and assumptions, which unfortunately,

37
00:02:36,794 --> 00:02:40,222
sometimes your assumptions about how something works is just

38
00:02:40,276 --> 00:02:43,774
wrong. And I've seen lots of examples of applications

39
00:02:43,822 --> 00:02:47,394
that pass all the tests only to fail the first

40
00:02:47,432 --> 00:02:50,786
time it runs in AWS because you're using

41
00:02:50,968 --> 00:02:54,322
the same flawed assumptions to write your

42
00:02:54,376 --> 00:02:57,542
code and your test. And so your test

43
00:02:57,596 --> 00:03:00,690
is not checking your expectations against reality,

44
00:03:00,850 --> 00:03:04,626
which has just a habit of slapping you right down to earth.

45
00:03:04,818 --> 00:03:08,486
And so local testing is prone to false positives

46
00:03:08,518 --> 00:03:12,698
and gives you a fairly low confidence. And it doesn't cover

47
00:03:12,864 --> 00:03:16,342
a big part of your application like iem permissions,

48
00:03:16,486 --> 00:03:20,410
API gateway authentication, and basically any direct

49
00:03:20,480 --> 00:03:23,822
integration you have between different services, amongst other

50
00:03:23,876 --> 00:03:27,726
things. All of these are important because your application

51
00:03:27,828 --> 00:03:31,022
is more than just your code. And your job

52
00:03:31,076 --> 00:03:34,814
as a software engineer is to make sure that all of it works. Because the

53
00:03:34,852 --> 00:03:38,418
whole idea is that at the end of it, user gets something that works.

54
00:03:38,504 --> 00:03:42,274
Not just that, oh, my code works, but some other integration that

55
00:03:42,312 --> 00:03:45,814
I didn't test is not working. Customers are not going to care

56
00:03:45,852 --> 00:03:49,622
if the problem is with your configuration and not your

57
00:03:49,676 --> 00:03:53,414
code. And that's where remote testing comes

58
00:03:53,452 --> 00:03:57,522
in. You're testing against the cloud, so it's far more realistic,

59
00:03:57,586 --> 00:04:00,362
and it covers basically everything along the way,

60
00:04:00,416 --> 00:04:04,090
including IAM permissions and your configurations and security

61
00:04:04,240 --> 00:04:08,202
and so on. So you get far more confidence from this test

62
00:04:08,336 --> 00:04:11,900
that your application actually works the way you expect them to.

63
00:04:12,430 --> 00:04:15,886
But having to wait for a full deployment cycle can

64
00:04:15,908 --> 00:04:19,262
be very slow and painful, and it can really slow down your

65
00:04:19,316 --> 00:04:23,326
feedback loop. And especially if you are making small code changes

66
00:04:23,508 --> 00:04:26,642
constantly. And every time you make a small code change,

67
00:04:26,696 --> 00:04:30,622
you have to wait for a full deployment that can be really, really painful.

68
00:04:30,766 --> 00:04:33,906
And there are some frameworks that give you some help with this,

69
00:04:34,008 --> 00:04:37,446
but they're fairly limited. And I really don't like the idea of

70
00:04:37,468 --> 00:04:41,094
having to switch frameworks just so that they

71
00:04:41,132 --> 00:04:45,254
make testing a bit easier. And as a consultant, I work with

72
00:04:45,292 --> 00:04:48,870
clients who use all kind of different tools and languages,

73
00:04:49,030 --> 00:04:52,906
so I prefer approaches that anybody can use with

74
00:04:52,928 --> 00:04:56,774
a minimum amount of custom adaptation. And so the approach

75
00:04:56,822 --> 00:05:00,594
that I take is to combine local testing with remote

76
00:05:00,662 --> 00:05:03,914
testing. Hence the name remote testing,

77
00:05:04,042 --> 00:05:07,866
where you run your code locally, but you're talking to real AWS

78
00:05:07,898 --> 00:05:11,166
services as much as possible. And you can

79
00:05:11,188 --> 00:05:15,326
still use debuggers to step through your code because you're running them locally.

80
00:05:15,438 --> 00:05:19,154
And the tests are far more realistic because you are testing your

81
00:05:19,192 --> 00:05:22,898
code against the real AWS services, but you

82
00:05:22,904 --> 00:05:26,242
don't need a full deployment every single time you make a code change,

83
00:05:26,296 --> 00:05:30,034
because again, you're running tests against your code that are executing

84
00:05:30,082 --> 00:05:32,840
locally but talking to remote services.

85
00:05:33,690 --> 00:05:37,542
But this kind of testing is still just only looking at your lambda functions and

86
00:05:37,596 --> 00:05:40,594
how they interact with your downstream systems,

87
00:05:40,642 --> 00:05:44,742
like your dynamdb tables or SNS topics or queues

88
00:05:44,806 --> 00:05:48,266
or whatnot. But what about all the stuff that are in front

89
00:05:48,288 --> 00:05:52,190
of your lambda function? A lot of things can still go wrong there,

90
00:05:52,340 --> 00:05:55,482
like im permissions, or absent resolver

91
00:05:55,546 --> 00:05:58,826
templates or eventbridge event patterns.

92
00:05:58,938 --> 00:06:02,122
Your code might be fine, but if any of these configurations

93
00:06:02,186 --> 00:06:05,470
are wrong, then your application is not going to work properly.

94
00:06:05,630 --> 00:06:09,582
And remember, all of these configurations are still your responsibility,

95
00:06:09,726 --> 00:06:13,140
and you need to make sure that all of them are working together.

96
00:06:14,390 --> 00:06:17,402
And so if I was to look at an API gateway API,

97
00:06:17,486 --> 00:06:21,446
then there are multiple things I want to be able to test for

98
00:06:21,468 --> 00:06:24,678
my lambda functions. I can encapsulate all of my

99
00:06:24,764 --> 00:06:28,614
domain logic into separate modules, and I can unit test them

100
00:06:28,652 --> 00:06:32,026
individually. And then I can use remote code testing to check

101
00:06:32,048 --> 00:06:36,060
my code integration with other things like other AWS services.

102
00:06:36,430 --> 00:06:40,374
And I can also use end to end tests to exercise API

103
00:06:40,422 --> 00:06:44,014
endpoints directly once they've been deployed, which would

104
00:06:44,052 --> 00:06:47,646
invoke my lambda function and check the IAM permissions as part of

105
00:06:47,668 --> 00:06:51,594
those test cases. And when I'm using API gateway

106
00:06:51,642 --> 00:06:54,986
to say validate or to transform the request or

107
00:06:55,028 --> 00:06:58,494
response, or to call other AWS services directly,

108
00:06:58,622 --> 00:07:02,050
then I can still use those end to end tests to check that

109
00:07:02,120 --> 00:07:04,820
any configuration in API gateway is correct.

110
00:07:05,510 --> 00:07:09,474
Similarly, if I'm asking API gateway to do all the authentication and

111
00:07:09,512 --> 00:07:13,414
authorization, then they'll be checked as part of my end to end test.

112
00:07:13,612 --> 00:07:17,678
If I'm using lambda authorizer, then I can also test that authorizer

113
00:07:17,714 --> 00:07:21,850
logic independently with unit and the remote test where

114
00:07:21,920 --> 00:07:25,706
appropriate. So that's the theory. Let's look at

115
00:07:25,728 --> 00:07:29,900
how this can work in practice by looking at a really short demo

116
00:07:30,910 --> 00:07:34,286
and let me switch over to a different view.

117
00:07:34,468 --> 00:07:37,646
And so I've got a repo set up here. As you can

118
00:07:37,668 --> 00:07:41,054
see, I've just deployed my application, and in this case this is

119
00:07:41,092 --> 00:07:44,654
using a service framework, and I've deployed my application to

120
00:07:44,692 --> 00:07:47,890
a new stage called the conf fourty two.

121
00:07:48,040 --> 00:07:51,854
And here I can execute some tests. I've got some test script

122
00:07:51,902 --> 00:07:55,086
prepared in my package JSON, which allows

123
00:07:55,118 --> 00:07:59,286
me to run my tests against whatever environment that

124
00:07:59,308 --> 00:08:02,806
I've just deployed to. And I've got some test cases set

125
00:08:02,828 --> 00:08:06,610
up for my application, which consists of an API with API gateway

126
00:08:06,690 --> 00:08:10,362
and some direct service integration. The API gateway is going to talk to

127
00:08:10,416 --> 00:08:13,562
dynamdb directly without a lambda function.

128
00:08:13,696 --> 00:08:16,890
But I also got a bunch of lambda functions down below here.

129
00:08:17,040 --> 00:08:21,098
Let's look at one that just adds some restaurant data

130
00:08:21,184 --> 00:08:25,082
to a dynamDb table called Restaurants table

131
00:08:25,226 --> 00:08:28,686
in this case protected is hosted by

132
00:08:28,788 --> 00:08:32,726
APAC gateway, and it has got IAM authentication

133
00:08:32,778 --> 00:08:36,034
and authorization. And there's some schema for

134
00:08:36,072 --> 00:08:39,502
the request so that once it's deployed in APAC gateway,

135
00:08:39,566 --> 00:08:42,786
API Gateway is responsible for checking the

136
00:08:42,808 --> 00:08:46,678
schema according to this json structure I've got here,

137
00:08:46,764 --> 00:08:50,662
which says the body of the post request must have

138
00:08:50,716 --> 00:08:53,350
a name property which is a string.

139
00:08:54,250 --> 00:08:58,034
So some of this we can test in our code by checking

140
00:08:58,082 --> 00:09:01,306
that our code in the lambda function is working correctly. In this

141
00:09:01,328 --> 00:09:04,586
case, it's just writing to a dynamDB table to

142
00:09:04,608 --> 00:09:07,914
insert a new restaurant data and return 200.

143
00:09:08,032 --> 00:09:11,226
But to make sure that the whole thing actually works, I also need to have

144
00:09:11,248 --> 00:09:14,426
some coverage for what this API

145
00:09:14,458 --> 00:09:18,570
gateway is going to do to validate the schema of the request.

146
00:09:18,730 --> 00:09:22,366
So to look at my test, I've got some test cases set up.

147
00:09:22,468 --> 00:09:26,130
I've got a test case here that just checks my code,

148
00:09:26,200 --> 00:09:29,954
my lambda function, which I can invoke as part

149
00:09:29,992 --> 00:09:33,710
of remote tests, or in this case I'm calling them integration tests,

150
00:09:33,790 --> 00:09:37,254
but they can also be executed as part of an end to end test.

151
00:09:37,372 --> 00:09:41,234
And I've also got a schema test which just checks the schema

152
00:09:41,282 --> 00:09:45,234
validation is working. And because this can only be done in API

153
00:09:45,282 --> 00:09:48,242
gateway in the ABIS environment,

154
00:09:48,306 --> 00:09:51,994
so this will only be triggered as part of an end to end test that

155
00:09:52,032 --> 00:09:55,754
will be run. So if you look at the test

156
00:09:55,872 --> 00:09:59,306
here, that allows me to test my code locally. So the

157
00:09:59,328 --> 00:10:02,286
magic here happens in the when module, when we say,

158
00:10:02,388 --> 00:10:06,298
when we invoke the add restaurant endpoint. So it's

159
00:10:06,314 --> 00:10:09,770
going to look at some environment variable called test mode,

160
00:10:09,850 --> 00:10:13,246
and based on whatever the value is, when we say when

161
00:10:13,268 --> 00:10:17,106
we invoke add restaurant with some payload, it's going to

162
00:10:17,128 --> 00:10:20,562
do something slightly different. So we want to see the case when

163
00:10:20,616 --> 00:10:23,906
we want to run the remote tests that allows us to make

164
00:10:23,928 --> 00:10:27,554
changes on my code locally and then execute it and

165
00:10:27,592 --> 00:10:30,854
potentially even put breakpoints in the code so that we can step through

166
00:10:30,892 --> 00:10:34,582
any bugs or errors that we capture. So what this is doing

167
00:10:34,636 --> 00:10:39,080
is via this via handler helper function, which just requires a

168
00:10:39,390 --> 00:10:43,270
handler module locally, execute it with a stubbed

169
00:10:43,350 --> 00:10:46,874
context and event, and then it's just going to return

170
00:10:46,992 --> 00:10:51,174
and do some transformation in this case so that we are dealing with JSON

171
00:10:51,222 --> 00:10:53,850
lessons body as opposed to a string.

172
00:10:54,190 --> 00:10:57,406
So this just allows us to write our test so that we can check the

173
00:10:57,428 --> 00:11:01,150
status code that comes back is 200 and that ID

174
00:11:01,220 --> 00:11:05,054
that comes back is not. No. And we're able to do some validation

175
00:11:05,102 --> 00:11:08,274
to say that, okay, given the ID that comes back from the

176
00:11:08,312 --> 00:11:11,490
add restaurant function that we invoke locally,

177
00:11:12,070 --> 00:11:16,174
this new restaurant ID is going to exist in the DynamDb

178
00:11:16,222 --> 00:11:19,854
table. So we can say then the restaurant exists

179
00:11:19,902 --> 00:11:23,254
in Dunhamdb by looking up that ID in the

180
00:11:23,292 --> 00:11:27,394
restaurants table and make sure that the restaurant item

181
00:11:27,522 --> 00:11:31,354
actually exists. So in this case, if I was to use

182
00:11:31,392 --> 00:11:35,146
the JavaScript debug terminal, I can run the

183
00:11:35,248 --> 00:11:38,134
script I prepared to say test integration.

184
00:11:38,262 --> 00:11:42,346
Then we can see that that test case is going to run. And if

185
00:11:42,368 --> 00:11:46,138
the demo got up with us today, then yeah, all the tests are passing.

186
00:11:46,234 --> 00:11:49,758
And what's also nice about this is that I can make some code changes

187
00:11:49,844 --> 00:11:53,786
and I can quickly iterate that. Okay, maybe let's

188
00:11:53,818 --> 00:11:57,362
say if I just comment out this bit of code and we run a test

189
00:11:57,416 --> 00:12:00,738
again. Now the test should fail because the restaurant is no

190
00:12:00,744 --> 00:12:03,170
longer being added to the database.

191
00:12:04,950 --> 00:12:08,326
Okay, so that was unexpected. So let's try and debug this.

192
00:12:08,428 --> 00:12:12,194
So we've got a code that's commented out, but it's still somehow passing

193
00:12:12,242 --> 00:12:14,680
the test. So let's check. Okay,

194
00:12:15,130 --> 00:12:18,802
go down here, put a breakpoint in our test, and let's

195
00:12:18,866 --> 00:12:22,166
run the test again and see what's

196
00:12:22,198 --> 00:12:25,434
actually going on. Okay, so the restaurant came back

197
00:12:25,632 --> 00:12:29,146
okay, right. So this is because I've got a bug in my test, not the

198
00:12:29,168 --> 00:12:33,134
code itself. So the restaurant did came back as undefined, but our

199
00:12:33,172 --> 00:12:36,880
test case wasn't handling that. So let's just say

200
00:12:37,730 --> 00:12:40,750
this to be truthy.

201
00:12:41,650 --> 00:12:45,122
And now let's rerun our test case again. And now

202
00:12:45,176 --> 00:12:48,802
the test should fail because this should now come back

203
00:12:48,856 --> 00:12:52,674
as undefined and should fail the test. And so we

204
00:12:52,712 --> 00:12:55,954
can quickly make changes, test them, and in this

205
00:12:55,992 --> 00:12:59,850
case, let me just revert the change and make sure now the test is passing

206
00:12:59,950 --> 00:13:03,574
so we're able to put breakpoints in our code and in our test so

207
00:13:03,612 --> 00:13:06,866
that, okay, let me run it this again so you can see the breakpoint hitting

208
00:13:06,898 --> 00:13:10,906
my lambda function. So we're able to step through the code step by step

209
00:13:11,008 --> 00:13:14,794
and quickly debug problems and fix them without having

210
00:13:14,832 --> 00:13:18,394
to wait for full deployment to AWS, I think this time is

211
00:13:18,432 --> 00:13:21,420
just going to be timeout because I sat there for a little while.

212
00:13:22,110 --> 00:13:25,682
Yeah, timed out. So if you do need to raise this timeout

213
00:13:25,766 --> 00:13:29,246
for when you need to debug through the code line by line, you can do

214
00:13:29,268 --> 00:13:32,350
that as well. So as you can see, I hope you can see that this

215
00:13:32,420 --> 00:13:36,242
is going to make it a lot easier for you to troubleshoot the failing test

216
00:13:36,296 --> 00:13:39,522
and iterate on your code gradually. And because

217
00:13:39,576 --> 00:13:42,962
we're using a temporary environments as well, so that any changes

218
00:13:43,016 --> 00:13:47,058
we're making is only going to be going towards this dev Conf

219
00:13:47,144 --> 00:13:50,674
42 environment I've just created. And as I mentioned earlier,

220
00:13:50,722 --> 00:13:54,610
that there are some changes, while some of the business logic can only be tested,

221
00:13:54,690 --> 00:13:58,662
such as the schema validation, if we run against the real

222
00:13:58,716 --> 00:14:02,326
deployment AWS services, in this case the API gateway endpoint.

223
00:14:02,438 --> 00:14:06,250
So we can also run the end to end test that I've prepared

224
00:14:06,670 --> 00:14:10,138
and in this case I've got a separate script here called test

225
00:14:10,224 --> 00:14:13,786
end to end. And this is actually going to call the API endpoints

226
00:14:13,818 --> 00:14:17,054
that's been deployed in the AWS environment by

227
00:14:17,092 --> 00:14:21,578
putting a post request. And in some cases we have involves

228
00:14:21,674 --> 00:14:25,674
creating a new user in the cognito because some of these endpoints

229
00:14:25,722 --> 00:14:29,070
are protected by cognito. Let's see,

230
00:14:29,220 --> 00:14:32,798
Cognito user pool. So also involves creating these users

231
00:14:32,814 --> 00:14:36,166
as well. So we can look at some of these tests there where

232
00:14:36,268 --> 00:14:39,314
we have to create an authenticated user

233
00:14:39,442 --> 00:14:42,886
if the test mode is end to end, and then we invoke the

234
00:14:42,908 --> 00:14:46,946
endpoint when the environment

235
00:14:46,978 --> 00:14:50,534
variable says it's going to be end to end. So we have to then authenticate

236
00:14:50,582 --> 00:14:54,534
the user and then take the user's ID token and use that to invoke

237
00:14:54,582 --> 00:14:57,510
HTTP endpoint in API gateway.

238
00:14:57,670 --> 00:15:01,770
So having test cases like this allows me to have both

239
00:15:01,840 --> 00:15:05,726
reusable test cases like this one here, where we can

240
00:15:05,828 --> 00:15:09,566
run this test either as a remote test while

241
00:15:09,588 --> 00:15:12,878
we are working on the code, but once we are happy with the code changes,

242
00:15:12,964 --> 00:15:16,014
we are happy that it should work, but we want to test the whole thing,

243
00:15:16,052 --> 00:15:19,714
make sure that all the configurations are working together. Then we deploy our

244
00:15:19,752 --> 00:15:23,362
changes and then we run the test case again by

245
00:15:23,416 --> 00:15:26,354
running it as the end to end test, because the test is written in such

246
00:15:26,392 --> 00:15:30,790
a way that it's not tied to the implementations and can be toggled between either

247
00:15:30,860 --> 00:15:34,086
remote or end to end test. So by

248
00:15:34,108 --> 00:15:37,590
just switching the environment variable that we configure in the test

249
00:15:37,660 --> 00:15:41,070
script test mode, so we're able to reuse

250
00:15:41,090 --> 00:15:44,986
some of the test cases. So it takes less effort for us to maintain a

251
00:15:45,008 --> 00:15:48,950
large suite of different test cases and we can use the remote

252
00:15:49,030 --> 00:15:52,430
test to iterate quickly, but still have the entrance test

253
00:15:52,500 --> 00:15:56,414
to make sure that we have full coverage of everything that our

254
00:15:56,452 --> 00:16:00,554
application is doing. So as you can see, the main downside

255
00:16:00,602 --> 00:16:04,274
of remote testing is that you do need to production the

256
00:16:04,312 --> 00:16:07,410
AWS resources that your code is going to depend on,

257
00:16:07,480 --> 00:16:11,470
like the dynamdB tables, et cetera, before you can run your tests.

258
00:16:11,550 --> 00:16:15,202
So this open up problems where multiple people

259
00:16:15,256 --> 00:16:18,518
need to work on the same project at the same time, and people

260
00:16:18,604 --> 00:16:22,534
are going to be stepping on each other's toes and that's where the

261
00:16:22,572 --> 00:16:26,034
use of fmero environments comes in, which is easily

262
00:16:26,082 --> 00:16:29,726
the most impactful practice that has evolved with server

263
00:16:29,778 --> 00:16:32,890
technologies. But I'm jumping ahead of schedule here.

264
00:16:32,960 --> 00:16:37,030
Before we can talk about Fmaro environments, let's talk about deployments.

265
00:16:37,190 --> 00:16:40,474
Specifically why you should keep your

266
00:16:40,512 --> 00:16:44,202
deployments as simple as possible, but no simpler.

267
00:16:44,346 --> 00:16:47,614
I wish we don't have to talk about this, but unfortunately I see

268
00:16:47,652 --> 00:16:51,690
a lot of clients and the students suffer from self inflicted wounds

269
00:16:51,770 --> 00:16:54,900
when it comes to how they deploy their serverless application.

270
00:16:55,270 --> 00:16:58,734
You see, the lambda service carries some of the blame

271
00:16:58,782 --> 00:17:01,634
here because it's no longer this simple thing,

272
00:17:01,752 --> 00:17:05,646
and nowadays it has a lot of additional features like lambda

273
00:17:05,678 --> 00:17:08,790
layers, or the option to package your function

274
00:17:08,860 --> 00:17:12,454
as container images, or the ability to create your own

275
00:17:12,492 --> 00:17:16,006
custom runtimes, or to use a provision concurrency to

276
00:17:16,028 --> 00:17:19,578
keep a number of lambda workers around all the time

277
00:17:19,664 --> 00:17:23,178
so that you can mitigate costarts. All of those options

278
00:17:23,264 --> 00:17:26,986
are great, and they're useful in some use cases, but I

279
00:17:27,008 --> 00:17:30,506
think just because they're there doesn't mean that you have

280
00:17:30,528 --> 00:17:34,078
to use them. In fact, I'll go as far as to say that

281
00:17:34,164 --> 00:17:37,534
for 90% of use cases you shouldn't use any of these

282
00:17:37,572 --> 00:17:41,134
options. And for lambda layers I will go

283
00:17:41,172 --> 00:17:44,674
even further and say that you shouldn't use them to share code between

284
00:17:44,712 --> 00:17:48,558
lambda functions at all, because they complicate your deployments

285
00:17:48,654 --> 00:17:52,258
and make things more difficult than they need to be without

286
00:17:52,344 --> 00:17:55,730
really giving you any meaningful return on investment.

287
00:17:56,070 --> 00:17:59,454
They don't support semantic versioning, and because they exist

288
00:17:59,502 --> 00:18:03,474
outside of your language's ecosystem security scanners

289
00:18:03,522 --> 00:18:06,614
don't know about them and can't automatically scan them

290
00:18:06,652 --> 00:18:10,998
and check them against their database of known vulnerabilities.

291
00:18:11,174 --> 00:18:14,762
And you're limited to just five lambda layers per

292
00:18:14,816 --> 00:18:18,470
function, and they still count towards your lambda functions

293
00:18:18,550 --> 00:18:22,326
250 meg size limit once it's been unzipped.

294
00:18:22,438 --> 00:18:26,586
So they don't help you sort of mitigate some of those lambda

295
00:18:26,618 --> 00:18:29,886
limits, and again, because it exists outside of your

296
00:18:29,908 --> 00:18:33,006
language's ecosystem, so it's going to make it harder for

297
00:18:33,028 --> 00:18:36,306
you to test your code locally as well if some of

298
00:18:36,328 --> 00:18:39,458
your dependencies exist outside of your local

299
00:18:39,544 --> 00:18:43,854
execution environment and only exists in AWS as lambda layers,

300
00:18:43,982 --> 00:18:47,566
and because your language runtime doesn't know about

301
00:18:47,608 --> 00:18:50,854
them. So it's then up to you to find a way to bring them into

302
00:18:50,892 --> 00:18:54,646
your local development environment so that you are able to execute your code

303
00:18:54,748 --> 00:18:58,210
locally. And they were designed to

304
00:18:58,220 --> 00:19:02,154
help with the likes of Python and JavaScript, and they

305
00:19:02,192 --> 00:19:05,818
don't really work for static languages like Java or

306
00:19:05,904 --> 00:19:09,066
net that requires your dependencies to be available at

307
00:19:09,088 --> 00:19:11,962
compile time. And honestly,

308
00:19:12,026 --> 00:19:14,746
compared to package managers like NPM,

309
00:19:14,858 --> 00:19:18,686
it's just more work to publish updates to your shared code

310
00:19:18,788 --> 00:19:22,714
and then to bring them into where they're needed in your local development

311
00:19:22,762 --> 00:19:26,850
environment, as well as into your project, and for anyone who's using

312
00:19:26,920 --> 00:19:30,386
JavaScript, because again, they exist outside of your

313
00:19:30,408 --> 00:19:33,950
NPM ecosystem, they don't really work with bundling

314
00:19:34,030 --> 00:19:37,854
and tree shaking as well. So that's a whole laundry

315
00:19:37,902 --> 00:19:41,590
list of reasons why lambda layers just don't add any value.

316
00:19:41,740 --> 00:19:45,062
So instead, if you're sharing code between functions in the same

317
00:19:45,116 --> 00:19:48,946
project, I will just put them in a folder and reference them directly

318
00:19:49,058 --> 00:19:52,326
during deployment. Just make sure that both of

319
00:19:52,348 --> 00:19:55,866
your lambda functions handle the module as well as

320
00:19:55,888 --> 00:19:59,402
your shared library. Modules are included in the same

321
00:19:59,456 --> 00:20:02,766
zip file, or is bundled into a single file if

322
00:20:02,788 --> 00:20:06,266
you're using a bundler and this is supported by most frameworks

323
00:20:06,298 --> 00:20:09,310
like SAM or serverless framework or CDK.

324
00:20:09,810 --> 00:20:13,914
And if you need to shared code between different projects, then publish

325
00:20:13,962 --> 00:20:17,778
them to NPM and use a private NPM registry if you

326
00:20:17,784 --> 00:20:21,170
need to. It's simple and it's what we do already outside

327
00:20:21,240 --> 00:20:24,482
of the context of lambda, and it works just fine

328
00:20:24,536 --> 00:20:27,060
when you're writing lambda functions as well.

329
00:20:27,750 --> 00:20:31,734
And the next thing I'll say about deployment is that as much as

330
00:20:31,772 --> 00:20:35,430
possible, you should just stick with using zip files and manage

331
00:20:35,500 --> 00:20:38,822
runtimes. There's a time when you need to package your function

332
00:20:38,876 --> 00:20:42,714
as a container image, for example when your application is bigger than

333
00:20:42,752 --> 00:20:46,554
the 250 meg size limit, but it also means

334
00:20:46,592 --> 00:20:50,246
that you become responsible for the runtime as well as

335
00:20:50,288 --> 00:20:53,854
your code and your dependencies. And wherever possible,

336
00:20:53,972 --> 00:20:57,534
I want to delegate responsibilities to the cloud so

337
00:20:57,572 --> 00:21:01,406
I can focus on just my application. Which is why

338
00:21:01,508 --> 00:21:04,818
for an efficient development flow, I recommend that you

339
00:21:04,824 --> 00:21:08,354
stick with using zip files and manage runtimes, and stay

340
00:21:08,392 --> 00:21:10,450
away from using lambda layers.

341
00:21:11,830 --> 00:21:15,410
And that brings us to how do you manage your AWS environments?

342
00:21:15,830 --> 00:21:19,298
I will start by just saying that, okay, you should have at a minimum

343
00:21:19,394 --> 00:21:23,094
one account per stage so that you have one account for

344
00:21:23,132 --> 00:21:26,514
Dev, one account for test, one account for staging,

345
00:21:26,562 --> 00:21:30,326
and a separate account for production, so that if there's any problems in

346
00:21:30,348 --> 00:21:33,558
terms of throughput or in terms of a security breach,

347
00:21:33,654 --> 00:21:36,922
they are contained into a single account, so that if your dev

348
00:21:36,976 --> 00:21:40,266
account gets compromised, at least the attacker won't be able to

349
00:21:40,288 --> 00:21:43,870
access your user data. In production and for large

350
00:21:43,940 --> 00:21:47,726
organizations with many different teams, then I would go as far go

351
00:21:47,748 --> 00:21:52,266
a bit further and say that you should have one account per team per stage,

352
00:21:52,378 --> 00:21:55,694
so that different teams are also insulated from

353
00:21:55,732 --> 00:21:59,486
each other, and if one team makes a mistake or they have a really busy

354
00:21:59,518 --> 00:22:02,962
service, they're not going to use up all the available throughput in the

355
00:22:03,016 --> 00:22:06,806
account for everybody, and saying that if

356
00:22:06,828 --> 00:22:09,874
you got say one team with different workloads,

357
00:22:10,002 --> 00:22:13,654
some of them are more business critical than others, or they

358
00:22:13,692 --> 00:22:17,858
have higher throughput than others, then it's also recommended.

359
00:22:17,954 --> 00:22:21,910
Well, I recommend you putting those business critical workflows

360
00:22:21,990 --> 00:22:25,802
into their own separate accounts. So for a particular service you may

361
00:22:25,856 --> 00:22:29,482
have dev test staging production account just for that service,

362
00:22:29,616 --> 00:22:33,610
but for the team and all of the other services that you maintain

363
00:22:33,770 --> 00:22:37,694
as a team, I will have dev test staging and production accounts for

364
00:22:37,732 --> 00:22:41,710
all the other serverless shared together. That way,

365
00:22:41,860 --> 00:22:45,822
for the less critical workflows, you have a separate dev

366
00:22:45,876 --> 00:22:49,406
test staging production account for though then for the things that

367
00:22:49,428 --> 00:22:52,546
are really business critical or have a

368
00:22:52,568 --> 00:22:55,780
much higher throughput, you have a separate set of accounts for those.

369
00:22:56,630 --> 00:23:00,082
And as I mentioned earlier, the use of FML environments

370
00:23:00,146 --> 00:23:03,746
or temporary environments is perhaps one of the most impactful

371
00:23:03,778 --> 00:23:07,366
things you can do that's going to improve your development workflow when it

372
00:23:07,388 --> 00:23:11,130
comes to working with serverless technologies. And it can work as simple

373
00:23:11,200 --> 00:23:14,986
as just using the server framework as example, that when you

374
00:23:15,008 --> 00:23:18,694
start to work on a new feature, create a new environment.

375
00:23:18,822 --> 00:23:21,978
And within the server framework you just run deploy command

376
00:23:22,074 --> 00:23:25,742
with a flag for the stage override and say name

377
00:23:25,796 --> 00:23:29,294
your stage after the feature. So dev my

378
00:23:29,332 --> 00:23:33,306
feature for example, this way it's going to create completely new environment

379
00:23:33,418 --> 00:23:37,006
with all of your functions and dynamdb tables and whatnot,

380
00:23:37,118 --> 00:23:40,260
so that you are able to then iterate on your code changes,

381
00:23:40,630 --> 00:23:44,434
run your remote tests against them, or end to end tests as well

382
00:23:44,552 --> 00:23:47,874
against this temporary environment that you've created just for this

383
00:23:47,912 --> 00:23:51,382
feature. And once you're ready, you can commit your code

384
00:23:51,436 --> 00:23:54,866
changes, submit your PR, and as part of the Ci CD

385
00:23:54,898 --> 00:23:59,162
pipeline, you're going to run all of the tests against your

386
00:23:59,216 --> 00:24:02,842
changes. And when you're done, you can just

387
00:24:02,896 --> 00:24:06,538
run the serverless remove command against your

388
00:24:06,704 --> 00:24:10,506
temporary environment, in this case using the stage override in

389
00:24:10,528 --> 00:24:14,186
the CLI to say use the stage name of dev my feature

390
00:24:14,298 --> 00:24:17,694
and this would delete your temporary environment as if it

391
00:24:17,732 --> 00:24:21,646
never existed in the first place. In this case, because all of your

392
00:24:21,668 --> 00:24:25,534
tests is run against your temporary environment, so you've kept

393
00:24:25,582 --> 00:24:29,122
your main stages like dev test and staging and

394
00:24:29,176 --> 00:24:32,818
production cleans, and so everybody does no

395
00:24:32,824 --> 00:24:36,466
need to clean up any data. And because every time you start to work on

396
00:24:36,488 --> 00:24:39,874
a new feature and every developer can have their own environment

397
00:24:39,922 --> 00:24:43,446
to work in, so there's no need to worry about people stepping on

398
00:24:43,468 --> 00:24:47,078
each other's toes as well, because you're able to

399
00:24:47,244 --> 00:24:50,458
work against your own insulated environment and basically

400
00:24:50,544 --> 00:24:53,994
stay out of each other's way, and because able

401
00:24:54,032 --> 00:24:57,626
to keep these shared environments like Dev and test and

402
00:24:57,648 --> 00:25:02,714
staging clean, you also by

403
00:25:02,752 --> 00:25:06,622
not polluting them with the test data, because all of your work is

404
00:25:06,676 --> 00:25:09,802
done and all of your tests is done against those temporary environments

405
00:25:09,866 --> 00:25:13,038
as well. And one of the really nice things about using

406
00:25:13,124 --> 00:25:16,834
temporary environments or FML environments with serverless components is

407
00:25:16,872 --> 00:25:20,386
that because you've got this usage based pricing, you can

408
00:25:20,408 --> 00:25:24,210
have as many of these environments as you need, and there's no extra

409
00:25:24,280 --> 00:25:27,670
cost overhead because those environments are going to sit there.

410
00:25:27,740 --> 00:25:31,174
If there's no traffic, then you're not going to pay anything because you

411
00:25:31,212 --> 00:25:34,694
only pay for what you use. But sometimes you have to

412
00:25:34,732 --> 00:25:38,294
use serverful components, things that charges you

413
00:25:38,332 --> 00:25:42,018
based on uptime, things like RDS or opensearch

414
00:25:42,114 --> 00:25:45,834
where you've got a cluster, you're sitting there, you're paying for them by the

415
00:25:45,872 --> 00:25:49,354
second, even if nobody uses them. So when you're using

416
00:25:49,472 --> 00:25:53,054
FML environment, you have to do a little bit tweak to your

417
00:25:53,092 --> 00:25:56,974
workflow to make sure that your serverless components are

418
00:25:57,012 --> 00:26:00,442
not created with every single temporary environment.

419
00:26:00,506 --> 00:26:03,906
Instead, you have to do some work to make sure that these

420
00:26:04,088 --> 00:26:07,710
stateful resources, these serverful resources, sorry, not staple,

421
00:26:07,790 --> 00:26:11,774
serverless resources are shared across this FML

422
00:26:11,822 --> 00:26:15,666
environment. I've written about this before, so give this blog post a

423
00:26:15,688 --> 00:26:19,542
read afterwards and you'll see why

424
00:26:19,596 --> 00:26:23,302
it's not as bad as you may think. And you can also use this

425
00:26:23,356 --> 00:26:27,046
FML environment for your CI CD pipeline as well, so that when

426
00:26:27,068 --> 00:26:30,410
the pipeline runs, you can create a fresh environment every single

427
00:26:30,480 --> 00:26:33,900
time and run the test against them. So that

428
00:26:34,670 --> 00:26:37,786
once the pipeline is finished, you can also destroy the

429
00:26:37,808 --> 00:26:41,174
environments as well, so that again, you avoid polluting

430
00:26:41,222 --> 00:26:44,894
your main stages like dev test and staging and so

431
00:26:44,932 --> 00:26:48,286
on. At this point you probably got a sense that when I talk

432
00:26:48,308 --> 00:26:52,000
about an environment, I don't necessarily mean an AWS account,

433
00:26:52,370 --> 00:26:56,482
because again, when you have your separate accounts for each of your main

434
00:26:56,536 --> 00:27:00,306
environments or stages, you can actually have an

435
00:27:00,328 --> 00:27:04,370
AWS account that hosts multiple environments running

436
00:27:04,440 --> 00:27:08,002
in the same region. And normally I'll do this

437
00:27:08,056 --> 00:27:11,842
against the dev account for all the temporary environments,

438
00:27:11,906 --> 00:27:15,366
because that's where my developers are going to be working in most of the

439
00:27:15,388 --> 00:27:19,202
time. And depending on your choice of deployment framework,

440
00:27:19,346 --> 00:27:22,746
an environment might be a serverless project with a

441
00:27:22,768 --> 00:27:26,506
serverless or YAML or a cloudformation stack. Or if

442
00:27:26,528 --> 00:27:29,766
it's a case of CDK, it could be a CDK app that consists

443
00:27:29,798 --> 00:27:31,450
of multiple stacks,

444
00:27:32,990 --> 00:27:36,622
or maybe it's a combination of both cloud formation stacks and other

445
00:27:36,676 --> 00:27:40,794
things that are outside of cloudformation, such as infrastructure that are created

446
00:27:40,842 --> 00:27:44,914
as part of your lending zone for every single account or

447
00:27:44,952 --> 00:27:48,914
SSM parameters, basically anything that you need to run your

448
00:27:48,952 --> 00:27:52,194
application. So an important part of making this

449
00:27:52,232 --> 00:27:56,186
work is that you need to make sure your resource names don't

450
00:27:56,238 --> 00:27:59,702
clash. And there are essentially two main

451
00:27:59,756 --> 00:28:02,854
things that you need to do to make sure that's the case.

452
00:28:02,972 --> 00:28:06,818
Number one is don't explicitly name any resources

453
00:28:06,914 --> 00:28:10,614
unless you have to, and basically let cloudformation name them

454
00:28:10,652 --> 00:28:13,978
for you, which will make sure that there's some random bit at the end.

455
00:28:14,144 --> 00:28:17,350
And number two is that when you have to name a resource,

456
00:28:17,510 --> 00:28:21,082
which is the case for Eventbridge buses, for example,

457
00:28:21,216 --> 00:28:25,342
then make sure you include the name of the environment as a suffix or

458
00:28:25,396 --> 00:28:28,734
prefix in the name of that resource again, so that

459
00:28:28,772 --> 00:28:31,806
when you create a separate another environment in the same account,

460
00:28:31,908 --> 00:28:34,850
you're not going to have any name clashes of resources.

461
00:28:35,750 --> 00:28:39,470
And with FML environments, they work really well with remote

462
00:28:39,550 --> 00:28:42,802
testing, because again, remote testing requires having those

463
00:28:42,856 --> 00:28:46,338
resources in AWS to be able to run your tests against them.

464
00:28:46,424 --> 00:28:49,622
And when you have a temporary environment for every single

465
00:28:49,676 --> 00:28:53,014
feature you're going to be working on, or every developer that

466
00:28:53,212 --> 00:28:56,806
are part of the team, then it becomes really easy to create a

467
00:28:56,828 --> 00:29:00,526
temporary environment for just you or that piece of feature

468
00:29:00,658 --> 00:29:04,186
and do your changes, run your remote tests, and so

469
00:29:04,208 --> 00:29:08,202
you're able to iterate on your code quickly without having to wait for deployment between

470
00:29:08,256 --> 00:29:11,718
every single small change, and you're able to put the breakpoints

471
00:29:11,734 --> 00:29:14,926
in your code and debug them and so on. But then once you're done,

472
00:29:14,948 --> 00:29:19,118
you're able to then promote your code changes and delete the environment so that

473
00:29:19,204 --> 00:29:22,366
again, you avoid computing the main stages you

474
00:29:22,388 --> 00:29:26,158
have as a team. So those are the three things that I

475
00:29:26,164 --> 00:29:29,786
think that's very important for having an efficient development workflow

476
00:29:29,818 --> 00:29:33,886
when it comes to serverless technologies. And I hope I've given you some ideas in

477
00:29:33,908 --> 00:29:37,686
terms of what you could do to improve your workflow to make

478
00:29:37,708 --> 00:29:42,130
it more efficient and easier for you to work with serverless technologies.

479
00:29:42,290 --> 00:29:46,086
This is a starting point only. There's also other things you need to

480
00:29:46,108 --> 00:29:50,034
worry about in terms of actually building and running a production ready serverless

481
00:29:50,082 --> 00:29:53,734
application. So if you have any questions, please feel free to

482
00:29:53,772 --> 00:29:56,930
reach out to me afterwards, and I hope you enjoy the rest of the conference.

