1
00:00:20,650 --> 00:00:23,914
Hey everyone, my name is Sohan Maheshwar. I'm a dev advocate

2
00:00:23,962 --> 00:00:27,094
at Fermion and, and today we're going to show you how

3
00:00:27,132 --> 00:00:30,914
you can build a serverless webassembly app using Python

4
00:00:31,042 --> 00:00:34,726
with this open source framework called Spin. Now if

5
00:00:34,748 --> 00:00:37,958
you're not familiar with what Webassembly is, or if you're

6
00:00:37,964 --> 00:00:41,578
not familiar with what serverless is, no problem. That's what I'm here for.

7
00:00:41,664 --> 00:00:45,242
And by the end of this session, hopefully you'll know how you can get

8
00:00:45,296 --> 00:00:48,874
started with Webassembly. I'm going to start off with

9
00:00:48,912 --> 00:00:52,586
a very build claim, and that is the next wave

10
00:00:52,618 --> 00:00:56,730
of cloud computing will be powered by webassembly.

11
00:00:56,890 --> 00:01:00,474
And this is a rather bold way to start off session.

12
00:01:00,522 --> 00:01:04,142
So hopefully by the end of the session you are convinced as well. In fact,

13
00:01:04,196 --> 00:01:07,762
the creator of Docker Solomon makes had tweeted something to this very

14
00:01:07,816 --> 00:01:11,394
effect about two or three years ago. And in a few

15
00:01:11,432 --> 00:01:14,866
slides I think you will see why. So today we are going to talk

16
00:01:14,888 --> 00:01:18,462
about what webassembly is, how it works,

17
00:01:18,536 --> 00:01:22,322
when to use it, and how this will potentially change cloud computing.

18
00:01:22,466 --> 00:01:26,006
I'm also going to show you two demos, very hands on, going with

19
00:01:26,028 --> 00:01:29,602
the hello world example to can example of AI,

20
00:01:29,666 --> 00:01:33,610
and how you can actually use this. So stay tuned till the end for

21
00:01:33,680 --> 00:01:37,654
both of these demos. So first things first, I always have to context

22
00:01:37,702 --> 00:01:40,874
set what really is webassembly. The boring answer

23
00:01:40,912 --> 00:01:44,334
is it's just another bytecode format. Now the short

24
00:01:44,372 --> 00:01:47,694
history behind it is sometime in the was

25
00:01:47,732 --> 00:01:51,694
this technology introduced called Webassembly, originally meant for

26
00:01:51,732 --> 00:01:54,782
the browsers, it was meant to be faster,

27
00:01:54,846 --> 00:01:58,574
it was meant to be portable, it was meant to be more lightweight.

28
00:01:58,702 --> 00:02:01,566
And even now, companies like Adobe Figma,

29
00:02:01,598 --> 00:02:04,814
Shopify, all of these companies use Webassembly

30
00:02:04,942 --> 00:02:08,246
in their browser. Now, if I

31
00:02:08,268 --> 00:02:11,766
say wasm, it's just another word for Webassembly, short for

32
00:02:11,788 --> 00:02:15,414
Webassembly, basically. And really how it was

33
00:02:15,452 --> 00:02:18,614
designed was for it to be a portable compilation

34
00:02:18,662 --> 00:02:21,754
target. Which means any webassembly module could

35
00:02:21,792 --> 00:02:25,254
run anywhere, right? Any architecture, any OS,

36
00:02:25,382 --> 00:02:29,814
any system, as long as that system could run a particular webassembly

37
00:02:29,862 --> 00:02:32,170
runtime. Now what does that mean?

38
00:02:32,320 --> 00:02:36,026
Well, a few of you all might be familiar with the Java

39
00:02:36,058 --> 00:02:39,326
world and how jvms worked, or Java virtual machines worked,

40
00:02:39,428 --> 00:02:42,874
where essentially you wrote a Java program and this compiled

41
00:02:42,922 --> 00:02:46,274
to something called Java Bytecode. And that

42
00:02:46,312 --> 00:02:50,030
Java bytecode could be executed in any environment

43
00:02:50,190 --> 00:02:53,118
which could run a JVM or a Java virtual machine.

44
00:02:53,214 --> 00:02:56,882
And these jvms could run on ARM processors, on x 86

45
00:02:56,936 --> 00:03:00,398
processors, on Windows, Mac, Linux, whatever, right?

46
00:03:00,424 --> 00:03:04,434
So it wasm fairly portable. Now WASM

47
00:03:04,482 --> 00:03:07,638
was designed with a similar method in mind.

48
00:03:07,724 --> 00:03:11,238
Similar idea in mind. But instead of just sticking

49
00:03:11,254 --> 00:03:14,854
to one language, you can write a program in any language.

50
00:03:14,982 --> 00:03:18,822
Yes. So you can write it in Rust C plus plus javascript,

51
00:03:18,886 --> 00:03:22,126
typescript, zig go, and of course Python as well,

52
00:03:22,228 --> 00:03:25,962
which compiles to something called a webassembly bytecode.

53
00:03:26,106 --> 00:03:29,886
Now this webassembly bytecode is the

54
00:03:29,908 --> 00:03:33,066
new format that I was talking to you about. It is a WASM module,

55
00:03:33,178 --> 00:03:36,974
and that could be executed anywhere that has a webassembly

56
00:03:37,022 --> 00:03:40,366
runtime. And this runtime, like I said, cloud be executed

57
00:03:40,398 --> 00:03:43,518
on ARM x 86, Windows, Mac, Linux, Raspberry PI,

58
00:03:43,614 --> 00:03:47,142
kubernetes, whatever, right? So you can write code in

59
00:03:47,196 --> 00:03:50,258
any program. So that essentially is webassembly.

60
00:03:50,434 --> 00:03:53,746
A couple of more things for you to know. Like I mentioned earlier,

61
00:03:53,778 --> 00:03:57,686
it started off in the browser, but sometime in the

62
00:03:57,708 --> 00:04:00,818
late, I think 2010s, around 2017 18,

63
00:04:00,994 --> 00:04:04,506
there were calls to say, hey, this might actually make sense if you

64
00:04:04,528 --> 00:04:08,026
could run it on the serverless side as well. So we'll talk

65
00:04:08,048 --> 00:04:11,162
about that very soon because that's our focus for today.

66
00:04:11,296 --> 00:04:14,654
And the whole idea really is a compile once and then run

67
00:04:14,692 --> 00:04:18,110
that code on any number of targets because it is so

68
00:04:18,180 --> 00:04:21,600
portable. Now how does this really work? How does

69
00:04:22,530 --> 00:04:26,370
this compile once type thing really works? So you need to know some

70
00:04:26,440 --> 00:04:29,726
basic terminology. So when I say a WASM

71
00:04:29,758 --> 00:04:33,538
module, we use the words guest and host. So a

72
00:04:33,544 --> 00:04:37,090
WASM module essentially is that webassembly program

73
00:04:37,160 --> 00:04:40,886
that you wrote. You wrote a program in some language which converted it into a

74
00:04:40,908 --> 00:04:44,886
WASM module. So for instance, you created a function to add two numbers

75
00:04:44,988 --> 00:04:47,978
or to increment a number by one,

76
00:04:48,064 --> 00:04:51,894
right? So that is a WASM module. Now the theory

77
00:04:51,942 --> 00:04:56,246
behind webassembly is it's secure by default or it's sandboxed

78
00:04:56,278 --> 00:05:00,226
by default, which means no other webassembly

79
00:05:00,278 --> 00:05:04,250
module, no other HTTP request, nothing can access this module

80
00:05:04,330 --> 00:05:07,662
by default. Now this module runs in something called

81
00:05:07,716 --> 00:05:11,502
a runtime or a host, and even

82
00:05:11,636 --> 00:05:15,086
this host can run multiple modules. And for one WASM

83
00:05:15,118 --> 00:05:18,318
module to access something in another WASM module,

84
00:05:18,414 --> 00:05:22,100
it cannot unless given explicit permissions to do so.

85
00:05:22,870 --> 00:05:26,146
There are some things we don't need to get into the weeds of some things,

86
00:05:26,168 --> 00:05:29,686
like shared memory and all of that. But the analogy that

87
00:05:29,708 --> 00:05:33,542
I want to draw here is think of a guest WASM module as

88
00:05:33,676 --> 00:05:37,762
like a room in a hotel that you're staying and the host runtime

89
00:05:37,826 --> 00:05:41,682
is the hotel itself. Now as a guest you have access only to

90
00:05:41,756 --> 00:05:44,906
your room, not to the other rooms of course, but there are some

91
00:05:44,928 --> 00:05:48,442
things that are started like say the gym or a restaurant or a lounge within

92
00:05:48,496 --> 00:05:52,300
that hotel that other guests can also

93
00:05:52,690 --> 00:05:56,240
make use of. So that's the analogy that you can think of.

94
00:05:56,930 --> 00:06:00,778
So essentially with this compile and run, you write your code in any language

95
00:06:00,874 --> 00:06:04,510
which is then compiled to a webassembly or a WaSm

96
00:06:04,590 --> 00:06:08,434
bytecode format. And this can run in any

97
00:06:08,472 --> 00:06:11,906
place that can run a webassembly runtime. So think of it as

98
00:06:11,928 --> 00:06:15,990
a virtual machine that can run a webassembly runtime.

99
00:06:16,490 --> 00:06:20,262
Now we said that it originated in the browser, right?

100
00:06:20,316 --> 00:06:23,122
And because of its lightweight,

101
00:06:23,186 --> 00:06:26,614
because of its performance, because of its security, everyone's like hey,

102
00:06:26,652 --> 00:06:30,282
hold on, this actually might make sense if you want to run it in

103
00:06:30,336 --> 00:06:33,866
the server side as well. But guess what? For something to

104
00:06:33,968 --> 00:06:37,334
run on a server you need access to things like files,

105
00:06:37,462 --> 00:06:42,154
you need access to things like sockets, system clocks, random number generators

106
00:06:42,202 --> 00:06:45,854
and so on. So in the late two thousand and ten s this

107
00:06:45,892 --> 00:06:49,706
thing called Wazi was introduced which stands for webassembly

108
00:06:49,738 --> 00:06:52,894
systems interface, which essentially enabled you to

109
00:06:52,932 --> 00:06:56,622
run webassembly on the server side. And quite frankly,

110
00:06:56,686 --> 00:07:00,034
this was a big turning point towards this shift of how

111
00:07:00,072 --> 00:07:03,614
webassembly can change cloud compute. The TLDR,

112
00:07:03,662 --> 00:07:07,250
of course, is you can now run wasm outside of the browser.

113
00:07:07,590 --> 00:07:10,898
Browser Bowser is Mario character,

114
00:07:10,994 --> 00:07:14,498
but essentially you get access to several operating system like features,

115
00:07:14,514 --> 00:07:18,274
right? So access to files, clocks, random number generators,

116
00:07:18,322 --> 00:07:21,994
all of the things you need to run on a server. The cool

117
00:07:22,032 --> 00:07:25,286
thing is it retains wasm sandboxing,

118
00:07:25,398 --> 00:07:29,066
but it also includes input output. So unless you give

119
00:07:29,088 --> 00:07:32,166
it explicit permissions to access a file or

120
00:07:32,208 --> 00:07:36,506
for a file to access this module, it is security sandboxed

121
00:07:36,538 --> 00:07:40,110
by default. And the good thing is browser is not needed.

122
00:07:40,180 --> 00:07:43,654
So it doesn't depend on a web app or JavaScript,

123
00:07:43,722 --> 00:07:47,842
because we're all Python fans here. If you

124
00:07:47,896 --> 00:07:51,454
take a look at the top 20 languages according to Redmonks

125
00:07:51,502 --> 00:07:55,086
ranking, a chunk of them, actually most of them except things

126
00:07:55,128 --> 00:07:59,394
like CSS of course, or PowerShell have support for Webassembly,

127
00:07:59,442 --> 00:08:02,674
right? So everything from JavaScript, Python, Ruby, typeScript,

128
00:08:02,722 --> 00:08:06,194
all of that, and across things like core Webassembly,

129
00:08:06,242 --> 00:08:09,914
browser Wazi, and even spin the SDK that I'll be talking

130
00:08:09,952 --> 00:08:14,054
about in a bit have access. And this is in a continual

131
00:08:14,102 --> 00:08:17,674
state of evolution where there's even more language support coming

132
00:08:17,712 --> 00:08:21,098
in day by day. So the question is I think, how do

133
00:08:21,104 --> 00:08:24,558
I compile my code webassembly? I know to write code in Python, I know to

134
00:08:24,564 --> 00:08:27,774
write code in rust. What's actually happening now?

135
00:08:27,812 --> 00:08:31,358
The thing is, with compile languages like Rust or C or

136
00:08:31,364 --> 00:08:34,814
C plus plus, it actually is a much easier

137
00:08:34,862 --> 00:08:38,334
process, right? Rust, for instance, has amazing webassembly

138
00:08:38,382 --> 00:08:42,434
support because with Rust you compile it to a webassembly module which

139
00:08:42,472 --> 00:08:45,374
can execute on a webassembly runtime wherever,

140
00:08:45,422 --> 00:08:49,298
right? Similar to how we spoke about. Now this is a compiled language,

141
00:08:49,394 --> 00:08:52,710
so it's already low level in that sense.

142
00:08:52,860 --> 00:08:56,786
But with interpreted languages these are a little more tricky

143
00:08:56,898 --> 00:09:00,666
because with languages such as JavaScript and Python, you are

144
00:09:00,688 --> 00:09:04,330
writing code which are then interpreted to something that's at a lower level,

145
00:09:04,400 --> 00:09:07,174
which can then run like bytecode.

146
00:09:07,302 --> 00:09:10,502
So here's a nice piece of trickery that actually

147
00:09:10,576 --> 00:09:14,826
happens where you write a program in Python that's compiled to webassembly,

148
00:09:14,858 --> 00:09:17,434
that's executed on a webassembly runtime.

149
00:09:17,562 --> 00:09:21,774
So if you take a Python program, but that

150
00:09:21,892 --> 00:09:25,586
needs to be interpreted. So what actually happens is a

151
00:09:25,608 --> 00:09:29,614
bunch of very smart and knowledgeable people have provided

152
00:09:29,662 --> 00:09:32,702
the Python source code, like cpython for instance,

153
00:09:32,846 --> 00:09:37,102
in a webassembly format itself, which is then sort of compiled

154
00:09:37,166 --> 00:09:40,766
along with your program into Webassembly, which then runs

155
00:09:40,798 --> 00:09:44,214
on the Wasm runtime. Now this sounds complicated, but the good

156
00:09:44,252 --> 00:09:47,474
news is you don't have to worry about how any of that works.

157
00:09:47,612 --> 00:09:50,954
If you want to build a program in Python that

158
00:09:51,072 --> 00:09:55,718
converts to webassembly, all you have to do is do the Python bits.

159
00:09:55,894 --> 00:09:59,926
And this particular step of this compiling

160
00:09:59,958 --> 00:10:03,006
the interpreter to WASM, is actually done by hand.

161
00:10:03,108 --> 00:10:06,318
So a bunch of smart people are doing this by hand.

162
00:10:06,404 --> 00:10:09,582
They're testing it out so that devs such as

163
00:10:09,636 --> 00:10:12,990
us can actually just focus on writing code

164
00:10:13,060 --> 00:10:16,206
in Python. So that's how interpreted

165
00:10:16,238 --> 00:10:19,010
languages actually compile to Webassembly,

166
00:10:19,750 --> 00:10:22,754
spoken quite a bit, and I don't think you've seen code

167
00:10:22,792 --> 00:10:26,226
so far. So I'm going to get to code very shortly. How do

168
00:10:26,248 --> 00:10:29,334
you get started with building your first webassembly app?

169
00:10:29,452 --> 00:10:33,314
So I'm going to use this open source project called Spin.

170
00:10:33,442 --> 00:10:37,574
Now, spin is the open source tool for building webassembly and

171
00:10:37,612 --> 00:10:41,206
serverless apps. Check it out. On GitHub.

172
00:10:41,318 --> 00:10:44,566
You can create a new serverless app with just three commands,

173
00:10:44,598 --> 00:10:48,106
I promise, and you can even deploy it in the

174
00:10:48,128 --> 00:10:52,214
cloud with the fourth command. And I'm going to show you how it's

175
00:10:52,262 --> 00:10:55,854
completely open source. So if you'd like to contribute to open source? Go ahead

176
00:10:55,892 --> 00:10:59,294
and do so. In fact, there is a bot called the good first

177
00:10:59,332 --> 00:11:02,750
issue bot, which gives you good first issues that you can

178
00:11:02,820 --> 00:11:05,870
get started with contributing to spin.

179
00:11:06,450 --> 00:11:09,762
It supports 15 plus programming languages, very simple

180
00:11:09,816 --> 00:11:13,490
CLI and developer experience. We have 4.6k

181
00:11:13,560 --> 00:11:17,234
stars on GitHub. We also have a discord channel and things like that. So feel

182
00:11:17,272 --> 00:11:21,222
free to jump in. I think it's a nice community. So yeah,

183
00:11:21,276 --> 00:11:24,626
you can do that. And again, just to give you a sense of what spin

184
00:11:24,658 --> 00:11:29,334
is, completely open source and it's built with open standards supported

185
00:11:29,382 --> 00:11:32,570
by the Bytecode alliance. At a glance,

186
00:11:33,550 --> 00:11:36,938
you get the dev experience around building webassembly apps on

187
00:11:36,944 --> 00:11:40,698
the server side, but you also get things like writing serverless AI. You get

188
00:11:40,704 --> 00:11:44,426
a key value store CLI and also a SQL

189
00:11:44,458 --> 00:11:48,014
database that you can use. Right? And you have different triggers for this.

190
00:11:48,052 --> 00:11:51,418
And we will talk about it very shortly.

191
00:11:51,594 --> 00:11:55,346
So again, enough of me talking. Maybe let's dive straight into the

192
00:11:55,368 --> 00:11:59,138
demo. All of this can be found on developer fermion.com

193
00:11:59,304 --> 00:12:02,558
spin. And like I said, it's completely open source.

194
00:12:02,654 --> 00:12:07,142
So I'm going to open up my terminal right

195
00:12:07,196 --> 00:12:07,800
here.

196
00:12:11,690 --> 00:12:15,480
All right, so I've installed the spin CLi already

197
00:12:16,650 --> 00:12:20,330
and I'm just going to start off with the first of the three commands.

198
00:12:22,110 --> 00:12:26,314
Not spin, but spin. I said three commands. So this is the first of

199
00:12:26,432 --> 00:12:30,074
those three commands, which is to create a new spin app. Right.

200
00:12:30,112 --> 00:12:33,802
We're creating our first serverless web app using Python.

201
00:12:33,946 --> 00:12:37,822
Now you will see there are a bunch of templates for you to get started.

202
00:12:37,956 --> 00:12:41,566
And on the left are triggers, right? Typically triggers are

203
00:12:41,588 --> 00:12:45,130
things like HTTP because with serverless it's completely

204
00:12:45,220 --> 00:12:49,058
event driven. Or you can also have triggers such as

205
00:12:49,224 --> 00:12:52,994
Redis, which is a redis database. Right? So right there

206
00:12:53,112 --> 00:12:56,594
on the right you will see a bunch of languages like C and go and

207
00:12:56,632 --> 00:12:59,926
Python and rust. So those are the different languages for

208
00:12:59,948 --> 00:13:03,670
you to get started to write those webassembly apps.

209
00:13:04,330 --> 00:13:07,758
We are talking about Python today. So I'm going to go ahead and say HTTP

210
00:13:07,794 --> 00:13:11,900
python. I'm saying hello world.

211
00:13:12,430 --> 00:13:16,234
Conf 42. All right, skip the description. There's something

212
00:13:16,272 --> 00:13:19,594
called HTTP Path, which you can specify a

213
00:13:19,632 --> 00:13:22,922
URL upon which your app will be

214
00:13:22,976 --> 00:13:27,054
triggered. So say checkout will trigger a certain module or

215
00:13:27,172 --> 00:13:30,686
add to cart will trigger something else. Here we, let's leave

216
00:13:30,708 --> 00:13:34,354
it as default, which means anything to that URL will give

217
00:13:34,392 --> 00:13:37,806
you or will trigger this app. So I'm

218
00:13:37,838 --> 00:13:42,302
going to hello world, I'm going to CD into this directory

219
00:13:42,446 --> 00:13:45,906
and then just open it in vs code and let's see

220
00:13:45,928 --> 00:13:49,586
how that goes. All right, so a spin

221
00:13:49,618 --> 00:13:52,806
app is fairly simple and the entry point to the app is

222
00:13:52,828 --> 00:13:56,850
this thing called an app manifest or a spin toml.

223
00:13:56,930 --> 00:14:00,074
Now you can see some metadata here. You don't have to worry about that.

224
00:14:00,192 --> 00:14:03,882
This is the trigger that we added where we say here

225
00:14:04,016 --> 00:14:07,562
by default, hit this particular component which

226
00:14:07,696 --> 00:14:11,466
the code to which we will be writing very soon. And there is some description

227
00:14:11,498 --> 00:14:15,114
of that component as well. So you can see the wasm file

228
00:14:15,242 --> 00:14:18,622
and you can see the command to create,

229
00:14:18,756 --> 00:14:22,414
to convert it from python to wasm using this

230
00:14:22,452 --> 00:14:26,314
thing called pytovasm. Again, we as developers don't have to worry

231
00:14:26,362 --> 00:14:30,066
about how pytovasm works. We just know that some people have

232
00:14:30,088 --> 00:14:34,020
created this pytovasm and we can focus on writing our python code.

233
00:14:34,470 --> 00:14:37,810
Now, serverless is completely event driven, right? So you get

234
00:14:37,880 --> 00:14:41,058
a request and you have to send a response.

235
00:14:41,154 --> 00:14:44,406
Now this is the simplest hello world possible. So there is

236
00:14:44,428 --> 00:14:48,620
a request coming in. We are sending a response of 200k saying hello

237
00:14:49,310 --> 00:14:52,442
Conf 42. Right. And I'm going to save

238
00:14:52,496 --> 00:14:56,170
that. Now, we added our first command, which was

239
00:14:56,320 --> 00:15:00,134
spin new. I'm going to build my program by saying spin

240
00:15:00,182 --> 00:15:03,946
build. Right. You can see how fast that was. I haven't sped

241
00:15:03,978 --> 00:15:07,262
up the video or anything. That is literally it. And now

242
00:15:07,316 --> 00:15:10,638
I can just say spin up, which is to test

243
00:15:10,724 --> 00:15:14,370
the app locally. Now this is part of a good developer experience

244
00:15:14,440 --> 00:15:17,650
where you can test something locally before pushing it to

245
00:15:17,720 --> 00:15:21,314
the crowd cloud with my pronunciations today.

246
00:15:21,432 --> 00:15:24,180
So I can just do a simple curl to this.

247
00:15:27,530 --> 00:15:29,800
I sorry,

248
00:15:31,930 --> 00:15:35,318
I'm just going to do that again. I'm going

249
00:15:35,324 --> 00:15:39,186
to do a spin up so that it's running locally.

250
00:15:39,298 --> 00:15:43,254
Right. That's spin up running locally. And I'm just doing a curl

251
00:15:43,302 --> 00:15:46,922
command. Curl minus I, right.

252
00:15:46,976 --> 00:15:50,742
And as you can see, the response returned is hello Conf 42.

253
00:15:50,816 --> 00:15:54,810
So in three commands we went from nothing to creating

254
00:15:54,970 --> 00:15:58,458
app that is running locally. And it's

255
00:15:58,474 --> 00:16:01,966
a serverless webassembly app written in Python. The cool thing

256
00:16:01,988 --> 00:16:06,338
is with the fourth command I can deploy this to the fermion cloud.

257
00:16:06,424 --> 00:16:09,874
So actually have this app that's running in the

258
00:16:09,912 --> 00:16:13,954
cloud for anyone to access. Now how this essentially works is it

259
00:16:13,992 --> 00:16:17,474
takes that particular wasm file that has been created,

260
00:16:17,522 --> 00:16:20,440
which I'll show you now, and it pushes it to the cloud.

261
00:16:20,970 --> 00:16:23,400
So if I do,

262
00:16:24,090 --> 00:16:27,746
let me do ls, you can see ls.

263
00:16:27,858 --> 00:16:31,334
Oh, if I do ls minus La, you can actually

264
00:16:31,372 --> 00:16:35,354
see an app wasm that's created here, which is about

265
00:16:35,552 --> 00:16:39,626
a couple of megabytes, and if you do a

266
00:16:39,808 --> 00:16:43,786
Nanoapp wasm, you will see the bytecode

267
00:16:43,818 --> 00:16:47,678
format, which for us it's mostly gibberish. Right? It doesn't make sense,

268
00:16:47,764 --> 00:16:51,610
but that's essentially what the webassembly runtime is reading.

269
00:16:51,770 --> 00:16:55,154
So yeah, it's deployed to the cloud. In fact, I can go

270
00:16:55,192 --> 00:16:58,754
to this website right now and I will hopefully be

271
00:16:58,792 --> 00:17:03,954
able to see the

272
00:17:03,992 --> 00:17:07,606
output. Right, there we go. You can see. Hello conf fourty two.

273
00:17:07,628 --> 00:17:11,686
So like I said, in four commands we have gone from nothing to deploying an

274
00:17:11,708 --> 00:17:14,040
app in the cloud in hardly any time.

275
00:17:14,410 --> 00:17:18,198
Cool. So let's get back to this.

276
00:17:18,284 --> 00:17:21,994
So four things that make Webassembly great, right? So the first one

277
00:17:22,032 --> 00:17:25,674
is binary size itself. Why is webassembly a big deal?

278
00:17:25,712 --> 00:17:29,580
Why is it going to be the next wave of cloud compute? Well,

279
00:17:30,030 --> 00:17:33,758
at scale, things like binary size makes a big difference, because that changes

280
00:17:33,844 --> 00:17:37,022
your deploy times, it changes your startup times, it changes

281
00:17:37,076 --> 00:17:38,830
your carbon footprint.

282
00:17:40,050 --> 00:17:43,406
There was a benchmark done in rust, and hello World was

283
00:17:43,428 --> 00:17:47,054
just about two mb, and then ahead of time compiled

284
00:17:47,102 --> 00:17:50,350
rust. Webassembly app was only about 300 kb.

285
00:17:50,510 --> 00:17:54,194
We just saw in our demo as well. The app WASM file was about 2.5

286
00:17:54,232 --> 00:17:57,990
mb, which was a simple file. So these are very, very small apps.

287
00:17:58,490 --> 00:18:02,326
The same thing using, if you're running it

288
00:18:02,348 --> 00:18:06,594
in flask, say on Docker or something, is a much bigger file.

289
00:18:06,722 --> 00:18:10,060
So Webassembly is lightweight, and it's designed to be so

290
00:18:10,750 --> 00:18:14,460
startup times are comparable with natively compiled code.

291
00:18:16,030 --> 00:18:19,402
It's not the same, of course it's going to be slightly slower. Again,

292
00:18:19,456 --> 00:18:22,766
with Rust it was about 2.3 x slower than native, but those are

293
00:18:22,788 --> 00:18:26,958
near native compile times, which make a lot of sense, especially when you're building

294
00:18:27,044 --> 00:18:30,814
at scale. We mentioned earlier about how

295
00:18:30,852 --> 00:18:33,922
Webassembly is portable, which means you can build this once

296
00:18:33,976 --> 00:18:37,394
and run it anywhere. That app wasm will run

297
00:18:37,432 --> 00:18:40,626
on any runtime which supports Webassembly, right?

298
00:18:40,648 --> 00:18:44,494
So the same, just in time build will work across operating systems,

299
00:18:44,542 --> 00:18:48,680
platform architectures, different systems and so on.

300
00:18:49,130 --> 00:18:53,234
And like I mentioned, it's designed to be security sandboxed

301
00:18:53,282 --> 00:18:56,982
by default. So the approach is a very capability based

302
00:18:57,036 --> 00:19:00,674
security model. Any HTTP request using in or

303
00:19:00,812 --> 00:19:04,810
going out or coming in has to be explicitly given. Any access

304
00:19:04,880 --> 00:19:08,426
to files in or out, again has to be explicitly given,

305
00:19:08,528 --> 00:19:11,690
which makes this very secure by default.

306
00:19:12,110 --> 00:19:16,426
When I said the next wave of cloud computing will be powered by webassembly,

307
00:19:16,618 --> 00:19:20,286
how will this change? Yeah, sure, it has all these cool things. But how will

308
00:19:20,308 --> 00:19:23,894
this really change cloud computing? Well, my prediction

309
00:19:23,962 --> 00:19:27,506
is, and I've been working a lot with emerging tech for the

310
00:19:27,528 --> 00:19:31,314
last ten years, is that it will change things gradually and

311
00:19:31,352 --> 00:19:34,962
then suddenly, because there are so many

312
00:19:35,016 --> 00:19:38,294
things that we are seeing in how cloud computing is evolving right

313
00:19:38,332 --> 00:19:41,878
now. If you see the evolution of it,

314
00:19:41,964 --> 00:19:45,714
we've gone from a pre cloud era where we had this server

315
00:19:45,762 --> 00:19:49,618
running down the hallway in this room that was cooled by multiple air

316
00:19:49,644 --> 00:19:52,874
conditioners, where you had to take care of everything from the

317
00:19:52,912 --> 00:19:55,740
hardware to the security, the physical security,

318
00:19:56,350 --> 00:19:59,738
but to the kernel, the drivers, the operating system, and of

319
00:19:59,744 --> 00:20:03,182
course, your app. Good old days. We don't want to go there

320
00:20:03,236 --> 00:20:06,634
anymore. As we evolved towards things like virtual

321
00:20:06,682 --> 00:20:10,126
machines, we saw where the physical security

322
00:20:10,228 --> 00:20:13,786
and the space we didn't really need to care about. A cloud provider

323
00:20:13,818 --> 00:20:17,122
gave that to us. We could focus on things like our

324
00:20:17,176 --> 00:20:20,562
app, but also we had to take care of updating our os and

325
00:20:20,616 --> 00:20:22,850
security and our utilities.

326
00:20:23,510 --> 00:20:27,138
That has changed a bit with containers, and now that is changing with

327
00:20:27,224 --> 00:20:30,790
serverless, where you can focus only on your business

328
00:20:30,860 --> 00:20:33,986
logic and your app, you don't need to worry about scaling

329
00:20:34,018 --> 00:20:37,842
up, about scaling down, about updates, any of that. Right? The host

330
00:20:37,906 --> 00:20:42,170
takes care of most of that. You as a dev, focus only on

331
00:20:42,240 --> 00:20:45,578
your business logic. So talking about how that changes

332
00:20:45,664 --> 00:20:49,766
containers, well, sorry, how that changes cloud computing, well, we won't

333
00:20:49,798 --> 00:20:53,566
see any more clunky containers. I'm sure we're all familiar with

334
00:20:53,588 --> 00:20:57,054
things like Docker and Kubernetes. These are widely used in

335
00:20:57,092 --> 00:21:00,302
enterprises, in startups wherever, right?

336
00:21:00,356 --> 00:21:03,410
And it's a known fact that with containers,

337
00:21:04,310 --> 00:21:07,746
there is a huge underutilization of opensource that

338
00:21:07,768 --> 00:21:11,202
actually happen. So, excuse me. Even in

339
00:21:11,256 --> 00:21:15,150
a study of the top 50 public software companies, it's estimated

340
00:21:15,230 --> 00:21:18,902
about $100 billion of market value is lost because of

341
00:21:18,956 --> 00:21:22,918
the cloud impact on margins. What this basically means

342
00:21:23,004 --> 00:21:26,294
is when we are provisioning for cloud computing space,

343
00:21:26,412 --> 00:21:29,746
we typically provision for the peaks and not the average,

344
00:21:29,858 --> 00:21:33,482
right? We're like, hey, what if there is so much usage on our app?

345
00:21:33,536 --> 00:21:37,194
This is the peak usage on our app that happens once a month,

346
00:21:37,312 --> 00:21:40,574
so we have to provision for that much. But guess what?

347
00:21:40,612 --> 00:21:44,078
Your average usage is way below, and that's what's running

348
00:21:44,164 --> 00:21:48,506
most of the time. So there's all of these resources

349
00:21:48,538 --> 00:21:52,398
that are being underutilized with webassembly. You can actually

350
00:21:52,484 --> 00:21:56,034
scale to zero in no time, right? You can scale up and scale down

351
00:21:56,072 --> 00:21:59,538
in no time. And it's so lightweight, so you can pack a

352
00:21:59,544 --> 00:22:03,170
container with far more number of app than you are doing currently,

353
00:22:03,320 --> 00:22:06,114
thereby utilizing your resources better.

354
00:22:06,312 --> 00:22:09,686
And as a company scales, or as you deploy more

355
00:22:09,708 --> 00:22:13,094
and more apps into a container, this starts making a lot

356
00:22:13,132 --> 00:22:16,550
more sense, right? We're talking about again, running in the cloud

357
00:22:16,620 --> 00:22:19,754
at scale. You start saving costs, you're faster, you're more

358
00:22:19,792 --> 00:22:22,922
agile, you can do things

359
00:22:22,976 --> 00:22:26,246
quicker as well with microservices. So this starts

360
00:22:26,278 --> 00:22:29,850
making sense again. So webassembly is using to change this

361
00:22:29,920 --> 00:22:33,370
part, and the second is it could potentially

362
00:22:33,450 --> 00:22:37,034
fix serverless as well. Now, serverless is gaining

363
00:22:37,082 --> 00:22:40,826
a lot of traction in the last few years with services like Lambda

364
00:22:40,858 --> 00:22:44,466
and Azure functions and so on. There are a few problems that

365
00:22:44,488 --> 00:22:46,690
I see with things like serverless.

366
00:22:47,350 --> 00:22:50,962
One is of course, serverless in the public cloud has

367
00:22:51,016 --> 00:22:54,702
a cold start problem, if you're not familiar. Basically how serverless

368
00:22:54,766 --> 00:22:58,742
works is there is an event that goes to a function that's running

369
00:22:58,796 --> 00:23:02,866
somewhere, and then that program starts, executes, and then sends

370
00:23:02,898 --> 00:23:06,406
a response back. But with how services

371
00:23:06,508 --> 00:23:10,598
such as lambda and Azure functions are actually structured.

372
00:23:10,694 --> 00:23:14,634
There is something called a cold start time, which means there is a finite amount

373
00:23:14,672 --> 00:23:18,522
of time between the request being sent and the program actually

374
00:23:18,576 --> 00:23:22,314
starting up. And it could take even about two to 3 seconds

375
00:23:22,362 --> 00:23:26,254
with AWS Lambda. But typically we see maybe about 500

376
00:23:26,292 --> 00:23:30,254
milliseconds as the cloud start time. This is not ideal for

377
00:23:30,292 --> 00:23:33,782
many use cases where speed is of the essence,

378
00:23:33,946 --> 00:23:37,886
and people have like complex and expensive workarounds

379
00:23:37,918 --> 00:23:41,394
by warming up an instance by sending pings once in a while,

380
00:23:41,432 --> 00:23:45,586
which these costs are borne by you as the customer. So that's

381
00:23:45,618 --> 00:23:48,710
not just coding complexity, but also costs.

382
00:23:49,210 --> 00:23:51,640
With Webassembly you can actually,

383
00:23:52,250 --> 00:23:56,182
because of its small size and its fast startup time, we are actually

384
00:23:56,236 --> 00:24:00,234
able to cold start a module on every execution in just

385
00:24:00,272 --> 00:24:03,862
about two milliseconds, right? So that is a significant

386
00:24:03,926 --> 00:24:07,594
difference between, say, an AWS lambda, and again,

387
00:24:07,632 --> 00:24:11,194
this is due to the properties of webassembly as well as

388
00:24:11,392 --> 00:24:14,878
our tech stack, where we're able to do this and then scale it

389
00:24:14,884 --> 00:24:18,462
down back to zero. So if your function has run something,

390
00:24:18,516 --> 00:24:22,538
that's all you're charged for. So broadly,

391
00:24:22,634 --> 00:24:26,546
these are a couple of ways that the cloud will potentially change with

392
00:24:26,568 --> 00:24:29,826
the adoption of webassembly. I did

393
00:24:29,848 --> 00:24:33,634
promise you two demos, so I'm going to show you another demo, and this time

394
00:24:33,672 --> 00:24:37,222
the usage of serverless again, but again,

395
00:24:37,276 --> 00:24:40,786
using AI. So llms or large language models

396
00:24:40,818 --> 00:24:44,054
are the talk of town. Everyone's talking about it. So I did

397
00:24:44,092 --> 00:24:47,478
say spin gives you access to LLM as well.

398
00:24:47,564 --> 00:24:51,082
We have access to the llama two language model, right?

399
00:24:51,136 --> 00:24:54,266
And again with just like five lines of code. I'm going to show you a

400
00:24:54,288 --> 00:24:57,786
simple hello worldish app, but that one that is actually

401
00:24:57,888 --> 00:25:01,980
using AI. So I've written the program already.

402
00:25:02,290 --> 00:25:05,920
It's pretty simple. All you have to do is import

403
00:25:06,370 --> 00:25:10,490
couple of libraries, especially spin LLM.

404
00:25:10,570 --> 00:25:13,954
And again, remember we are doing this serverlessly. So request comes in,

405
00:25:13,992 --> 00:25:17,954
request goes out. Now we have to call

406
00:25:17,992 --> 00:25:21,614
this function called LLM infer and mention the large language

407
00:25:21,662 --> 00:25:25,074
model which is llama to chat, followed by

408
00:25:25,112 --> 00:25:28,986
the text itself. So I'm just saying, can you tell me a joke about cats

409
00:25:29,118 --> 00:25:32,754
have no idea what output this will send and if it's successful,

410
00:25:32,802 --> 00:25:35,970
it'll actually return the text. If there's an error, it'll return the error.

411
00:25:36,050 --> 00:25:40,022
So ten lines of code, but really it's like two lines of

412
00:25:40,156 --> 00:25:42,780
code that you need to know, right? It's literally that simple.

413
00:25:43,230 --> 00:25:47,162
The one small change to your spin toml from earlier is

414
00:25:47,216 --> 00:25:50,346
I mentioned the AI model that I want to speak to.

415
00:25:50,528 --> 00:25:53,966
This is cool because as and when we have support for

416
00:25:53,988 --> 00:25:57,214
different models, you can just swap this out for a different model

417
00:25:57,252 --> 00:26:02,046
name or potentially even bring your own model and you

418
00:26:02,068 --> 00:26:05,410
don't have to recreate everything from scratch and so on.

419
00:26:05,560 --> 00:26:11,042
So I am going to go back here and

420
00:26:11,096 --> 00:26:14,994
do the same steps again. Remember, just spin build. And now

421
00:26:15,032 --> 00:26:18,934
I can run this locally or I can run it in the

422
00:26:18,972 --> 00:26:22,598
cloud. This is using a large language model though, so if I

423
00:26:22,604 --> 00:26:26,198
run it locally it can take about 10 minutes

424
00:26:26,284 --> 00:26:30,106
to actually process it because I'm running it on a MacBook. There is

425
00:26:30,128 --> 00:26:33,706
a pretty cool plugin that someone's written for spin where

426
00:26:33,808 --> 00:26:37,402
you can run this program locally, but talk to a large

427
00:26:37,456 --> 00:26:40,758
language model that's running in the cloud. So I'm going to

428
00:26:40,784 --> 00:26:44,842
do that. I've done one step of a runtime

429
00:26:44,906 --> 00:26:48,702
config, but let's open the browser and see

430
00:26:48,756 --> 00:26:53,966
how this goes and see if it's fast as well. Hitting enter now and

431
00:26:54,068 --> 00:26:57,746
in maybe a second or two. Yes. So there we

432
00:26:57,768 --> 00:27:00,990
go. These are the cat jokes. Why did the cat go to the vet

433
00:27:01,070 --> 00:27:03,890
to get its positive diagnosis?

434
00:27:04,390 --> 00:27:07,630
What did you call a group of cats playing instruments? A musical band?

435
00:27:07,710 --> 00:27:10,946
Well, I didn't say the jokes are good, but well, it is a joke.

436
00:27:10,978 --> 00:27:14,150
That's what the AI decided was funny. So who are we to judge?

437
00:27:15,370 --> 00:27:18,966
Again, this is completely serverless. I didn't need to have a

438
00:27:18,988 --> 00:27:22,806
large language model running on a server in the cloud consistently,

439
00:27:22,918 --> 00:27:27,046
right? It made a request to a large language model that processed,

440
00:27:27,078 --> 00:27:30,186
it sent a request back to me and that's it again.

441
00:27:30,288 --> 00:27:33,758
You saw the speeds, the scale up and scale down, and this is just the

442
00:27:33,764 --> 00:27:37,354
tip of the iceberg. The one thing that I'm super excited

443
00:27:37,402 --> 00:27:40,846
about in the webassembly and serverless webassembly world

444
00:27:40,948 --> 00:27:43,600
is something called the component model.

445
00:27:43,910 --> 00:27:47,730
So software, when we build software now, the process

446
00:27:47,800 --> 00:27:50,910
itself is kind of weird, because, for instance,

447
00:27:51,070 --> 00:27:54,946
you're writing an app in JavaScript and you need two things. You need a

448
00:27:54,968 --> 00:27:58,694
YAml parser and a date formatter. But guess what? There are

449
00:27:58,732 --> 00:28:02,710
no great YAml parsers in JavaScript. There are no date formatters.

450
00:28:03,050 --> 00:28:06,166
Great date formatters in JS. So you write your

451
00:28:06,188 --> 00:28:09,926
own, right, or you write one, or you use one that is not very good.

452
00:28:10,028 --> 00:28:13,814
Basically it's very inefficient. But there are great rust

453
00:28:13,862 --> 00:28:17,926
YAml passes, because rust is very good at parsing lots of data, and Python

454
00:28:17,958 --> 00:28:21,158
is very good with numbers. So there's an amazing Python date formatter.

455
00:28:21,254 --> 00:28:24,474
So what if there was a way for you to, in your JavaScript

456
00:28:24,522 --> 00:28:28,106
app, use a Rust YAml parser and a Python date formatter?

457
00:28:28,218 --> 00:28:32,030
Well, with the component model, which is live, and you can try it out,

458
00:28:32,100 --> 00:28:35,794
this is actually possible. The idea is all of these

459
00:28:35,832 --> 00:28:39,886
languages convert to a webassembly module. So if you define

460
00:28:39,918 --> 00:28:43,694
can interface that allows you to talk to interface

461
00:28:43,742 --> 00:28:47,570
where these modules can talk to each other, then you can theoretically

462
00:28:47,730 --> 00:28:51,590
have an app composed of different modules in different languages.

463
00:28:51,930 --> 00:28:56,210
And it's not just theory, because there are enough examples now of languages

464
00:28:56,290 --> 00:28:59,586
written in different, sorry, programs written

465
00:28:59,618 --> 00:29:03,114
in different languages. So you could write something in Rust Python C

466
00:29:03,152 --> 00:29:06,874
plus plus, which should compile to a webassembly module and talk to

467
00:29:06,912 --> 00:29:10,282
each other. And you could compose an application this way.

468
00:29:10,336 --> 00:29:13,850
So you have a component a, which has a core webassembly module,

469
00:29:13,930 --> 00:29:17,566
which exports a function, and component b wants to import

470
00:29:17,668 --> 00:29:20,910
that same function. So you can join the two together,

471
00:29:21,060 --> 00:29:24,626
they can be in rust, go Python, whatever, and thereby you

472
00:29:24,648 --> 00:29:28,114
create a new component called c. So this is

473
00:29:28,152 --> 00:29:31,410
possible now, and as unbelievable as it sounds,

474
00:29:31,480 --> 00:29:35,262
it literally is possible. You should check it out with Python.

475
00:29:35,326 --> 00:29:38,722
Specifically, I want to shout out the work done on something called

476
00:29:38,776 --> 00:29:42,626
componentize PI, which is a tool to convert a Python

477
00:29:42,658 --> 00:29:46,342
application to a webassembly component. It takes something

478
00:29:46,396 --> 00:29:49,894
called a wit file or wasm interface type file,

479
00:29:49,942 --> 00:29:53,818
which determines the imports and exports. It makes the

480
00:29:53,824 --> 00:29:57,382
name of something called a world, which is a very abstract

481
00:29:57,446 --> 00:30:01,414
concept, but a place where these imports can export

482
00:30:01,462 --> 00:30:04,954
and those exports can import. It takes the name of a module

483
00:30:05,002 --> 00:30:08,126
which targets that world, and a list of directories in

484
00:30:08,148 --> 00:30:11,934
which you can find this module. It's super. A few

485
00:30:11,972 --> 00:30:15,394
people who work at Fermyon have contributed to this, and again,

486
00:30:15,432 --> 00:30:18,766
it's completely open source, so check it out. It's part of the Bytecode

487
00:30:18,798 --> 00:30:22,830
alliance on GitHub.com slash Bytecode alliance slash componentize

488
00:30:22,910 --> 00:30:26,750
by all right, that's it for my presentation

489
00:30:26,830 --> 00:30:29,926
today. I think I just about made time. Feel free

490
00:30:29,948 --> 00:30:33,800
to join our Discord server or get started with spin. I'd love to

491
00:30:34,570 --> 00:30:38,294
see what you're building with Webassembly. We do a lot of cool stuff on

492
00:30:38,332 --> 00:30:41,926
YouTube and Discord, so join us there. Feel free to connect with

493
00:30:41,948 --> 00:30:45,414
me on LinkedIn if you like this presentation. Hope you learned something new today,

494
00:30:45,532 --> 00:30:49,218
and I look forward to seeing what you're building with Webassembly and spin.

495
00:30:49,314 --> 00:30:51,500
Till then, enjoy out the rest of the conference and see you soon.

