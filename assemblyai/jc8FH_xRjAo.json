{"language_code": "en_us", "audio_url": "https://cdn.assemblyai.com/upload/f3916688-0a21-4a72-90ff-7a51542d6643", "punctuate": true, "format_text": true, "dual_channel": null, "webhook_url": null, "webhook_auth_header_name": null, "webhook_auth_header_value": null, "audio_start_from": null, "audio_end_at": null, "word_boost": ["abstractions", "building", "chaur wu", "composability", "composable", "compose", "conf fourty two", "contravariant", "freelance", "functions", "functor", "functors", "pipelines", "profunctors"], "boost_param": "high", "filter_profanity": false, "redact_pii": false, "redact_pii_audio": false, "redact_pii_policies": null, "redact_pii_sub": null, "speaker_labels": false, "speakers_expected": null, "content_safety": false, "content_safety_confidence": null, "iab_categories": false, "custom_spelling": null, "disfluencies": false, "sentiment_analysis": false, "auto_chapters": false, "entity_detection": false, "summarization": true, "summary_model": "informative", "summary_type": "bullets_verbose", "auto_highlights": true, "language_detection": false, "speech_threshold": null, "speech_model": null, "id": "922be7fb-eb3a-4121-98dd-88a1dfe34b5b", "status": "completed", "error": null, "text": "Hi, thank you for coming to my talk. We will look at functions and how to use them in Python programs. If you haven't heard of functions before, this talk requires no prior knowledge of functions or category theory. The talk is for Python programmers and is designed for ease of understanding. There will be places where we will choose to simplify things at the expense of skipping some math details. The code examples are based on an open source Python package called Funklift. The links to the GitHub repositories of funklift and its tutorials are shown on the slide. Before we move on to the meat of the talk, a quick introduction of myself. My name is Char Wu. I'm a software developer, grew up in Taiwan, and I'm based in the San Francisco Bay area for the past 20 years. Now, today's agenda is very simple. We will start with a motivating example and then we will introduce various functions with even more examples. Let's start with a simple function, get price, that takes an item and returns the item's price. To visualize the code, we can draw types as dots and functions as arrows. Item is a dot in the diagram and int is also a dot. Get price is an arrow that goes from item to int. Now we have another function is pricey and we can draw it as an arrow as well. This time the arrow goes from with those two functions, what interesting things can we do with them? We can compose the two functions to form a new function. The composition of functions corresponds nicely to the composability of arrows in our diagram. A diagram like the one we are seeing here represents a category in category theory. Essentially, a category consists of dots and arrows, plus some properties about how arrows compose. We will call our category here the category of types. In this category, the dots are Python types and the arrows are Python functions. Now let's move on to see how functions are related to categories. Here we have a function is even that goes from int to bool and we have a list of numbers. 1234 we want to map is even over the numbers. One way to achieve that is by using this comprehension. Another way is to use the CDS class of the funklift package. As you can see from the code here, the CDis class has a method called fmap. Fmap takes the function is even and maps it over the list of numbers behind the scenes. On the outside, we can think of fmap as lifting is even to a function that goes from c list of int to c list of bool. If we put the is even function and its lifted counterpart side by side we can see that c list is actually a mapping from a source category to a target category. Such a mapping is called a functor if it satisfies certain properties. In our case, C list is a functor. The source category and the target category of C list are both the category of types. A functor is called an functor when its source and target categories are the same. Now that we've introduced the concepts of categories and functors, let's see some functions, and let's also see what problems they solve. It's common to have code that performs some kind of input or output. For example, we might have code that sends a request over a network, reads a file, or writes a record to a database. Such I O functions are side effects that make our code harder to reason about because they break referential transparency. Here on the side, the function get number side effect on the left has side effects because it reads user input from a console. To avoid such side effect, we can wrap the I O action into an instance of the I O class when we call the get number function on the right, no actual reading from the console. Rather, we simply get an I O object that represents the I O action. The code here shows what we can do with the I O object returned by the get number function, even though no actual I o has happened yet. When we call get number, that does not stop us from mapping the is even function over the nonexistent number when we are finally ready to incur the actual I o by coding the unsafe run method on the I O object. Although our example here is simple already, it shows that with the I o function we are able to keep the kernel of our code free of side effects and push the actual I o functions to the boundary of our program. Now let's look at another example here. At the top we have a function that takes an integer and returns ten modulo that integer. The function is a partial function because it's not defined when the input integer is zero. We can write the function at the bottom. The function at the bottom is now defined for all input values. However, we now have a different issue, and that is the new function is not very composable with other functions. Here's an illustration of the lack of composability. The code on the right tries to compose the two functions on the left. Because the ten mark by function returns either an integer or none, it is not very composable, and we have to use if else statements when we try to compose it with other functions. Is there a solution that can turn a partial function into a total function while retaining composability. That solution is the option functions. As the example here shows, the ten mark by function now returns an option of int. The option class of the funklift package has a subclass called nothing and another subclass called sum. Nothing represents the absence of a value. Sum represents the existence of a value. By the magic of functions and their fmap methods, we can compose ten map by with other functions, without any if else statements in the code. Just like how we visualize c list as a functor, we can visualize option as a functor. Map starts and arrows from a source category to a target category. So far we've been composing functions. It turns out that we can compose functions too. This diagram shows that we can compose the option functor and the c list function. The result of the composition is a new function, and we call that new functions c list after option. Like any other function, the new functions is a mapping between two categories. It maps dots to dots and arrows to arrows. If we can compose functors the way we compose arrows, does that mean functions are arrows in some sort of category? Notice that in this diagram, each rectangle represents a category. If we collapse the rectangles into dots, we will get a category whose dots are smaller categories and whose arrows are functions. Here's what that category looks like in a diagram. We call it the category of small categories. Of course, we don't just look at theories, we want to see some code, right? The code example on this slide shows how to compose functions in Python. Here, the variable nums is a C list of option objects. If we call fmap on nums, we will not be able to map over the numbers inside the option objects. In order to do that, we need to compose the two functions first, and we do that by using the compose class of the funklift package. Once we have the compose function, we can call fmap on it, just like we do with any other functions. This is really fantastic. In this diagram, capital f denotes a functor. The functions we've seen so far are called covariant functions. Here, covariant basically means that the two vertical arrows in the diagram point in the same direction. When a functor maps a source arrow to a target arrow. If the mapping does not change the direction of the arrows, then the functions is covariant. If the two vertical arrows in the diagram point in the opposite direction, then the function is contravariant. For contravariant functions, we have the fmap method. For contravarian functions, we have the cmap method similar to fmap. The cmap method lifts a function from type a to type b to a function that goes from f of b to f of a. Here's an example of a contravariant function called predicate. A predicate is something that is either true or false. In our example, we first have a predicate that will be true if we give it an even integer, and as the diagram shows, we can use cmap to convert that predicate of int into a predicate of str. With the converted predicate we can pass it the number six as a string, and it will tell us if that's an even number or not. The next type of functions we will look at is called applicative functions. Before we introduce applicative function, we need to first get to know a special kind of categories called closed category. In the diagram on the side, there are two categories. The category on the left has a dot for type a and a dot for type b. If the category also has a dot in gray for the function type a to b, plus some other properties, then the category is called a closed category. An example of a function type is into bool, as shown in the blue box. Now let's turn our attention to the category on the right. The category has a dot for the type f of a and a dot for the type f of b. Because it's also a closed category, it has a dot for the function type f of a to f of b in green. Between the two categories we have a functions that maps dots to dots and arrows to arrows. In particular, the functor maps the gray dot a to b on the left, f of a to b on the right. In blue, it may be the case that the blue dot and the green dot are not related at all if they happen to be one and the same dot. Then we say that the functor preserves the structure of the source category, and we call the functor a strict requiring the blue dot and the green dot to be the same dot is a rather strict condition. A somewhat more relaxed not require the two dots to be the same, we merely require that there's an arrow between the two dots. We call the functions a lex closed functions another name for lax closed functor is applicative functions, the arrow between the blue dot and the green dot app. That's a lot of theory. Let's see an example in code. Here we have a curried function for summing two integers. Currying means if a function takes multiple arguments, then the current function will take one argument at a time. In this example, we start with sum of 20. Then we f map the current function. What we end up with is an option of int to int, which is shown as the blue dot in the diagram. Because our option functions is an applicative function, we have the app arrow that takes us from the blue dot. The green dot is essentially a function that takes n and returns another option of int. So if we give that functions sum of 30, we will get back sum of 50 as the result. Next, let's turn our attention to a kind of functions called functors. If we have a type a and a type c, we can form the tuple type a comma c. If we have a type b and a type d, we can form a tuple type. And if there's an arrow from a to b and another arrow from c to d, we can take those two arrows and form a tuple of arrows that goes from a comma c. Now, if we have a functor that maps a comma c to f of a comma c and b comma d to f of b comma d, and the functor also maps the tuple of arrows to a lifted tuple of arrows, then we call such functions a functor. In python code, a functor class takes only one type argument, whereas a functor class takes two type arguments. Let's see an example of a functor. The functor in the example is the either class from the funk devt package. As its name suggests, either represents one of two possibilities. We represent those two possibilities with two classes left and right. In the co example, we take two functions, add one and negate. We by map them over an either object. Because the either object is a write object, the negate function will have no effect, and the add one function will be applied to the number five. Like functor, there's a kind of functions called profunctors that also takes two type arguments. The difference is a functor is covariant in both of its type arguments, whereas a profunctors is contravariant in the first type argument and covariant in the second type argument. The diagram here is very similar to the diagram we saw earlier. For functors, the only difference is that the arrow between type a and type b a. Perhaps very helpful way for visualizing how a profunctors works is through a diagram like the one at the bottom. We can visualize a profunctors p of a comma c as a box that takes an a and outputs a c. When we call dimap under profunctors. We get back a new profunctors and outputs a d. There are many different profunctors. One of them is called forget it always returns some value of type r, type of input value you give it. Star and costar are two other kinds of profunctors. The symbol f here represents a functions. So star f takes an a and returns an f of c. When you die map on it, you can turn it into a new star f that takes a b and returns an f of d. Here's a co example of the star profunctors. The star profunctors takes an integer. If we give it integer three, it will give us sum of one because ten mod by three is one. If we pass zero to the profunctors, it will give us nothing because ten mod by zero is not a valid operation. We can take the star profunctors and die map on it with the stir to int function on the way in is even function on the way out. What we end up with is a new profunctors that takes a string and returns an option of bool. The code example we have starts to look like some sort of data pipelines that can be chained and composed in flexible ways, and that's indeed a good application of profunctors. Congratulations for making it to this point. We've covered a lot in a fairly short amount of time. We've introduced the concept, then we covered covariant, contravariant applicative functions, as well as functors and profunctors. Hope you all enjoyed the talk. Thank you.", "words": [], "utterances": null, "confidence": 0.920084973056198, "audio_duration": 1166.0, "webhook_status_code": null, "webhook_auth": false, "summary": "- We will look at functions and how to use them in Python programs. The talk is for Python programmers and is designed for ease of understanding. The code examples are based on an open source Python package called Funklift.\n- A diagram like the one we are seeing here represents a category in category theory. To visualize the code, we can draw types as dots and functions as arrows. Let's move on to see how functions are related to categories.\n- Now that we've introduced the concepts of categories and functors, let's see some functions. It's common to have code that performs some kind of input or output. Such side effects make our code harder to reason about. Is there a solution that can turn a partial function into a total function while retaining composability?\n- Next, let's turn our attention to a kind of functions called functors. In python code, a functor class takes only one type argument, whereas a profunctors class takes two type arguments. A very helpful way for visualizing how aprofunctors works is through a diagram.\n- Congratulations for making it to this point. We've introduced the concept, then we covered covariant, contravariant applicative functions. Hope you all enjoyed the talk.", "auto_highlights_result": {"status": "success", "results": [{"count": 1, "rank": 0.11, "text": "Python functions", "timestamps": [{"start": 156932, "end": 158350}]}, {"count": 4, "rank": 0.11, "text": "other functions", "timestamps": [{"start": 392096, "end": 393238}, {"start": 414872, "end": 416078}, {"start": 460356, "end": 461434}, {"start": 586812, "end": 587918}]}, {"count": 1, "rank": 0.11, "text": "contravariant functions", "timestamps": [{"start": 630732, "end": 631874}]}, {"count": 3, "rank": 0.11, "text": "applicative functions", "timestamps": [{"start": 690940, "end": 692280}, {"start": 815896, "end": 817314}, {"start": 1158050, "end": 1159882}]}, {"count": 1, "rank": 0.11, "text": "covariant functions", "timestamps": [{"start": 597744, "end": 599446}]}, {"count": 1, "rank": 0.11, "text": "various functions", "timestamps": [{"start": 81314, "end": 82578}]}, {"count": 1, "rank": 0.11, "text": "contravarian functions", "timestamps": [{"start": 634812, "end": 636194}]}, {"count": 1, "rank": 0.11, "text": "contravariant applicative functions", "timestamps": [{"start": 1156378, "end": 1159882}]}, {"count": 3, "rank": 0.07, "text": "function type", "timestamps": [{"start": 716792, "end": 717618}, {"start": 727128, "end": 727890}, {"start": 748448, "end": 749500}]}, {"count": 1, "rank": 0.07, "text": "Python types", "timestamps": [{"start": 154532, "end": 155578}]}, {"count": 2, "rank": 0.07, "text": "get number function", "timestamps": [{"start": 305028, "end": 306158}, {"start": 321208, "end": 322420}]}, {"count": 2, "rank": 0.07, "text": "option functions", "timestamps": [{"start": 427516, "end": 428600}, {"start": 858980, "end": 859886}]}, {"count": 3, "rank": 0.07, "text": "new function", "timestamps": [{"start": 123288, "end": 124100}, {"start": 389088, "end": 389738}, {"start": 494208, "end": 495020}]}, {"count": 1, "rank": 0.07, "text": "lex closed functions", "timestamps": [{"start": 807252, "end": 808960}]}, {"count": 9, "rank": 0.06, "text": "categories", "timestamps": [{"start": 164824, "end": 165730}, {"start": 248566, "end": 249206}, {"start": 253312, "end": 253830}, {"start": 505508, "end": 506350}, {"start": 533698, "end": 534530}, {"start": 543200, "end": 544010}, {"start": 698768, "end": 699494}, {"start": 704452, "end": 705230}, {"start": 754468, "end": 755146}]}]}, "content_safety_labels": null, "iab_categories_result": null, "chapters": null, "sentiment_analysis_results": null, "entities": null}