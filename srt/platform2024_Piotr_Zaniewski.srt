1
00:00:02,240 --> 00:00:14,699
Hi everyone.

2
00:00:15,280 --> 00:00:16,540
My name is Piotr Zaniewski.

3
00:00:16,560 --> 00:00:19,800
I'm a head of engineering
enablement at Loft Labs.

4
00:00:20,240 --> 00:00:22,880
And today I will talk to
you about architecting.

5
00:00:23,160 --> 00:00:24,800
developer platforms.

6
00:00:25,150 --> 00:00:28,930
We'll focus specifically on
infrastructure developer platforms.

7
00:00:29,490 --> 00:00:34,120
We will talk about design principles
and tools used in building those.

8
00:00:34,780 --> 00:00:37,119
This will be heavily Kubernetes centric.

9
00:00:37,300 --> 00:00:39,280
And I also have a really cool demo.

10
00:00:40,300 --> 00:00:41,769
So a little bit about me.

11
00:00:41,800 --> 00:00:46,700
I specialize in all the cloud native
ecosystem, Kubernetes, Docker.

12
00:00:47,005 --> 00:00:48,355
Linux and so on.

13
00:00:48,785 --> 00:00:53,975
I typically spend way more free
time on tweaking my dot files and

14
00:00:53,975 --> 00:00:57,884
working with NeoVim than I should
have, but it's a lot of fun.

15
00:00:58,164 --> 00:00:59,955
As I mentioned, I work at Loft Labs.

16
00:01:00,795 --> 00:01:04,180
Go ahead and check them out if
you would like to Work with the

17
00:01:04,190 --> 00:01:05,800
cluster or other cool projects.

18
00:01:06,400 --> 00:01:11,690
the easiest way to contact me is to go
to my web page cloud rumble dot net or

19
00:01:11,690 --> 00:01:14,240
simply, send me an invite on LinkedIn.

20
00:01:16,420 --> 00:01:22,500
So before we jump into the building
of the platform architecting it, let's

21
00:01:22,500 --> 00:01:25,330
actually talk about what platform is.

22
00:01:25,690 --> 00:01:30,094
And the way I like to do this is
like contrasting it or putting it in

23
00:01:30,094 --> 00:01:32,845
the context of existing knowledge.

24
00:01:33,395 --> 00:01:37,975
So for me, there are
three kinds of platforms.

25
00:01:38,304 --> 00:01:40,865
One is a business platform.

26
00:01:40,905 --> 00:01:44,254
If you have used an application
like Uber or DoorDash, those are

27
00:01:44,254 --> 00:01:47,355
really platforms for consumers.

28
00:01:47,814 --> 00:01:53,384
They enable both consumers and vendors
to connect and sell their services.

29
00:01:53,394 --> 00:01:53,734
So that's it.

30
00:01:54,215 --> 00:01:58,205
That's a platform that is essentially a
product that is consumed by the end user.

31
00:01:58,995 --> 00:02:02,624
Another type of platform is
the domain specific platform.

32
00:02:02,625 --> 00:02:07,614
So those are typically services
that encapsulate cross cutting

33
00:02:07,614 --> 00:02:10,374
functionality for user facing services.

34
00:02:10,384 --> 00:02:15,355
A good example is if you have,
let's say, An application that has

35
00:02:15,355 --> 00:02:19,524
a map functionality would like to
put this map functionality like

36
00:02:19,555 --> 00:02:23,355
geofencing, translating addresses
and so on into a separate service.

37
00:02:23,635 --> 00:02:25,564
And then this would be your platform.

38
00:02:25,564 --> 00:02:26,714
The developers can use.

39
00:02:27,325 --> 00:02:29,935
And finally, we have a third
kinds of platforms, which are

40
00:02:29,935 --> 00:02:31,885
domain agnostic platforms.

41
00:02:32,464 --> 00:02:35,235
So this is the one that we
are going to talk about today.

42
00:02:35,545 --> 00:02:39,254
And the way to define those is
those are really building blocks

43
00:02:39,284 --> 00:02:41,384
that provide essential tools.

44
00:02:41,654 --> 00:02:45,874
They can be infrastructure focus, like the
one we'll talk about today, or they can

45
00:02:45,874 --> 00:02:50,185
be older, domain agnostic, something that
doesn't fall into your business domain,

46
00:02:51,185 --> 00:02:53,025
security related platforms and so on.

47
00:02:54,445 --> 00:02:54,804
All right.

48
00:02:54,814 --> 00:03:01,150
So with this definitions out of the way,
Let's talk about why this is useful.

49
00:03:01,160 --> 00:03:03,590
What's the point of building platforms?

50
00:03:03,930 --> 00:03:09,819
Imagine somebody has already
access to cloud like AWS or Azure.

51
00:03:09,899 --> 00:03:12,950
Why do they need something on top of that?

52
00:03:13,730 --> 00:03:17,770
The simple answer is that cloud
infrastructure or infrastructure

53
00:03:17,780 --> 00:03:20,470
in general is built for everyone.

54
00:03:20,945 --> 00:03:24,284
Is not built for your
developers specifically is

55
00:03:24,314 --> 00:03:25,964
built for everyone in mind.

56
00:03:25,994 --> 00:03:32,015
So every customer of Azure would need to
find themselves in the cloud services.

57
00:03:32,015 --> 00:03:35,834
So they might provide way too
much than your developers need.

58
00:03:36,174 --> 00:03:41,894
So thus, we need to simplifies the
resources management and isolate

59
00:03:41,914 --> 00:03:44,704
only those features that are useful.

60
00:03:45,139 --> 00:03:50,639
And important and actually empower our
developers rather than expose everything.

61
00:03:52,269 --> 00:03:56,399
this in turn increases development
efficiency because developers

62
00:03:56,449 --> 00:04:00,739
don't have to spend time learning
Kubernetes or learning all

63
00:04:00,739 --> 00:04:02,639
kinds of complex cloud services.

64
00:04:02,999 --> 00:04:08,809
They can just rely on the internal
platform to provide them what they need.

65
00:04:09,719 --> 00:04:13,799
platforms are also typically
built in scalability in mind.

66
00:04:14,194 --> 00:04:17,654
So they are from ground
up, scalable and reliable.

67
00:04:18,084 --> 00:04:23,184
And this is something that
clouds, of course, already have.

68
00:04:23,934 --> 00:04:27,354
But when you design your own platform,
that's probably the concern that you

69
00:04:27,354 --> 00:04:29,284
will think about at the very beginning.

70
00:04:31,284 --> 00:04:37,364
So what are the building blocks of a
typical cloud native developer platform?

71
00:04:37,919 --> 00:04:44,710
those are not exclusive all the building
blocks, but also the ones that you

72
00:04:44,710 --> 00:04:47,009
would see in most modern platform.

73
00:04:47,010 --> 00:04:51,189
So first of all, you have a some
form of self service portal.

74
00:04:51,499 --> 00:04:54,679
This portal can be a web
interface like we will see in

75
00:04:54,679 --> 00:04:56,710
the demo, but it can be a script.

76
00:04:56,940 --> 00:04:58,200
It can be a program.

77
00:04:58,219 --> 00:04:59,239
It can be a web interface.

78
00:04:59,599 --> 00:05:02,320
API directly exposed to an endpoint.

79
00:05:02,819 --> 00:05:07,780
At the end of the day, this is really
encapsulating APIs and making it

80
00:05:07,789 --> 00:05:13,899
simpler to access services and execute
repeatable tasks like provisioning a

81
00:05:13,899 --> 00:05:15,829
service, executing a test, and so on.

82
00:05:16,090 --> 00:05:18,609
creating a femoral testing
environment and so on.

83
00:05:19,719 --> 00:05:22,820
Finally, a second point is really the key.

84
00:05:22,840 --> 00:05:27,770
And I would like to emphasize this
in this talk, but the platforms are

85
00:05:27,770 --> 00:05:33,689
really an additional abstraction
layer over an existing APIs and

86
00:05:33,689 --> 00:05:38,400
they provide the programmatic APIs
for developers to interact with.

87
00:05:38,630 --> 00:05:42,270
Again, self service portal could be
one way of doing it, but you can also

88
00:05:42,270 --> 00:05:45,230
directly, access APIs if you need it.

89
00:05:47,104 --> 00:05:49,014
Automated workflows.

90
00:05:49,374 --> 00:05:52,514
So think of GitOps and similar principles.

91
00:05:53,534 --> 00:05:59,144
Platforms by design would use those
to automate the data flow within

92
00:05:59,144 --> 00:06:03,875
the pipeline of whatever tasks are
necessary from developers to execute.

93
00:06:04,124 --> 00:06:06,284
Developers can provision a service.

94
00:06:06,534 --> 00:06:10,444
And then the way it happens is
that it uses behind the scenes

95
00:06:10,744 --> 00:06:12,494
tools like Argo maybe, or GitOps.

96
00:06:12,899 --> 00:06:18,249
That automate the whole provisioning
process, monitoring and observability.

97
00:06:18,459 --> 00:06:21,139
this is not platform specific,
but it's very important.

98
00:06:21,804 --> 00:06:26,365
Specifically, in the age of
distributed systems, monitoring and

99
00:06:26,365 --> 00:06:32,034
observability, ability to roll back
and maybe perform canary deployments

100
00:06:32,054 --> 00:06:34,154
or similar things is really critical.

101
00:06:34,504 --> 00:06:40,034
So baking it in the platform is
something that we see, Every time

102
00:06:40,184 --> 00:06:44,775
and this is a very important building
block security and governance controls.

103
00:06:45,054 --> 00:06:47,275
I would also bundle here isolation.

104
00:06:47,644 --> 00:06:52,274
So if you have a platform that needs
to isolate workloads from a tenant to

105
00:06:52,274 --> 00:06:56,184
tenant, then you might use services
like the cluster internally to

106
00:06:56,184 --> 00:06:58,214
isolate and achieve multi tenancy.

107
00:06:58,514 --> 00:07:03,444
you want to use products, maybe a Falco
or others to harden your security and

108
00:07:03,444 --> 00:07:06,804
provide an end product that is secure.

109
00:07:07,224 --> 00:07:11,154
in a way that corresponds
to your compliance rules.

110
00:07:12,244 --> 00:07:15,464
This also means providing
audit trails or other things.

111
00:07:15,474 --> 00:07:19,444
So those are things that you don't
necessarily see as a developer, but

112
00:07:19,444 --> 00:07:21,354
those are important building blocks.

113
00:07:21,814 --> 00:07:25,414
And finally, platform is ever evolving.

114
00:07:25,484 --> 00:07:27,044
Platform is a product.

115
00:07:27,294 --> 00:07:30,314
It is going to continuously
evolve with your users.

116
00:07:30,624 --> 00:07:36,079
You need to have an organizational
structure around platform that

117
00:07:37,019 --> 00:07:41,049
controls its improvement, its
evolution and its features.

118
00:07:41,739 --> 00:07:45,839
So those are six building blocks
that are definitely important to

119
00:07:45,909 --> 00:07:47,669
see in any successful platform.

120
00:07:50,259 --> 00:07:51,459
Best practices.

121
00:07:51,824 --> 00:07:53,824
or successful platforms.

122
00:07:54,514 --> 00:07:57,694
As I mentioned earlier, API
driven is the key point.

123
00:07:57,874 --> 00:08:02,774
If you look at AWS, Azure, Google,
or any other successful cloud

124
00:08:02,814 --> 00:08:07,974
platform, the way they provide access
to their services is through API.

125
00:08:08,394 --> 00:08:10,694
You might, of course,
consume it through a UI.

126
00:08:11,639 --> 00:08:14,239
But on a large scale, there's an A.

127
00:08:14,239 --> 00:08:14,469
P.

128
00:08:14,469 --> 00:08:14,599
I.

129
00:08:14,629 --> 00:08:18,199
Responsible for driving your
decisions within the cloud.

130
00:08:18,209 --> 00:08:21,489
You can create a cloud
service, manipulated and do

131
00:08:21,499 --> 00:08:22,949
all kinds of things through A.

132
00:08:22,949 --> 00:08:23,159
P.

133
00:08:23,159 --> 00:08:23,369
I.

134
00:08:23,839 --> 00:08:26,869
And I think having an A.

135
00:08:26,869 --> 00:08:27,109
P.

136
00:08:27,109 --> 00:08:27,219
I.

137
00:08:27,219 --> 00:08:32,529
Driven mindset in building your
platforms is the key to success, and

138
00:08:32,529 --> 00:08:34,489
it sets you up on the path to success.

139
00:08:35,249 --> 00:08:36,609
Cloud native principles.

140
00:08:36,829 --> 00:08:41,189
This, of course, means designing
The platforms to be friendly

141
00:08:41,199 --> 00:08:42,789
to cloud native applications.

142
00:08:43,239 --> 00:08:47,779
So things like containerizing
orchestration, leveraging

143
00:08:47,800 --> 00:08:50,709
various cloud native projects
that falls into this bucket.

144
00:08:50,939 --> 00:08:55,649
And as I mentioned earlier, GitOps
workflow or some form of automated

145
00:08:55,659 --> 00:09:02,279
rollbacks now releases a B testing and,
following GitOps principles one way or

146
00:09:02,279 --> 00:09:06,889
the other is definitely something that
will ensure success of your platform.

147
00:09:09,014 --> 00:09:10,104
What is an API?

148
00:09:10,234 --> 00:09:11,964
Let's just make a quick refresher.

149
00:09:11,964 --> 00:09:15,864
So API stands for application
programming interface and is really

150
00:09:15,884 --> 00:09:21,034
a set of rules and protocols for
building and interacting with software.

151
00:09:21,044 --> 00:09:24,944
So I emphasize those two words
here, interface and interacting.

152
00:09:25,714 --> 00:09:29,654
this is how typically the logic is driven.

153
00:09:30,024 --> 00:09:35,334
And if you design your platform thinking,
how my developers would interface with the

154
00:09:35,964 --> 00:09:43,794
Set of services and API's are provide I
provide and how would they how would the

155
00:09:43,794 --> 00:09:45,934
API's interact with existing software?

156
00:09:45,944 --> 00:09:46,914
So you have kind of a.

157
00:09:47,434 --> 00:09:49,034
Pipeline idea.

158
00:09:49,194 --> 00:09:52,924
At one end, you have a developers
teams that use whatever interface

159
00:09:52,924 --> 00:09:53,984
is comfortable for them.

160
00:09:54,194 --> 00:09:58,834
And then at the other hand, you
have some outbound, processes that

161
00:09:58,854 --> 00:10:00,524
interact with various software.

162
00:10:00,784 --> 00:10:03,844
Let's say Argo or, deploy
something to Kubernetes.

163
00:10:04,264 --> 00:10:08,819
So if you have this mindset of having
an API pipeline, It really helps

164
00:10:08,819 --> 00:10:10,839
design a very healthy platform.

165
00:10:12,789 --> 00:10:14,099
So why it all matters?

166
00:10:14,349 --> 00:10:16,019
Why do we want to have a platform?

167
00:10:16,019 --> 00:10:20,009
And why do we want to
follow an API driven design?

168
00:10:20,379 --> 00:10:23,199
First of all, this
simplifies a lot of things.

169
00:10:23,549 --> 00:10:30,154
You can hide or create an
obstruction that exactly,

170
00:10:30,414 --> 00:10:32,264
corresponds to your developers needs.

171
00:10:32,904 --> 00:10:37,814
You can standardize on
existing standards, HTTP, GRPC.

172
00:10:37,894 --> 00:10:39,764
You can use something
that's already there.

173
00:10:39,764 --> 00:10:43,134
You don't need to invent a
new communication protocols.

174
00:10:44,304 --> 00:10:49,664
It helps automate all kinds of tasks on
various levels and layers of automation.

175
00:10:50,434 --> 00:10:55,354
And finally, APIs are very good
at scaling, and you can also

176
00:10:55,354 --> 00:10:56,734
secure them relatively easily.

177
00:10:59,159 --> 00:11:04,079
A brief reminder, I want to
repeat that platform is a product.

178
00:11:04,089 --> 00:11:09,439
So this simplistic diagram really
shows that the way you design a

179
00:11:09,439 --> 00:11:12,809
platform is not different than
designing any other product.

180
00:11:13,139 --> 00:11:15,299
So you want to understand
your customer's needs.

181
00:11:15,899 --> 00:11:22,609
You want to design something that fulfills
a need or two, test it, implement it,

182
00:11:22,719 --> 00:11:27,959
and deliver it to your customers, gather
feedback, improve on it, rinse and repeat.

183
00:11:28,719 --> 00:11:32,199
The platform should be
approached in the same way.

184
00:11:34,279 --> 00:11:36,779
So let's transition to a demo.

185
00:11:37,309 --> 00:11:43,789
During this demo, I want you to think of
the principles we just discussed and see

186
00:11:43,789 --> 00:11:47,389
how they translate to an actual platform.

187
00:11:47,749 --> 00:11:54,189
So we are going to see how platform
can empower developers, how it uses

188
00:11:54,189 --> 00:11:59,429
cloud native principles, is API driven,
and is baked by GitOps workflow.

189
00:12:01,019 --> 00:12:03,099
So let's transition to a demo.

190
00:12:03,899 --> 00:12:07,359
I am going to wear a
different, different hats.

191
00:12:08,079 --> 00:12:11,669
So now I am starting as
developer, what on the screen.

192
00:12:12,014 --> 00:12:15,494
is my developer world.

193
00:12:15,734 --> 00:12:16,964
This is my application.

194
00:12:17,414 --> 00:12:20,684
It's called, Azure Storage Blob Reader.

195
00:12:20,974 --> 00:12:25,064
And the task of this application is
to read the content of Azure Blob

196
00:12:25,064 --> 00:12:27,174
Storage and display it on the screen.

197
00:12:28,304 --> 00:12:32,684
I might not know too much about
Kubernetes or cloud services.

198
00:12:33,114 --> 00:12:37,474
My knowledge of containerization ends
with this very simple Dockerfile.

199
00:12:37,789 --> 00:12:38,619
Right here.

200
00:12:38,839 --> 00:12:41,739
Maybe somebody from platform
team helped me create it.

201
00:12:42,099 --> 00:12:43,079
But that's about it.

202
00:12:43,149 --> 00:12:44,529
So my application is a Node.

203
00:12:44,569 --> 00:12:45,269
js app.

204
00:12:45,569 --> 00:12:46,909
We don't need to go in detail.

205
00:12:47,179 --> 00:12:47,739
In code.

206
00:12:47,759 --> 00:12:52,979
I just wanted to show you that me as
developer, that's what I spend my time on.

207
00:12:53,019 --> 00:12:55,689
I am creating new features every day.

208
00:12:55,999 --> 00:12:56,969
I run tests.

209
00:12:57,359 --> 00:12:59,369
I make sure that everything works.

210
00:12:59,559 --> 00:13:03,679
And then I'm using cloud native
services and cloud services in

211
00:13:03,679 --> 00:13:05,559
conjunction with my application.

212
00:13:05,569 --> 00:13:10,809
But the most important part here, that's
where I would feel most comfortable.

213
00:13:10,809 --> 00:13:13,879
I don't need to deal with
all the cloud complexity.

214
00:13:15,554 --> 00:13:18,434
All right, so that's the developer.

215
00:13:18,524 --> 00:13:19,564
So the developer.

216
00:13:19,564 --> 00:13:25,804
Now I would like to deploy
this application and test it.

217
00:13:25,944 --> 00:13:27,954
I want to see if
everything works correctly.

218
00:13:28,504 --> 00:13:29,784
So how do I do it?

219
00:13:29,874 --> 00:13:35,849
Remember from our principles, we
are actually using service portal.

220
00:13:36,299 --> 00:13:39,349
So here for this demo, I am using port.

221
00:13:40,249 --> 00:13:42,909
Unfortunately, port still
doesn't have dark mode.

222
00:13:43,669 --> 00:13:44,679
Apologies for that.

223
00:13:45,119 --> 00:13:47,569
I tried to keep everything in
dark mode for presentation.

224
00:13:48,629 --> 00:13:54,409
Regardless, we can see, as developers,
that we have two actions in our homepage.

225
00:13:54,769 --> 00:13:59,089
One, it says cross plane storage
account reader, and we can create

226
00:13:59,169 --> 00:14:01,379
it, and another one for removing it.

227
00:14:01,989 --> 00:14:05,869
this is the extent of the
knowledge I need to have in order

228
00:14:05,869 --> 00:14:07,929
to create my infrastructure.

229
00:14:08,349 --> 00:14:09,099
let's kick it.

230
00:14:09,159 --> 00:14:14,739
When I hit create, it asks me some
variables, not many, just three

231
00:14:14,739 --> 00:14:15,979
that I might be interested in.

232
00:14:16,269 --> 00:14:18,689
One is connection string,
how I want to name it.

233
00:14:19,069 --> 00:14:22,419
Another one is my image, maybe I
want to iterate on the new versions

234
00:14:22,419 --> 00:14:23,739
of the image and I can bump it.

235
00:14:24,214 --> 00:14:25,154
An application port.

236
00:14:25,434 --> 00:14:30,754
I am happy to accept the defaults and
behind the scenes what's happening port

237
00:14:30,774 --> 00:14:38,024
in this case would actually kick off
a CICD pipeline, which in turn creates

238
00:14:38,024 --> 00:14:41,924
a PR that creates a necessary file.

239
00:14:42,564 --> 00:14:46,424
Okay, so this step is
really just for convenience.

240
00:14:46,654 --> 00:14:51,924
We could have manually create a
file, but we did it through port.

241
00:14:51,954 --> 00:14:56,994
as developers, we interact with
port or with backstage, and we

242
00:14:57,074 --> 00:14:59,064
actually create various things.

243
00:14:59,734 --> 00:15:00,884
let's see what's happening.

244
00:15:01,744 --> 00:15:05,484
If we refresh this, we should see
in a moment that there is a pull

245
00:15:05,484 --> 00:15:07,524
request being created by port.

246
00:15:08,594 --> 00:15:13,074
I don't know why it doesn't auto refresh
yet, maybe a good feature request.

247
00:15:14,794 --> 00:15:19,634
So now we have a pull request into
a repository called apps deployment.

248
00:15:19,784 --> 00:15:20,364
So let's see.

249
00:15:20,404 --> 00:15:21,874
Let's click on our pull request.

250
00:15:22,784 --> 00:15:25,114
All right, so we can
see some details again.

251
00:15:25,124 --> 00:15:26,924
This is from a developer point of view.

252
00:15:27,434 --> 00:15:29,964
I can interact with this
and read various things.

253
00:15:30,004 --> 00:15:32,824
I can see logs and runs and whatnot.

254
00:15:33,644 --> 00:15:35,314
That's not important at this point.

255
00:15:36,114 --> 00:15:39,104
But here I have a link to my repository.

256
00:15:39,105 --> 00:15:41,604
As you can see, we have apps deployment.

257
00:15:41,884 --> 00:15:46,424
This repository is specifically
designed to deploy my application.

258
00:15:47,014 --> 00:15:51,964
So now I am changing my hats to
becoming a platform team or maybe an

259
00:15:51,994 --> 00:15:56,814
admin, and I can see, oh, there's a
new PR on a deployment repository.

260
00:15:56,854 --> 00:16:00,144
By the way, this action is
obviously not mandatory.

261
00:16:00,144 --> 00:16:04,284
You can skip the PR review, but I
want to show you that it's possible.

262
00:16:04,754 --> 00:16:06,544
So what does this PR do?

263
00:16:07,314 --> 00:16:10,584
This PR creates a single YAML file.

264
00:16:11,764 --> 00:16:15,594
We talked about API and
this is the API in action.

265
00:16:15,824 --> 00:16:20,684
The API we all agreed on is
the Kubernetes style API.

266
00:16:21,399 --> 00:16:25,439
So both platform engineers and
developers agree that the way we're

267
00:16:25,479 --> 00:16:28,679
going to talk to each other and the
way we're going to make things happen

268
00:16:29,069 --> 00:16:31,949
is by standardizing on Kubernetes API.

269
00:16:32,109 --> 00:16:33,849
Why a Kubernetes API?

270
00:16:33,849 --> 00:16:35,039
There are various reasons.

271
00:16:35,409 --> 00:16:38,699
Kubernetes already exists
and has strong ecosystem.

272
00:16:39,159 --> 00:16:43,869
Kubernetes lends itself very well
to designing custom APIs using CRDs.

273
00:16:44,579 --> 00:16:45,749
And the list goes on.

274
00:16:46,499 --> 00:16:47,969
So how does this file look like?

275
00:16:47,989 --> 00:16:52,169
You can see this file has API version,
which if you're familiar with Kubernetes,

276
00:16:52,169 --> 00:16:56,689
you will know it has kind, which is
a custom resource definition kind.

277
00:16:56,689 --> 00:16:58,139
So this is an app claim.

278
00:16:58,469 --> 00:17:01,839
It has some names and
labels, and it also has spec.

279
00:17:02,179 --> 00:17:06,499
It follows the Kubernetes API
design, which is spec and status.

280
00:17:06,969 --> 00:17:10,469
And within the spec, Those are
the parameters you might remember.

281
00:17:10,649 --> 00:17:14,979
We specified in port when
we triggered the service.

282
00:17:15,269 --> 00:17:17,819
So we have a namespace
which we couldn't specify.

283
00:17:17,839 --> 00:17:19,969
This namespace is hard coded for our team.

284
00:17:20,449 --> 00:17:22,289
And then we have those parameters.

285
00:17:22,339 --> 00:17:28,519
So this simple YAML file is all
what it's necessary to create our

286
00:17:28,519 --> 00:17:34,319
application, create associated cloud
infrastructure, and other things.

287
00:17:35,459 --> 00:17:35,939
All right.

288
00:17:36,349 --> 00:17:39,349
So let me show you one
more thing before we move.

289
00:17:39,419 --> 00:17:41,799
I'm going to trigger Argo CD.

290
00:17:42,429 --> 00:17:45,389
So here I just have a
handy script to do this.

291
00:17:46,339 --> 00:17:52,819
So I just type just launch Argo and
you will see that inside of Argo CD,

292
00:17:53,309 --> 00:17:55,649
there is not much happening just yet.

293
00:17:56,149 --> 00:17:57,289
Let me log in real quick.

294
00:17:58,509 --> 00:18:04,479
We have a simple bootstrap application
and this Argo CD app Observes

295
00:18:04,479 --> 00:18:06,119
the apps deployment repository.

296
00:18:06,129 --> 00:18:10,249
The one we just seen a moment ago and
the one which we opened the PR to.

297
00:18:10,619 --> 00:18:13,319
So for now we have this empty app.

298
00:18:13,609 --> 00:18:14,669
Nothing happens.

299
00:18:15,439 --> 00:18:15,879
Okay.

300
00:18:16,859 --> 00:18:17,979
So far so good.

301
00:18:18,219 --> 00:18:19,839
Let's approve the PR.

302
00:18:20,299 --> 00:18:24,789
Let's pretend that I reviewed it and
we're going to merge it right now.

303
00:18:25,719 --> 00:18:31,599
When we merge the PR, we will see in
a moment that Argo will pick it up.

304
00:18:31,619 --> 00:18:36,629
I will help Argo by refreshing the screen
real quick and things start happening.

305
00:18:36,699 --> 00:18:39,619
We will see there's a lot of new
resources that are being created

306
00:18:40,009 --> 00:18:45,199
just from the small configuration
YAML that I submitted through API.

307
00:18:46,249 --> 00:18:50,769
So we have app claim, which is
exactly the YAML that we've seen

308
00:18:50,809 --> 00:18:54,979
earlier with some Kubernetes
annotations and additional code.

309
00:18:55,164 --> 00:18:59,324
Kubernetes added stuff, but you
can recognize the spec here and

310
00:18:59,334 --> 00:19:03,204
little our parameters and so
on and the kind API up claim.

311
00:19:03,224 --> 00:19:05,354
So we have applied it to the cluster.

312
00:19:06,104 --> 00:19:11,074
Okay, so how come we have
all those things right here?

313
00:19:11,814 --> 00:19:15,444
We'll talk about this later, but
let's go back to being a developer.

314
00:19:15,684 --> 00:19:20,549
Remember, one thing I did
is I went through my port, I

315
00:19:20,609 --> 00:19:26,809
created, clicked create, and how
do I know if my app is ready?

316
00:19:26,859 --> 00:19:29,749
Maybe I wanted to go and
grab a coffee, but my goal is

317
00:19:29,749 --> 00:19:31,319
really to test my application.

318
00:19:32,109 --> 00:19:36,099
Okay, what's a better way than
create a Slack notification?

319
00:19:36,149 --> 00:19:40,339
And as you can see here in my
channel, I have an app notify.

320
00:19:40,829 --> 00:19:44,899
That I might be subscribed to and I
have a notification and it tells me your

321
00:19:44,899 --> 00:19:46,929
application is deployed to localhost.

322
00:19:47,539 --> 00:19:49,049
Okay, let's give it a go.

323
00:19:49,729 --> 00:19:51,799
Indeed, we have Kubernetes demo.

324
00:19:52,059 --> 00:19:53,229
Let me make it a little bit bigger.

325
00:19:54,039 --> 00:19:55,569
So this is my application.

326
00:19:55,579 --> 00:19:58,539
That's my storage, Azure
Storage Account Reader.

327
00:19:59,439 --> 00:20:04,189
So now it's working, but there
are no documents found inside.

328
00:20:04,879 --> 00:20:08,419
And just to prove to you that we have all
the architecture, all the infrastructure

329
00:20:08,429 --> 00:20:13,294
here, If we go to Azure for a moment,
you can see that we have platform demo,

330
00:20:14,074 --> 00:20:18,674
which is the resource group that is being
deployed and sorry for all the jumping.

331
00:20:18,674 --> 00:20:23,594
But going back to, you can see that
one of the resources that we've

332
00:20:23,594 --> 00:20:25,924
deployed is actually resource group.

333
00:20:26,564 --> 00:20:29,874
So it is corresponding to
my resource group in Azure.

334
00:20:30,464 --> 00:20:34,754
We also have vcluster, slug and some
other stuff that's called object.

335
00:20:35,044 --> 00:20:40,484
It's quite some resources that we as
developers didn't need to specify.

336
00:20:42,574 --> 00:20:46,244
All right, so you can see here
we have platform demo storage.

337
00:20:46,264 --> 00:20:47,454
This is our storage bucket.

338
00:20:47,624 --> 00:20:53,204
If you're not familiar with Azure, storage
bucket is like an S3 bucket in AWS.

339
00:20:53,964 --> 00:20:56,674
And inside of it, we have a
simple container called sample

340
00:20:56,674 --> 00:20:58,684
blob, which is currently empty.

341
00:20:58,734 --> 00:20:59,544
There's nothing here.

342
00:21:00,044 --> 00:21:02,394
But our app works and we as developers.

343
00:21:03,739 --> 00:21:05,259
Just needed to click one button.

344
00:21:06,609 --> 00:21:07,039
Okay.

345
00:21:07,579 --> 00:21:12,079
So how do we test this
API all the way down?

346
00:21:12,319 --> 00:21:13,409
Let's go back now.

347
00:21:13,829 --> 00:21:15,159
By the way, you can see here.

348
00:21:15,549 --> 00:21:18,169
we have cross plane resources.

349
00:21:18,329 --> 00:21:21,979
Cross plane is the magic behind
creating all the cloud infrastructure.

350
00:21:22,704 --> 00:21:27,814
And then we also have here an NS,
which is a Kubernetes cluster viewer.

351
00:21:28,034 --> 00:21:30,554
We can see all the events and we
will look at this a little later.

352
00:21:31,284 --> 00:21:35,804
But for now, let's again switch
hearts and let's become a developer.

353
00:21:35,814 --> 00:21:38,624
So now I don't want to use get ups.

354
00:21:38,694 --> 00:21:40,924
I don't want to use,
something complicated.

355
00:21:40,964 --> 00:21:45,454
I just want to quickly create
something that I can test my app.

356
00:21:45,454 --> 00:21:52,389
So my app needs an actual file that is
inside of the blob and storage account.

357
00:21:52,849 --> 00:21:58,949
So what I can do is I can use
your catalog, apply that file.

358
00:21:59,099 --> 00:22:00,729
And I go to examples folder.

359
00:22:00,769 --> 00:22:03,799
And here I have a blob content dot Yama.

360
00:22:03,799 --> 00:22:08,509
We'll see its content in a second,
but remember, it's just an API.

361
00:22:08,909 --> 00:22:14,969
So I want to create a blob content inside
of my newly created infrastructure.

362
00:22:15,444 --> 00:22:16,644
And let's see what happens.

363
00:22:16,664 --> 00:22:17,864
So it says created.

364
00:22:18,214 --> 00:22:22,424
If we go back to our web page
and refresh now, you can see that

365
00:22:22,434 --> 00:22:26,624
our storage block leader actually
reads the content of a file.

366
00:22:26,964 --> 00:22:31,974
Hello, 24 platform engineering and just
to prove it to you that the file is here.

367
00:22:32,449 --> 00:22:36,489
You can see, indeed, there's an example
file present in my storage account.

368
00:22:36,969 --> 00:22:42,309
from the developer's point of view,
I was able to very easily spin

369
00:22:42,309 --> 00:22:46,979
up the infrastructure, create my
application, and do everything that

370
00:22:47,009 --> 00:22:48,659
is necessary to interact with it.

371
00:22:49,434 --> 00:22:52,904
Let's go back real quick to
the application and see what's

372
00:22:52,914 --> 00:22:55,194
happening inside of my application.

373
00:22:55,674 --> 00:22:59,694
But if we go to namespaces, you can see
that there's a DevOps team namespace.

374
00:22:59,724 --> 00:23:04,504
And inside of it, I have a
three replicas of my app full.

375
00:23:05,159 --> 00:23:08,359
And I have also a cluster
and some coordinates.

376
00:23:08,359 --> 00:23:09,669
So why do I have the cluster?

377
00:23:10,369 --> 00:23:16,299
Let's imagine that the developer we
tested this, but we also want to.

378
00:23:16,419 --> 00:23:19,209
Maybe we are a little bit more
Kubernetes savvy and we want

379
00:23:19,209 --> 00:23:21,479
to experiment with Kubernetes.

380
00:23:21,519 --> 00:23:27,179
But of course, we Our kubernetes is
populated by other tenants, and we don't

381
00:23:27,229 --> 00:23:30,579
really want to get in anybody's way.

382
00:23:30,699 --> 00:23:34,679
Maybe we want to create and try out new
English controller or something else.

383
00:23:35,029 --> 00:23:40,229
And here, if you go back quickly to our
slack notification, it tells us that

384
00:23:40,319 --> 00:23:42,161
we have here a dedicated V cluster.

385
00:23:42,161 --> 00:23:47,249
So if I have a big cluster CLI, Slack
tells me, Hey, this is your big cluster.

386
00:23:47,479 --> 00:23:51,529
You can connect to it and you can do
whatever you want in this big cluster.

387
00:23:51,539 --> 00:23:53,229
So let me open a new window.

388
00:23:53,669 --> 00:23:54,519
I can connect.

389
00:23:54,929 --> 00:23:56,749
And as you can see, we are connected.

390
00:23:57,349 --> 00:24:04,019
I can, for example, run maybe a debug
port or I can run, any other port

391
00:24:04,019 --> 00:24:05,599
or create any other part they want.

392
00:24:06,059 --> 00:24:09,419
And this would be interacting
with my future cluster.

393
00:24:09,419 --> 00:24:14,904
So we're not only given the developer
the Testing ephemeral environment.

394
00:24:14,944 --> 00:24:20,164
We also given them, their own fully
fledged virtual Kubernetes cluster

395
00:24:20,544 --> 00:24:22,554
where they can test whatever they want.

396
00:24:22,744 --> 00:24:25,304
So they don't have to open
tickets and keep following up.

397
00:24:25,714 --> 00:24:31,344
So we are escalating the ability for
developers, to use various testing tools.

398
00:24:32,954 --> 00:24:34,374
All right, let's, close it.

399
00:24:34,414 --> 00:24:36,154
Let's go back to our regular cluster.

400
00:24:36,944 --> 00:24:42,684
And we have seen the whole
flow so far as a developer.

401
00:24:43,254 --> 00:24:44,094
I am very happy.

402
00:24:44,094 --> 00:24:45,924
I didn't need to interact with any of it.

403
00:24:45,974 --> 00:24:47,624
I can see my application clearly.

404
00:24:48,089 --> 00:24:49,139
and I can test it.

405
00:24:49,659 --> 00:24:54,429
I can also additionally look at
the observation log, so you can

406
00:24:54,459 --> 00:24:57,859
open Grafana, which is a dedicated
Grafana dashboard just for me.

407
00:24:58,239 --> 00:25:00,759
And as you can see now, just
a little bit of data here.

408
00:25:01,169 --> 00:25:05,059
It's a dashboard that maybe my
platform team prepared, and it only

409
00:25:05,069 --> 00:25:07,979
observes my namespace and my vcluster.

410
00:25:07,999 --> 00:25:09,989
And then I can see what's happening.

411
00:25:10,099 --> 00:25:13,779
Maybe I want to tweak resource
quotas and so on in my application.

412
00:25:14,449 --> 00:25:17,879
So we can see we are giving
developers various tools, and they

413
00:25:17,879 --> 00:25:20,024
are All automatically deployed.

414
00:25:20,044 --> 00:25:22,954
We don't need to create
a ticket or anything.

415
00:25:23,204 --> 00:25:26,734
We just deployed all of
this that you've seen.

416
00:25:27,204 --> 00:25:33,604
We have deployed from this small yaml file
we've seen earlier, which is this guy.

417
00:25:34,234 --> 00:25:37,889
Okay, so now we're How did it all happen?

418
00:25:37,899 --> 00:25:39,179
Where is the secret sauce?

419
00:25:39,329 --> 00:25:42,849
Obviously, the complexity
cannot completely disappear.

420
00:25:43,239 --> 00:25:47,189
So there is definitely
complexity somewhere.

421
00:25:48,269 --> 00:25:51,269
So let's open a composition.

422
00:25:51,549 --> 00:25:56,409
So what I'm doing here, I'm using cross
plane and cross plane composition.

423
00:25:56,879 --> 00:26:00,739
As you can see, it's 285 lines of YAML.

424
00:26:01,139 --> 00:26:04,789
And as a platform team, this is my task.

425
00:26:04,869 --> 00:26:09,809
I am encapsulating and hiding
this composition, this, complexity

426
00:26:09,919 --> 00:26:11,309
inside of a composition.

427
00:26:11,599 --> 00:26:12,809
I'm hiding it away.

428
00:26:13,119 --> 00:26:14,159
From developers.

429
00:26:14,869 --> 00:26:17,089
So let's see what this
composition has inside.

430
00:26:17,099 --> 00:26:23,439
So if we go for name, you can see
it has an account service ingress

431
00:26:24,129 --> 00:26:27,039
and also deployment namespace.

432
00:26:27,039 --> 00:26:28,819
Those are all Kubernetes resources.

433
00:26:29,069 --> 00:26:30,149
It has the cluster.

434
00:26:30,584 --> 00:26:33,124
Resource group container
and so on and so forth.

435
00:26:33,534 --> 00:26:42,014
So all those things are deployed for
us by cross plane, and we can hide

436
00:26:42,184 --> 00:26:45,794
all the complexity using those tools.

437
00:26:47,084 --> 00:26:49,324
So you can go and read all the file.

438
00:26:49,354 --> 00:26:56,264
I will leave a link somewhere in the
presentation, so you can see it later

439
00:26:56,324 --> 00:26:58,104
and you check the repository for it.

440
00:26:58,974 --> 00:27:01,534
But that's how it works.

441
00:27:01,634 --> 00:27:02,404
But this is.

442
00:27:03,014 --> 00:27:05,064
Again, I'm putting a heart
of a platform engineer.

443
00:27:05,424 --> 00:27:07,864
That's how, that's how
we can make it happen.

444
00:27:07,864 --> 00:27:09,064
That's how we can make it possible.

445
00:27:11,144 --> 00:27:11,654
All right.

446
00:27:11,774 --> 00:27:14,164
So now I'm done as a developer.

447
00:27:14,274 --> 00:27:17,654
I don't want to deal with this anymore.

448
00:27:17,654 --> 00:27:18,474
I have tested.

449
00:27:18,544 --> 00:27:20,804
I successfully tested everything.

450
00:27:21,174 --> 00:27:23,244
And now I want to delete.

451
00:27:23,539 --> 00:27:27,659
All the infrastructure, including
all the Kubernetes resources.

452
00:27:28,179 --> 00:27:34,089
So as you might imagine, there is
another action that I can perform in my

453
00:27:34,389 --> 00:27:37,409
port here, namely delete the resource.

454
00:27:37,529 --> 00:27:40,099
So I am just selecting
the right repository.

455
00:27:40,919 --> 00:27:43,859
And I have to give here a file name.

456
00:27:43,859 --> 00:27:46,419
So I'm not deleting accidentally
somebody else's file.

457
00:27:47,049 --> 00:27:47,739
Click delete.

458
00:27:48,359 --> 00:27:51,849
And as you can imagine,
that opens another PR.

459
00:27:52,729 --> 00:27:56,359
We need to wait a second
for another PR to arrive.

460
00:27:56,599 --> 00:28:01,379
And once we approve this PR,
everything will be cleanly removed,

461
00:28:01,649 --> 00:28:05,799
including our cloud infrastructure,
as well as Kubernetes resources.

462
00:28:06,569 --> 00:28:10,799
So that is a really, lean flow
implementing the principles we were

463
00:28:10,819 --> 00:28:15,819
talking about and, showing you how
potentially you could implement

464
00:28:16,239 --> 00:28:20,619
an infrastructure platform, and
expose it to your developers.

465
00:28:20,949 --> 00:28:22,859
Again, let's pretend I've reviewed it.

466
00:28:23,489 --> 00:28:27,149
What it does, it just simply
removes the file, but there's

467
00:28:27,179 --> 00:28:28,429
nothing crazy happening here.

468
00:28:28,439 --> 00:28:33,129
It's a simple GitHub action,
confirm, and we are done.

469
00:28:33,779 --> 00:28:38,649
So with this done, if I go back
to Argo and refresh, you can see

470
00:28:38,649 --> 00:28:42,319
that everything could be gone or
is in the process of being deleted.

471
00:28:43,139 --> 00:28:46,859
And we can go also here, you can
see on the left hand side, all

472
00:28:46,859 --> 00:28:50,009
the cross plane resources are
also being currently removed.

473
00:28:50,239 --> 00:28:51,729
My application is being removed.

474
00:28:52,279 --> 00:28:54,779
Everything is cleanly done.

475
00:28:56,079 --> 00:28:56,539
All right.

476
00:28:56,599 --> 00:29:01,759
That was hopefully, showing you
well, how you can do this, but let's

477
00:29:01,759 --> 00:29:07,299
quickly go back to presentation and
let's, summarize what we've just seen.

478
00:29:09,939 --> 00:29:12,109
So what tools have we used?

479
00:29:12,199 --> 00:29:18,650
We have used Kubernetes and we used
it not as a Container orchestration,

480
00:29:18,680 --> 00:29:20,610
but we use this as a control plane.

481
00:29:20,950 --> 00:29:23,070
We've leveraged Kubernetes A.

482
00:29:23,070 --> 00:29:23,330
P.

483
00:29:23,330 --> 00:29:23,650
I.

484
00:29:23,790 --> 00:29:30,030
Friends and foremost, and we used it
to reconcile everything and anything.

485
00:29:30,880 --> 00:29:35,350
We used also the cluster to give
our developers, virtual Kubernetes

486
00:29:35,350 --> 00:29:37,880
cluster if they need a little bit more.

487
00:29:38,570 --> 00:29:40,170
to play around with or test.

488
00:29:40,590 --> 00:29:46,120
We have used cross plane to deploy
everything and reconcile our deployments

489
00:29:46,120 --> 00:29:49,820
to keep it synchronized with the
desired state with the actual state.

490
00:29:50,350 --> 00:29:52,470
And we have used various
cross plane providers.

491
00:29:53,140 --> 00:29:57,010
Providers are like telephone
providers that you can target

492
00:29:57,080 --> 00:29:58,180
various infrastructure.

493
00:29:58,180 --> 00:29:59,670
We have used Azure provider.

494
00:30:00,085 --> 00:30:03,365
We have used cross plane
functions, Kubernetes, Helm, HTTP.

495
00:30:04,005 --> 00:30:07,095
So that's like Lego building
blocks, which you can target.

496
00:30:07,705 --> 00:30:11,715
We have used Port, which is a
developer portal similar to Backstage,

497
00:30:12,035 --> 00:30:16,675
and we let our developers interact
with Port rather than, directly

498
00:30:16,675 --> 00:30:18,045
interacting with the YAML file.

499
00:30:19,240 --> 00:30:22,940
I want to emphasize it is possible
to directly interact with YAML

500
00:30:23,100 --> 00:30:27,230
or even to directly interact with
Kubernetes API, depending on the need

501
00:30:27,490 --> 00:30:31,030
and the level of, our developers,
knowledge about Kubernetes.

502
00:30:31,650 --> 00:30:38,170
We've used GitHub and specifically used
it as an interface driving the exchange

503
00:30:38,210 --> 00:30:40,110
between the platform team and developers.

504
00:30:40,610 --> 00:30:42,720
And we used the.

505
00:30:43,200 --> 00:30:44,430
Messaging system.

506
00:30:45,040 --> 00:30:47,710
as prs, we use PRS as messaging systems.

507
00:30:47,710 --> 00:30:53,250
Our prs are actionable messages that
developers send to platform team.

508
00:30:53,610 --> 00:30:56,350
They review it and then, magic happens.

509
00:30:57,170 --> 00:30:59,120
For GitHubs, we used Argo cd.

510
00:30:59,120 --> 00:31:04,100
We could have used flax or other
mechanism, but Argo CD because of its ui,

511
00:31:04,830 --> 00:31:07,130
was nice to show it and believe it or not.

512
00:31:07,650 --> 00:31:12,740
All this that I showed you is running
on my local kind Kubernetes cluster,

513
00:31:12,740 --> 00:31:14,080
which is Kubernetes in Docker.

514
00:31:14,750 --> 00:31:19,060
So I was able to encapsulate all
those things inside of my Kubernetes.

515
00:31:19,100 --> 00:31:20,744
You can, of course, run it in Docker.

516
00:31:21,015 --> 00:31:26,925
in a cloud somewhere like in AKS, EKS or
GCP, and you can do this equally well.

517
00:31:27,355 --> 00:31:27,705
All right.

518
00:31:27,705 --> 00:31:28,715
So that was tooling.

519
00:31:29,735 --> 00:31:34,705
Let's look at a helpful diagram,
that will again, guide us through

520
00:31:34,705 --> 00:31:36,085
the journey that we just saw.

521
00:31:36,145 --> 00:31:40,085
And I would like to pinpoint
certain aspects here.

522
00:31:40,095 --> 00:31:42,575
So we started by being a developer.

523
00:31:42,995 --> 00:31:52,675
We interacted with the portal and then
we accessed the UI and we created a

524
00:31:52,725 --> 00:31:57,475
triggered, creating of our ephemeral
testing environment, including our

525
00:31:57,475 --> 00:32:04,314
app, this in turn triggered action
to git and our git repository.

526
00:32:04,835 --> 00:32:11,285
Received, an action or triggered an
action as a third step, this PR, was

527
00:32:11,285 --> 00:32:15,165
reviewed by platform engineers approving.

528
00:32:15,985 --> 00:32:21,895
We have committed those changes to
a repository where Argo reconciled

529
00:32:21,895 --> 00:32:26,832
it, applied it to a cluster,
and from there, Crossplane Bye.

530
00:32:26,832 --> 00:32:26,859
Bye.

531
00:32:27,370 --> 00:32:34,830
Talk to Kubernetes API and used CRDs and
various other mechanisms to reconcile all

532
00:32:34,830 --> 00:32:36,820
the infrastructure and the application.

533
00:32:37,310 --> 00:32:42,380
This in turn resulted in provisioning
vCluster, provisioning our application,

534
00:32:42,390 --> 00:32:48,080
which is various Kubernetes resources,
and also provisioning cloud services.

535
00:32:49,080 --> 00:32:54,870
So that's just a quick overview
of what we have done in the demo.

536
00:32:58,390 --> 00:33:01,170
in conclusion, what we were able to do.

537
00:33:01,645 --> 00:33:05,815
We reduced friction for
developers to almost zero.

538
00:33:06,505 --> 00:33:11,135
The only touch point that developers had
to have with the infrastructure was a

539
00:33:11,375 --> 00:33:17,195
PR approval from somebody from platform
team, but we could very easily eliminate

540
00:33:17,195 --> 00:33:22,695
this PR approval and then we would have
actual zero friction in the whole process.

541
00:33:23,845 --> 00:33:28,625
We eliminated waiting times related to
Tickets because we anticipated that our

542
00:33:28,625 --> 00:33:33,115
developers might need a little bit more
experiment with and we have added the

543
00:33:33,125 --> 00:33:39,455
cluster that gives them essentially admin
level privileges, virtual cluster, and

544
00:33:39,455 --> 00:33:40,965
they don't need to ask us constantly.

545
00:33:40,965 --> 00:33:42,355
Hey, can you create this for me?

546
00:33:42,355 --> 00:33:43,335
Can you create that for me?

547
00:33:43,635 --> 00:33:48,075
So we have both cater to the immediate
needs of testing and application.

548
00:33:48,075 --> 00:33:53,475
And we also gave them A little playground
that is encapsulated just for the team

549
00:33:53,515 --> 00:33:55,145
or just for the person that does the PR.

550
00:33:56,055 --> 00:34:01,395
We have used the Git PR as a unified
interface between platform and

551
00:34:01,395 --> 00:34:06,835
developer teams, and we encapsulated
the API calls to the Kubernetes.

552
00:34:07,115 --> 00:34:09,825
Those API calls are in the form of YAML.

553
00:34:10,115 --> 00:34:14,435
This is just configuration, but at the
end, those are instructions for the

554
00:34:14,435 --> 00:34:20,085
Kubernetes API and other projects like
Crossplane to do something with it.

555
00:34:21,095 --> 00:34:26,655
And the magic is in the collaboration
part where platform team prepared

556
00:34:27,275 --> 00:34:30,755
something up front, which is a cross
plane composition and all the setup.

557
00:34:31,105 --> 00:34:36,515
And then developers were able to
collaborate by executing various APIs.

558
00:34:38,415 --> 00:34:43,235
We have also followed zero trust security
principles because our developers

559
00:34:43,265 --> 00:34:45,475
didn't need any access to Azure.

560
00:34:46,040 --> 00:34:50,760
They can, but we've encapsulated it
to a point where the developers simply

561
00:34:50,780 --> 00:34:55,850
interacted only with API through
Kubernetes without even knowing

562
00:34:55,870 --> 00:34:57,320
that there's Kubernetes behind it.

563
00:34:57,910 --> 00:35:02,720
They just apply files and work
with files and configuration and

564
00:35:03,160 --> 00:35:05,430
then achieve certain results.

565
00:35:06,100 --> 00:35:07,999
And we didn't even mention AI once.

566
00:35:10,840 --> 00:35:14,770
So the key take away from this
presentation is really to think

567
00:35:14,830 --> 00:35:18,600
of designing developer platforms,
whether they are infrastructure

568
00:35:18,600 --> 00:35:20,160
or other types of platforms.

569
00:35:20,740 --> 00:35:22,920
Think about it like designing an API.

570
00:35:23,580 --> 00:35:25,660
API is really a data pipeline.

571
00:35:25,700 --> 00:35:26,790
It has input.

572
00:35:26,800 --> 00:35:27,840
It has outputs.

573
00:35:28,250 --> 00:35:29,130
It has various.

574
00:35:29,505 --> 00:35:31,235
mutations that happen along the way.

575
00:35:31,675 --> 00:35:37,085
And if you think about how your API should
look like and how you design and craft the

576
00:35:37,085 --> 00:35:42,045
contract between developers and platform
team, that's a recipe for success.

577
00:35:44,695 --> 00:35:45,945
Thank you for your attention.

578
00:35:45,945 --> 00:35:46,985
Thank you for your time.

579
00:35:47,535 --> 00:35:49,625
please enjoy the rest of the conference.

580
00:35:49,655 --> 00:35:51,215
if you would like to reach out to me.

581
00:35:51,545 --> 00:35:54,015
You can visit my web page, CloudRumble.

582
00:35:54,045 --> 00:35:57,265
net, or simply connect me,
connect with me on LinkedIn.

583
00:35:57,685 --> 00:36:03,075
And I would be really interested to hear
your thoughts about Kubernetes, platforms,

584
00:36:03,515 --> 00:36:04,995
and all the tools that we've used.

