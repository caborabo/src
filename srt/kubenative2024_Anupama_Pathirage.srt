1
00:00:14,150 --> 00:00:15,000
Hello, everyone.

2
00:00:15,140 --> 00:00:19,480
Welcome to Conf42 and welcome to
my session on ballerinas on lake,

3
00:00:19,930 --> 00:00:23,480
which is, we are talking about
code to cloud mastering communities

4
00:00:23,550 --> 00:00:25,090
deployments with ballerina.

5
00:00:25,480 --> 00:00:30,659
And I'm going to discuss about the code
to cloud journey, the challenges, as

6
00:00:30,659 --> 00:00:35,239
well as how application development
and also the deployments can be

7
00:00:35,250 --> 00:00:36,980
simplified by using ballerina.

8
00:00:38,330 --> 00:00:40,330
First of all, let me introduce myself.

9
00:00:40,330 --> 00:00:44,459
I'm Anupama Pathiragi, currently working
as director and head of engineering.

10
00:00:44,530 --> 00:00:50,910
at WSO2 and I'm leading the development
efforts of Ballerina as well as

11
00:00:50,910 --> 00:00:52,300
the developer relations effort.

12
00:00:53,070 --> 00:00:55,720
So without taking much time,
Let's start the discussion.

13
00:00:56,210 --> 00:00:59,010
So I thought of starting
the conversation with this.

14
00:00:59,660 --> 00:01:02,030
So this is an AI generated image.

15
00:01:02,130 --> 00:01:04,259
You can see there's an
application developer.

16
00:01:04,650 --> 00:01:07,960
And also there are so many
complexities around him when

17
00:01:07,960 --> 00:01:09,219
it comes to the deployment.

18
00:01:09,250 --> 00:01:12,990
There are cloud components and
there are many different endpoints.

19
00:01:13,340 --> 00:01:17,259
applications, services, which are
connected together and also the

20
00:01:17,259 --> 00:01:21,259
deployment aspects and the things
were deployed in different places.

21
00:01:21,940 --> 00:01:25,359
Then you might wonder why the
application developer has to think

22
00:01:25,360 --> 00:01:29,349
about all these things, whether the
application development and deployments

23
00:01:29,350 --> 00:01:34,079
are two separate things, but actually
in the reality, it's not the case.

24
00:01:34,699 --> 00:01:39,300
So the journey from code to cloud, we
have to think about how applications

25
00:01:39,300 --> 00:01:43,365
are developing When we think about
the cloud as well, because with the

26
00:01:43,415 --> 00:01:47,925
rise of the cloud native applications,
things have evolved and transformed

27
00:01:48,325 --> 00:01:52,654
actually how we build applications as
well as how we deploy the applications.

28
00:01:52,945 --> 00:01:56,094
In the modern application
developments, we need integrations.

29
00:01:56,094 --> 00:01:59,955
It's an unavoidable part because we
have to talk to multiple different

30
00:02:00,105 --> 00:02:04,035
services, endpoints, and having
seamless integration is key thing.

31
00:02:04,485 --> 00:02:08,335
And also scalability aspects and
reliable deployment strategies.

32
00:02:08,800 --> 00:02:12,240
All these are key components
in application development

33
00:02:12,270 --> 00:02:12,930
in the modern world.

34
00:02:13,780 --> 00:02:18,329
So Kubernetes has emerged as a standard
for gestating the complex cloud

35
00:02:18,340 --> 00:02:23,540
deployments and also it's simplifying most
of the deployments and almost everything.

36
00:02:24,149 --> 00:02:28,620
So this process like planning the
application, Implement it, build it,

37
00:02:28,670 --> 00:02:33,890
test, release, deploy, operate, and
finally monitor, all these are connected

38
00:02:33,959 --> 00:02:36,240
and there should be seamless process.

39
00:02:36,560 --> 00:02:40,529
That's why we say cloud code to
cloud is very important when it comes

40
00:02:40,530 --> 00:02:42,179
to modern application development.

41
00:02:42,820 --> 00:02:47,829
And also, although cloud deployments are
comparatively easy, there are so many

42
00:02:47,829 --> 00:02:49,700
challenges in the cloud integrations.

43
00:02:50,704 --> 00:02:52,465
The first thing is multiple services.

44
00:02:52,895 --> 00:02:57,765
Cloud integration means we have to
involve or talk to different services

45
00:02:57,805 --> 00:03:01,625
and interact with different APIs and
those will have to work together.

46
00:03:02,335 --> 00:03:06,505
And this inherent, complexity
imposed by these services and data

47
00:03:06,505 --> 00:03:08,435
formats protocols we have to handle.

48
00:03:09,185 --> 00:03:12,625
And also the dynamic environments
when it comes to the deployments

49
00:03:12,645 --> 00:03:17,065
because cloud environments are highly
dynamic with containers, autoscaling,

50
00:03:17,115 --> 00:03:20,765
and also microservices, how the
security is handled and so on.

51
00:03:21,505 --> 00:03:23,555
And also the configuration overhead.

52
00:03:24,095 --> 00:03:28,485
Managing deployment configuration is a
key thing in the cloud deployments and

53
00:03:28,485 --> 00:03:31,185
how we autoscale and how we monitor.

54
00:03:31,595 --> 00:03:35,285
Those things can be time
consuming if we have to manage

55
00:03:35,315 --> 00:03:37,185
all these configurations manually.

56
00:03:37,675 --> 00:03:42,625
And also the security compliance, ensuring
the data is flowing securely and also

57
00:03:42,655 --> 00:03:44,825
the compliance requirements are achieved.

58
00:03:45,335 --> 00:03:49,475
Likewise, there are so many things
when we, when we, when we think about

59
00:03:49,475 --> 00:03:51,735
the cloud or integration applications.

60
00:03:52,265 --> 00:03:57,015
So that means application
development is not isolated.

61
00:03:57,095 --> 00:04:00,175
We have to think about all
these challenges as well as the

62
00:04:00,175 --> 00:04:04,295
deployment aspects when designing
and implementing the applications.

63
00:04:04,460 --> 00:04:09,920
So in today's session, I'm going to
discuss how ballerina can help you, with

64
00:04:10,020 --> 00:04:14,650
this thing, not just the development
and also the deployment aspects.

65
00:04:15,560 --> 00:04:17,270
So first of all, what is ballerina?

66
00:04:17,740 --> 00:04:21,880
In high level, it's technology for
simplifying cloud integrations.

67
00:04:21,955 --> 00:04:24,615
Let's look at a little bit more details.

68
00:04:25,175 --> 00:04:28,055
So it's an open source cloud
native technology, which is

69
00:04:28,055 --> 00:04:29,435
optimized for integration.

70
00:04:29,515 --> 00:04:33,635
In a way we can think of it as a
programming language as well, but more

71
00:04:33,635 --> 00:04:35,705
or less it's a platform for integration.

72
00:04:36,205 --> 00:04:37,995
It's developed by WSO2.

73
00:04:37,995 --> 00:04:41,175
It's an open source project,
completely open source project.

74
00:04:41,195 --> 00:04:42,985
And the first version is released.

75
00:04:43,540 --> 00:04:47,200
in February 2022, which we called
Paladin Aswan like version.

76
00:04:47,770 --> 00:04:50,830
if you think about the key
thing, key aspects, it has rich

77
00:04:50,890 --> 00:04:54,510
ecosystem of different services,
data formats, and connectors.

78
00:04:55,020 --> 00:04:59,060
And also it has both textual
representation as well as graphical

79
00:04:59,060 --> 00:05:03,970
requisite representation as sequence
diagrams and flowcharts, which is

80
00:05:04,010 --> 00:05:07,660
very much helpful when it comes to
maintainability of the application.

81
00:05:08,140 --> 00:05:13,410
And also it has many safe to primitives,
which helps the developers, for example,

82
00:05:13,960 --> 00:05:15,610
efficient concurrency mechanisms.

83
00:05:15,630 --> 00:05:20,950
The compiler itself can detect some data
races during the compile time because it

84
00:05:20,950 --> 00:05:26,530
is very difficult to handle these data
races and, concurrency related problems

85
00:05:26,550 --> 00:05:30,470
in the runtime because integration
applications are inherently concurrent.

86
00:05:30,820 --> 00:05:34,370
And if we had to deal with concurrency
issues, it's not that easy.

87
00:05:34,380 --> 00:05:34,440
Thank you.

88
00:05:35,260 --> 00:05:37,280
So this is a brief
overview about Valarina.

89
00:05:37,670 --> 00:05:39,640
So let's look a little bit deeper.

90
00:05:39,690 --> 00:05:42,050
So it's all about cloud
native integrations.

91
00:05:42,110 --> 00:05:46,640
And I said it's a programming language,
but it's not just a programming language.

92
00:05:46,760 --> 00:05:48,340
It's more than a programming language.

93
00:05:48,340 --> 00:05:49,280
It's a full framework.

94
00:05:49,810 --> 00:05:54,830
So if you compare it with other
languages, many like C Java, Go, etc.,

95
00:05:55,650 --> 00:05:59,430
Valarina syntax can fall into
the same family of syntaxes.

96
00:05:59,480 --> 00:06:02,450
We can think it's a programming
language, but which is highly

97
00:06:02,450 --> 00:06:05,770
optimized for, integration needs.

98
00:06:06,090 --> 00:06:09,970
We can do any general purpose
application development using Valerina,

99
00:06:10,410 --> 00:06:13,990
but when it comes to integration
application development, there are

100
00:06:13,990 --> 00:06:18,270
so many abstractions and other,
tooling capabilities and so on to

101
00:06:18,270 --> 00:06:20,020
make the developer's lives easy.

102
00:06:20,760 --> 00:06:24,140
So the abstractions are the
important or playing key thing here.

103
00:06:24,270 --> 00:06:28,290
right level abstractions, having the
right level of abstractions is very

104
00:06:28,290 --> 00:06:34,870
important because It will improve
the developer productivity and

105
00:06:34,890 --> 00:06:38,590
understandability of the code as well
as the maintainability of the code.

106
00:06:39,030 --> 00:06:42,210
And also this is not a research
product and it's heavily used

107
00:06:42,210 --> 00:06:44,750
in production environments and
it's an open source product.

108
00:06:44,800 --> 00:06:47,590
Anyone can freely use it as well.

109
00:06:47,590 --> 00:06:50,640
There's a huge open source
community around us and we

110
00:06:50,640 --> 00:06:53,790
are working collaboratively
with open source community.

111
00:06:55,850 --> 00:06:59,180
So I say Balena provide the right
abstractions for integration.

112
00:06:59,595 --> 00:07:02,015
There are three levels,
or three types, actually.

113
00:07:02,725 --> 00:07:04,045
First thing is data.

114
00:07:04,275 --> 00:07:07,655
When it comes to integration
applications, data is a key thing,

115
00:07:07,655 --> 00:07:09,925
because we have to represent data.

116
00:07:10,045 --> 00:07:14,465
We have to think about different
data types, formats, and how we

117
00:07:14,465 --> 00:07:18,435
manipulate data, and how we communicate
data from one service to another.

118
00:07:18,895 --> 00:07:20,625
Likewise, data plays a key role.

119
00:07:20,855 --> 00:07:24,375
So Valerina provides so many
abstractions, data type support,

120
00:07:24,825 --> 00:07:26,425
and type checking, serials.

121
00:07:27,140 --> 00:07:32,940
semantics to make it easy and also the
network representing the network, how

122
00:07:32,960 --> 00:07:37,780
we define client, how we define service
beyond different network protocols.

123
00:07:38,170 --> 00:07:41,840
All these things should be
very easy without going into

124
00:07:41,840 --> 00:07:44,400
the very low level details.

125
00:07:44,400 --> 00:07:48,760
The application developer should be able
to get their network requirements done

126
00:07:48,780 --> 00:07:51,210
very easily and also the concurrency.

127
00:07:51,250 --> 00:07:53,990
As I mentioned before,
the concurrency safety.

128
00:07:54,750 --> 00:07:57,740
During the application
development itself can be.

129
00:07:58,530 --> 00:08:01,980
Very helpful, when it comes
to integration applications.

130
00:08:02,670 --> 00:08:06,530
So there are three stages mainly
in the application life cycle.

131
00:08:06,910 --> 00:08:09,790
First thing is the deployment
and the maintenance.

132
00:08:10,150 --> 00:08:12,870
And after that, we had to
think about deployment aspects.

133
00:08:13,140 --> 00:08:15,500
And finally, the monitoring
or the runtime aspects.

134
00:08:15,780 --> 00:08:18,430
So let's quickly go
through all these things.

135
00:08:18,750 --> 00:08:21,790
And I will showcase
these in my demo as well.

136
00:08:22,370 --> 00:08:23,170
But before that.

137
00:08:23,385 --> 00:08:26,655
Let's go through some high level
overview of all these aspects.

138
00:08:26,805 --> 00:08:30,275
So if we look at the development
and maintenance, what we are

139
00:08:30,675 --> 00:08:35,485
talking about is a full life cycle
of the application development.

140
00:08:35,985 --> 00:08:42,900
Since ballerina is A language,
we can use VS Code as the IDE

141
00:08:43,260 --> 00:08:44,910
and with the familiar tool set.

142
00:08:45,180 --> 00:08:50,010
So you can commit the source code
to a preferred source control system

143
00:08:50,010 --> 00:08:55,490
like GitHub, GitLab, whatever,
and also can use existing CI, CD

144
00:08:55,490 --> 00:09:00,230
processors and deployment can be done
into any environment that you want.

145
00:09:00,720 --> 00:09:05,300
And when it comes to the runtime aspects
of monitoring, logging, et cetera, you can

146
00:09:05,300 --> 00:09:07,610
connect your existing tools and systems.

147
00:09:07,890 --> 00:09:09,710
to the running ballerina applications.

148
00:09:10,970 --> 00:09:15,090
So if you think about how you start
with ballerina first, you have

149
00:09:15,100 --> 00:09:16,760
to create your ballerina package.

150
00:09:17,190 --> 00:09:19,670
So there's a CLI
associated with ballerina.

151
00:09:19,720 --> 00:09:20,910
Once you install ballerina.

152
00:09:21,500 --> 00:09:22,380
You can go to ballerina.

153
00:09:22,380 --> 00:09:28,960
io website and get the download install
installers of the ballerina distribution.

154
00:09:29,250 --> 00:09:32,330
And once you install it, you
can get the ballerina CLI.

155
00:09:32,720 --> 00:09:36,240
With that, you can create new
packages using ballenew command.

156
00:09:36,730 --> 00:09:38,140
So these are like the big details.

157
00:09:38,140 --> 00:09:42,210
I'm skipping those things as you
can try those things by yourself.

158
00:09:42,900 --> 00:09:47,500
And once you do that initial ballenew
command, you will get a ballerina package.

159
00:09:47,825 --> 00:09:51,775
Which contains the minimum set
of files needed to identify

160
00:09:51,785 --> 00:09:53,275
it as a package and run it.

161
00:09:53,325 --> 00:09:57,275
So it contains bel files, which
are the source code files.

162
00:09:57,645 --> 00:10:00,245
So like any other programming
language, these are the files

163
00:10:00,245 --> 00:10:01,775
where you write your application.

164
00:10:02,325 --> 00:10:04,545
And there are some other
meta files like ballerina.

165
00:10:04,545 --> 00:10:05,365
toml file.

166
00:10:05,915 --> 00:10:09,195
Which identifies a given
directory as a ballerina package.

167
00:10:09,215 --> 00:10:13,325
It contains the metadata about the
package, like the package name,

168
00:10:13,385 --> 00:10:15,675
version, and many other information.

169
00:10:16,395 --> 00:10:18,495
So this is like a
structure of the package.

170
00:10:18,585 --> 00:10:22,515
By looking at this, you should get the
sense that, okay, this is like any other

171
00:10:22,515 --> 00:10:27,275
programming language and how you start a
project and how you start your application

172
00:10:27,275 --> 00:10:29,215
development journey is very simple.

173
00:10:30,075 --> 00:10:34,145
And then the next thing is how we
design our application, especially

174
00:10:34,145 --> 00:10:35,585
the integration applications.

175
00:10:36,075 --> 00:10:40,355
In Ballerina, we have integration
designers for the various protocols.

176
00:10:40,365 --> 00:10:45,095
For example, REST based applications,
you can start by defining services

177
00:10:45,155 --> 00:10:49,475
and then defining resources
and finally add the data types.

178
00:10:49,610 --> 00:10:51,320
Return types and so on.

179
00:10:51,800 --> 00:10:54,740
So here you can see the graphical
view of the service designer.

180
00:10:54,740 --> 00:10:58,940
You can use both code view or either
code view or the graphical view.

181
00:10:59,300 --> 00:11:03,790
Both will do the same thing and
as per the convenience, or what

182
00:11:03,790 --> 00:11:08,630
preference, you can select, either
code view or the designer view.

183
00:11:09,140 --> 00:11:14,630
So that is an easy mechanism for
the initial skeleton development.

184
00:11:15,035 --> 00:11:18,655
And same with GraphQL, you can
design and visualize your GraphQL

185
00:11:18,655 --> 00:11:20,650
applications using GraphQL designer.

186
00:11:20,650 --> 00:11:25,989
Likewise, these service designers
are very much helpful to start with

187
00:11:25,989 --> 00:11:27,845
your application design process.

188
00:11:28,375 --> 00:11:32,315
And after designing your application,
the initial stages and the skeleton,

189
00:11:32,695 --> 00:11:35,803
it is just a matter of developing
your business logic accordingly.

190
00:11:35,803 --> 00:11:39,505
So I mentioned about the graphical view.

191
00:11:39,720 --> 00:11:44,830
And also for all the pro, any programming
application, any application that you

192
00:11:44,830 --> 00:11:48,920
are developing with ballerina, you
will get visual representation as well.

193
00:11:48,920 --> 00:11:54,400
That is in terms of sequence diagram,
you can see a left hand side is

194
00:11:54,400 --> 00:11:58,080
a code view, right hand side is a
visual view or the graphical view,

195
00:11:58,090 --> 00:11:59,350
which is the sequence diagram.

196
00:12:00,030 --> 00:12:03,610
So without looking at the source
code, you can understand everything

197
00:12:04,000 --> 00:12:05,840
by looking at the sequence diagram.

198
00:12:05,840 --> 00:12:07,570
As it says, there are two.

199
00:12:07,980 --> 00:12:11,670
endpoints, GitHub and Google sheets.

200
00:12:12,010 --> 00:12:16,450
And this application is getting some
information from GitHub and then,

201
00:12:16,900 --> 00:12:21,550
some from, Google sheets and writing
to the Google sheet at the end.

202
00:12:21,960 --> 00:12:26,950
So if your application is very complex
or having a lot of source files, lines

203
00:12:26,950 --> 00:12:30,630
of codes, going through each of them
to understand who are the different

204
00:12:30,660 --> 00:12:33,970
endpoint, what are the different
endpoints, how we are going to interact

205
00:12:33,970 --> 00:12:36,190
with each of them is very difficult task.

206
00:12:36,655 --> 00:12:41,975
And with this feature, you can visualize
your application without any additional

207
00:12:41,975 --> 00:12:46,095
efforts because every application that
you develop, you will get automatically,

208
00:12:46,255 --> 00:12:49,865
you will get this diagram automatically
if you are using the VS Code plugin.

209
00:12:50,515 --> 00:12:55,195
So this is very important or very helpful
when it comes to the understandability of

210
00:12:55,205 --> 00:12:57,805
the system as well as, maintainability.

211
00:12:58,085 --> 00:13:00,175
And also you can edit this diagram.

212
00:13:00,305 --> 00:13:03,255
You can see plus buttons,
in the diagram nodes.

213
00:13:03,275 --> 00:13:06,455
Where you can add additional
constructs as needed.

214
00:13:06,815 --> 00:13:10,355
So if you prefer to continue in
the diagram side, you can do it,

215
00:13:10,865 --> 00:13:15,515
but most of the time developers
prefer to use the code editing.

216
00:13:15,725 --> 00:13:19,775
So if you edit the code, that
will reflect in the diagram side.

217
00:13:20,465 --> 00:13:22,385
And also documentation.

218
00:13:22,505 --> 00:13:25,925
It plays a very important role in
the application development and

219
00:13:25,925 --> 00:13:29,375
especially enterprise application
development because those applications.

220
00:13:30,225 --> 00:13:34,185
are having complex code and also
maintainability point of view those

221
00:13:34,265 --> 00:13:35,805
applications should live longer.

222
00:13:35,905 --> 00:13:42,225
So this matter, Bellarina supports
Automatic documentation and you can

223
00:13:42,265 --> 00:13:45,945
see the code comments get appended
to the documentation of your

224
00:13:45,945 --> 00:13:51,075
service or application and there is
sophisticated documentation generation

225
00:13:54,240 --> 00:13:59,220
Framework where you can convert
the ballerina inline commands into

226
00:13:59,220 --> 00:14:04,560
documentation of your application
as API, document API specifications.

227
00:14:05,030 --> 00:14:09,580
So this is an example view of how
the commands got converted into the

228
00:14:10,210 --> 00:14:12,220
application or the documentation.

229
00:14:13,475 --> 00:14:16,785
And the other thing about data
transformations, because in the

230
00:14:16,785 --> 00:14:20,655
integration applications, we always
have to deal with different data formats

231
00:14:20,735 --> 00:14:27,805
like XML, JSON, CSV, and many different
formats and also different, even from

232
00:14:27,805 --> 00:14:33,135
JSON to JSON conversions or XML to XML
conversions can be very time consuming

233
00:14:33,135 --> 00:14:34,795
if you have very large payloads.

234
00:14:35,355 --> 00:14:40,065
In Ballerina, we have data mapper,
which is simplifying this process.

235
00:14:40,595 --> 00:14:41,375
You can use.

236
00:14:41,720 --> 00:14:47,730
you can load the left hand side and right
hand side information from where to map.

237
00:14:48,225 --> 00:14:52,495
To which, construct this is
what we call record in Valerina.

238
00:14:52,535 --> 00:14:57,515
We have a type called record in Valerina,
which is the canonical representation

239
00:14:57,515 --> 00:15:02,835
of all the data types like JSON,
XML can be represented as records.

240
00:15:03,375 --> 00:15:06,305
And then it's just a matter
of mapping the record fields.

241
00:15:06,615 --> 00:15:11,715
And also in between you can do multiple
expressions at multiple expressions

242
00:15:11,715 --> 00:15:13,465
to do additional calculations.

243
00:15:13,835 --> 00:15:16,765
And you can map multiple fields
into one fields like that.

244
00:15:17,165 --> 00:15:20,875
without writing any line of
code, you can visually map and

245
00:15:20,875 --> 00:15:22,425
generate the code automatically.

246
00:15:23,375 --> 00:15:25,255
The next thing is about debugging.

247
00:15:26,445 --> 00:15:29,725
In application development,
you always have to troubleshoot

248
00:15:29,725 --> 00:15:30,665
your application code.

249
00:15:31,005 --> 00:15:33,195
Then that's what we need, debugging.

250
00:15:33,615 --> 00:15:37,475
Since Balogna is a programming language,
you can always use usual debugging

251
00:15:37,485 --> 00:15:40,395
capabilities comes with VS Code plugin.

252
00:15:40,705 --> 00:15:44,835
And use the debugging functionalities
like any other programming language.

253
00:15:46,145 --> 00:15:49,635
Then since Balanizer is an integration
technology, it comes with a

254
00:15:49,635 --> 00:15:53,605
distribution which contains the support
for all of these protocol types.

255
00:15:54,015 --> 00:15:57,305
There are so many protocol types when
it comes to integration applications.

256
00:15:57,305 --> 00:16:00,585
We can, we have to deal with different
types of applications, different

257
00:16:00,585 --> 00:16:05,850
services, different clients, like
gRPC, REST, GraphQL, WebSupp.

258
00:16:07,010 --> 00:16:08,280
FTP and so on.

259
00:16:08,630 --> 00:16:11,970
So Ballerina has support for all
these protocol types and you can

260
00:16:11,970 --> 00:16:16,510
define services or clients as
needed using these protocol types.

261
00:16:17,760 --> 00:16:21,610
Not only these protocol support,
Ballerina comes with Ballerina library,

262
00:16:22,080 --> 00:16:27,460
which contains library packages for
utility functions like time, cache,

263
00:16:28,000 --> 00:16:33,270
things like that, and also packages
to support various protocols.

264
00:16:33,290 --> 00:16:36,090
So all these things comes with
the Ballerina distributions.

265
00:16:37,245 --> 00:16:40,535
And you don't need to do
anything explicitly to have

266
00:16:40,535 --> 00:16:42,535
those things in your application.

267
00:16:43,905 --> 00:16:45,725
Not, not just the connect app, library.

268
00:16:45,775 --> 00:16:49,985
Then what we have is the connectors
because integration application means

269
00:16:50,255 --> 00:16:54,355
you always have to connect with different
systems, different endpoints, SAS

270
00:16:54,355 --> 00:16:57,135
applications, data services, and so on.

271
00:16:57,515 --> 00:17:03,295
Belinda has more than 600 plus connectors,
which can connect seamlessly with

272
00:17:03,385 --> 00:17:05,385
these different types of systems.

273
00:17:05,825 --> 00:17:06,565
And if there's.

274
00:17:07,195 --> 00:17:12,085
A system which we already which we are
not supporting at the moment Generating

275
00:17:12,085 --> 00:17:16,515
a connector for such service also very
easy We have open api tool which can

276
00:17:16,875 --> 00:17:21,075
get an open api specification as input
And then convert it to a ballerina

277
00:17:21,075 --> 00:17:24,175
connectors within very short time.

278
00:17:25,885 --> 00:17:30,185
And then the other thing is handling
Data modeling and persisting is also

279
00:17:30,185 --> 00:17:35,745
an important thing ballerina has
module called persist, where we can

280
00:17:35,755 --> 00:17:41,895
use it to model your data, like entity
relationship diagram that you see here.

281
00:17:42,245 --> 00:17:47,245
You can define the relationship
between your entities and then it will

282
00:17:47,245 --> 00:17:52,465
automatically map to different data
types, data sources like databases.

283
00:17:53,195 --> 00:17:58,415
Redis stores or maybe Google
sheets, or in memory data types,

284
00:17:58,835 --> 00:18:00,805
in memory data stores and so on.

285
00:18:01,155 --> 00:18:06,455
It is like ORM that you can see in
some other languages and this persist

286
00:18:06,455 --> 00:18:11,125
capability is very important or very
helpful when designing applications with,

287
00:18:11,525 --> 00:18:14,075
which has data integration capabilities.

288
00:18:15,210 --> 00:18:18,670
so far I have discussed so
many visual capabilities as

289
00:18:18,690 --> 00:18:20,180
well as tooling capabilities.

290
00:18:20,480 --> 00:18:25,250
If I summarize this, we have various
integration tools built with the

291
00:18:25,310 --> 00:18:30,980
distribute inbuilt, in the distribution,
like EDI tool, which can convert

292
00:18:31,340 --> 00:18:37,020
various EDI formats into the other
data formats and also open API tool to

293
00:18:37,760 --> 00:18:42,010
convert a given open API specification
to a service and vice versa.

294
00:18:42,415 --> 00:18:47,425
And, GraphQL tool, health tool
to work with various health

295
00:18:47,535 --> 00:18:49,965
data protocols and formats.

296
00:18:50,375 --> 00:18:56,385
Likewise, all the required tools or
CLI commands are available with the

297
00:18:56,395 --> 00:18:59,865
Ballerina distribution so that you
can work easily with different data

298
00:18:59,875 --> 00:19:06,125
formats, protocols without looking for
alternatives or different external tools.

299
00:19:09,000 --> 00:19:12,490
After application development, the
next thing is about testing or else

300
00:19:12,560 --> 00:19:16,280
you have to think about test when
designing the application itself.

301
00:19:16,640 --> 00:19:18,810
If you think about test
driven applications, so

302
00:19:18,810 --> 00:19:20,030
it's a very important thing.

303
00:19:20,480 --> 00:19:24,760
And ballerina as a language support
all the testing capabilities, you

304
00:19:24,760 --> 00:19:28,940
can generate test reports and see
the coverage numbers and so on.

305
00:19:29,410 --> 00:19:35,100
So your application will not, behave
unexpectedly if you have better tests.

306
00:19:36,000 --> 00:19:38,600
Then the last thing is
about AI capabilities.

307
00:19:39,075 --> 00:19:43,215
Without AI, now we can't survive in
the modern application development.

308
00:19:43,545 --> 00:19:46,695
Balerna as a language has
a GitHub Copilot support.

309
00:19:46,695 --> 00:19:49,815
If you have GitHub Copilot, you
can see the suggestions like this.

310
00:19:50,175 --> 00:19:55,075
It is very much accurate and, Copilot
is aware of Balerna syntax and so on.

311
00:19:55,715 --> 00:19:57,835
And also we have inbuilt AI assistant.

312
00:19:58,240 --> 00:20:04,810
Which can generate unit tests with copilot
and also document the given Application

313
00:20:04,840 --> 00:20:08,980
code which is very much helpful with
the documentation aspects as well as

314
00:20:08,980 --> 00:20:13,980
testing capabilities And also we have
automap feature, which is also AI built

315
00:20:13,980 --> 00:20:21,250
AI based thing which can map the left
hand side of the construct of the record

316
00:20:21,270 --> 00:20:25,570
into the right hand side Which is very
useful in the data mapper When you are

317
00:20:25,570 --> 00:20:27,660
mapping different data formats and types.

318
00:20:28,130 --> 00:20:32,190
So those are some AI capabilities
that we have introduced to make

319
00:20:32,230 --> 00:20:33,340
the developer's life easier.

320
00:20:34,300 --> 00:20:38,220
so far we discussed the development
aspects and the maintenance aspects.

321
00:20:38,520 --> 00:20:41,440
The next thing is about deployment,
which is the key thing in

322
00:20:41,440 --> 00:20:42,550
today's discussion as well.

323
00:20:42,750 --> 00:20:47,510
deployment point of view, you can
build a self contained jar by using

324
00:20:47,510 --> 00:20:51,420
the build command, and then you
can run it using the run command.

325
00:20:51,740 --> 00:20:56,980
It will create a jar file executable,
which you can use to run the application.

326
00:20:57,980 --> 00:21:02,415
But when it comes to cloud deployment,
Ballerina has designed in a way

327
00:21:02,415 --> 00:21:05,385
that it allows the developers
to write code without thinking

328
00:21:05,385 --> 00:21:07,925
about the deployment platform.

329
00:21:08,615 --> 00:21:13,635
So Ballerina developers don't need to
worry about it because that is very much

330
00:21:13,755 --> 00:21:15,655
too much complexity for the developers.

331
00:21:15,985 --> 00:21:20,905
And that greatly simplifies the
experience of developing and deploying

332
00:21:20,925 --> 00:21:22,265
the application in the cloud.

333
00:21:24,515 --> 00:21:28,845
You can use the Belknap commands and
other tools to generate the required

334
00:21:28,845 --> 00:21:31,085
cloud artifacts without much hassle.

335
00:21:31,085 --> 00:21:33,555
So let's see how that is achieved.

336
00:21:34,465 --> 00:21:39,045
You can create a docker image very
easily using bel build command.

337
00:21:39,375 --> 00:21:42,355
You can see dash cloud
with the parameter docker.

338
00:21:42,775 --> 00:21:46,245
It will create the docker file
with all the required dependencies,

339
00:21:46,565 --> 00:21:51,105
docker image, To use with your
deployments and same with kubernetes.

340
00:21:51,245 --> 00:21:55,475
You can use the same command with
the kubernetes flag A parameter

341
00:21:55,775 --> 00:22:00,205
and it will generate the kubernetes
artifacts Where you can modify if

342
00:22:00,205 --> 00:22:01,925
needed or you can use the cloud.

343
00:22:01,955 --> 00:22:06,875
toml file to configure during the build
time itself So the compile is aware

344
00:22:06,945 --> 00:22:11,375
of the resources and other support
definitions configurable variables

345
00:22:11,765 --> 00:22:15,425
And other things available in your
application code and will generate You

346
00:22:15,795 --> 00:22:18,245
the deployment artifacts accordingly.

347
00:22:19,135 --> 00:22:22,855
And then the final thing is about
operation, how we handle things in

348
00:22:22,855 --> 00:22:28,895
the runtime, but now support, all
observable capabilities, including

349
00:22:28,895 --> 00:22:30,735
metrics, tracing, and logging.

350
00:22:31,325 --> 00:22:36,085
And it can be observable by any
open or telemetry supported tools.

351
00:22:36,815 --> 00:22:42,665
So these are some examples of metrics with
Grafana, and this is tracing with Jago.

352
00:22:43,035 --> 00:22:46,695
And distributed login
also supported with that.

353
00:22:46,735 --> 00:22:50,525
I have covered some key aspects
of ballerina and I hope you got

354
00:22:50,525 --> 00:22:55,065
some understanding about what is
ballerina and how we can use it in

355
00:22:55,065 --> 00:22:59,135
the application development as well
as the various deployment aspects.

356
00:22:59,455 --> 00:23:04,155
So I'm going to do some quick demo
around this so that you will get some

357
00:23:04,155 --> 00:23:09,495
understanding about how ballerina
application looks like and how we can

358
00:23:09,935 --> 00:23:12,085
use it during the development time.

359
00:23:12,375 --> 00:23:16,615
As well as how we can use various
deployment capabilities built

360
00:23:16,805 --> 00:23:18,485
in the banana distribution.

361
00:23:18,905 --> 00:23:21,955
For this demo, I'm using a
very simple service related

362
00:23:21,955 --> 00:23:23,315
to hotel management service.

363
00:23:23,715 --> 00:23:26,995
You can see the highlight hotel
backend service, which is accepting

364
00:23:26,995 --> 00:23:30,055
some incoming reservation request
from the hotel web portal.

365
00:23:30,785 --> 00:23:34,905
And it is contacting the room service
to see the availability of the rooms.

366
00:23:35,385 --> 00:23:37,985
And after that it is written.

367
00:23:38,515 --> 00:23:42,445
Returning the confirmed reservations
after doing some calculations and

368
00:23:42,865 --> 00:23:44,695
few other transformations in between.

369
00:23:44,695 --> 00:23:49,465
So it's a very simple service, but this
will help us to understand how well

370
00:23:49,465 --> 00:23:51,385
now application development looks like.

371
00:23:52,315 --> 00:23:55,975
This is the already developed
hotel management application

372
00:23:55,975 --> 00:23:57,085
that I have described.

373
00:23:57,660 --> 00:24:03,760
So I'm using the VS Code editor with
the Balena plugin installed already.

374
00:24:04,200 --> 00:24:07,240
You can see I have installed the
Balena plugin, which comes with all the

375
00:24:07,240 --> 00:24:09,090
visual features that I have explained.

376
00:24:09,730 --> 00:24:13,060
So once you open your application,
you can see multiple files here.

377
00:24:13,460 --> 00:24:17,395
And these BAL files are where your
application programming code is.

378
00:24:17,815 --> 00:24:18,315
Is at.

379
00:24:18,395 --> 00:24:23,505
So once you open those source files,
you can see the source code lines

380
00:24:24,015 --> 00:24:27,575
And also this is the balanatuml
file that I explained which contains

381
00:24:27,585 --> 00:24:32,545
some metadata about the package and
so on So if you look at the main.

382
00:24:32,785 --> 00:24:36,655
bin file, which contains the source code
of the application Let me go through

383
00:24:36,655 --> 00:24:41,885
some of the abstractions I explained
in my slides So this is the service

384
00:24:41,885 --> 00:24:46,745
abstraction, which is very easy to You
define a service in Valerina because it

385
00:24:46,745 --> 00:24:51,985
is a syntax, Valerina support service as
a first class thing in, language syntax.

386
00:24:52,325 --> 00:24:57,275
And when you attach a service with HTTP
listener, it will become an HTTP service.

387
00:24:57,555 --> 00:25:00,555
And if you attach it with
a GraphQL listener, it will

388
00:25:00,585 --> 00:25:01,840
become a GraphQL service.

389
00:25:03,120 --> 00:25:05,730
You don't need to deal with
underlying complexities.

390
00:25:06,080 --> 00:25:10,810
You can provide additional configuration
parameters to configure your listener.

391
00:25:11,290 --> 00:25:15,820
But other than that, you don't have to
worry about the underneath complexities.

392
00:25:16,160 --> 00:25:19,070
And also that every service
can have resource functions.

393
00:25:19,480 --> 00:25:23,760
And if you look at these resource function
signatures, those are very intuitive

394
00:25:23,760 --> 00:25:28,770
because those looks like normal function
calls where we have a function name,

395
00:25:28,850 --> 00:25:31,670
input parameters, return types, and so on.

396
00:25:32,560 --> 00:25:36,780
And after you design the skeleton of
this application, how the services,

397
00:25:36,870 --> 00:25:40,165
what are the services, What are
the resources within each services?

398
00:25:40,185 --> 00:25:43,775
It is just a matter of, implementing
the business logic carefully.

399
00:25:44,325 --> 00:25:48,435
So all these things comes with the
visual, representation as well.

400
00:25:48,855 --> 00:25:53,345
So if you open up the visual, panel
of the ballerina application, you can

401
00:25:53,345 --> 00:25:55,055
see the summary of your application.

402
00:25:55,455 --> 00:25:57,595
It has, one function, one service.

403
00:25:57,825 --> 00:26:00,585
Many records, many global
variables and so on.

404
00:26:00,955 --> 00:26:03,425
So these are the records that I
mentioned, which is a canonical

405
00:26:03,465 --> 00:26:05,335
format for representing your data.

406
00:26:05,845 --> 00:26:09,785
And when it comes to the service,
you can go to the service designer.

407
00:26:09,825 --> 00:26:11,535
So this is the service designer.

408
00:26:11,725 --> 00:26:14,555
You can see how many resources are there.

409
00:26:14,775 --> 00:26:15,725
What are their types?

410
00:26:16,055 --> 00:26:18,345
HTTP, POST, GET, DELETE and so on.

411
00:26:18,745 --> 00:26:21,185
And you can edit these
resources graphically.

412
00:26:21,625 --> 00:26:24,470
And also you can, use the.

413
00:26:24,520 --> 00:26:25,800
this is some summary.

414
00:26:26,150 --> 00:26:32,430
And if you look at one of these functions,
for example, bookings, you can see the

415
00:26:32,480 --> 00:26:34,470
associated sequence diagram as well.

416
00:26:36,120 --> 00:26:36,780
Let me.

417
00:26:38,830 --> 00:26:40,000
Reduce the size a little bit.

418
00:26:40,320 --> 00:26:44,490
So you can see the full logic and it
is not that interesting because it is

419
00:26:44,490 --> 00:26:46,440
interacting with only one other endpoint.

420
00:26:46,490 --> 00:26:50,860
But if your resource function is
talking to many different endpoints,

421
00:26:50,860 --> 00:26:55,700
data services, databases, and gathering
data, you can see all these things.

422
00:26:56,085 --> 00:27:00,535
As a nice sequence diagram where
you can understand the code easily.

423
00:27:00,915 --> 00:27:03,595
So these are some, interesting
things about Valerina.

424
00:27:03,995 --> 00:27:05,945
And let me expand the source code.

425
00:27:06,035 --> 00:27:10,265
So this is already implemented, simple
service which gets the reservation request

426
00:27:10,265 --> 00:27:13,705
as set of payload, arrays in the payload.

427
00:27:13,755 --> 00:27:17,290
And I'm just iterating it to
check the room availability

428
00:27:17,290 --> 00:27:18,660
with the external service.

429
00:27:18,910 --> 00:27:23,600
And do some conversions in between
using this transform function and then

430
00:27:23,870 --> 00:27:29,250
return that transformed message So if
we look at this transform function that

431
00:27:29,250 --> 00:27:35,680
is also A bit interesting because that
contains the data mapper because I need

432
00:27:35,680 --> 00:27:41,450
to convert one type into another So along
with some other additional calculations

433
00:27:41,450 --> 00:27:46,685
and other things in between for example
You can drag and drop these fields into

434
00:27:46,685 --> 00:27:49,895
each other using the, visuals panel.

435
00:27:50,295 --> 00:27:54,585
And you can see, I combined the first
name and last name using the, expression

436
00:27:54,585 --> 00:27:58,665
editor, and you can do any other
calculation in between if you need.

437
00:27:59,095 --> 00:28:03,055
So this is the Balena data mapper, and
we have auto map feature as well, where

438
00:28:03,095 --> 00:28:07,975
we can, use AI support to generate
these mappings based on the names

439
00:28:07,975 --> 00:28:09,785
of the fields and types and so on.

440
00:28:11,525 --> 00:28:14,585
Now, let's see how we can
run this application locally.

441
00:28:15,685 --> 00:28:21,995
To do that, you can use balerun
command line, balerun command.

442
00:28:23,215 --> 00:28:27,595
It will compile the application
and run it in your local machine.

443
00:28:27,985 --> 00:28:31,765
You can see I have attached
the port 9090, so it will start

444
00:28:31,765 --> 00:28:33,555
the service in the port 9090.

445
00:28:34,145 --> 00:28:35,935
So you can invoke the service.

446
00:28:38,065 --> 00:28:39,085
By using the curl

447
00:28:42,465 --> 00:28:48,055
port 9 to 90 and you can see in the
service path is hotel and let's invoke

448
00:28:48,145 --> 00:28:51,655
a resource like, rooms or bookings.

449
00:28:54,275 --> 00:28:57,395
You can see we don't have any
bookings at the, as of now.

450
00:28:57,835 --> 00:28:59,605
And if we look at rooms, it is.

451
00:29:02,585 --> 00:29:03,715
Let me prettify it.

452
00:29:04,295 --> 00:29:06,995
You can see the room details
response, which is adjacent.

453
00:29:07,585 --> 00:29:10,455
So now the service is up and
running in your local machine.

454
00:29:10,775 --> 00:29:14,505
And also you can use the try it
feature available in ballerina

455
00:29:14,855 --> 00:29:19,865
itself, where we have a swagger
like view to test the application.

456
00:29:19,875 --> 00:29:25,635
You can use the try out command
here and you can see no bookings

457
00:29:25,755 --> 00:29:28,955
and you can get the rooms.

458
00:29:28,955 --> 00:29:29,085
Thanks.

459
00:29:29,785 --> 00:29:34,805
You can use a tryout, execute, you
can see the same response here.

460
00:29:36,075 --> 00:29:40,285
I hope that you got some understanding
about how the Balena code looks like, and

461
00:29:40,295 --> 00:29:44,765
we already compiled it and run it locally.

462
00:29:44,965 --> 00:29:48,805
Now, as the next step, let's see how we
can run the application in the cloud.

463
00:29:49,365 --> 00:29:53,605
Before doing that, let me add one
more resource, that is to check

464
00:29:53,605 --> 00:29:57,835
the readiness of the application
by adding a readiness function.

465
00:29:58,470 --> 00:30:01,280
So to do that, I added
another resource function.

466
00:30:02,230 --> 00:30:06,100
as health readiness, which
is just returning HTTP.

467
00:30:06,100 --> 00:30:06,350
Okay.

468
00:30:06,890 --> 00:30:09,370
Then we need to add this
as a readiness probe.

469
00:30:09,960 --> 00:30:12,320
so to do that, we need to open the cloud.

470
00:30:12,360 --> 00:30:12,520
tuml.

471
00:30:12,520 --> 00:30:13,385
Cloud.

472
00:30:13,385 --> 00:30:18,890
tuml file is a configuration file where
you can use to modify it to, use to

473
00:30:18,890 --> 00:30:20,890
modify the generated cloud artifacts.

474
00:30:21,260 --> 00:30:24,480
You can see we already have
the container image details.

475
00:30:24,590 --> 00:30:27,500
And in addition to that, let
me add the readiness probe.

476
00:30:28,990 --> 00:30:33,280
You can see the values and
parameters are auto suggested.

477
00:30:33,630 --> 00:30:38,030
So I'm using them and
the path is readiness.

478
00:30:39,150 --> 00:30:45,510
And in addition to that, I need to
add the base path as the slash hotel.

479
00:30:50,060 --> 00:30:51,010
Now it's all good.

480
00:30:51,250 --> 00:30:57,340
Let's use the build command
to build the application.

481
00:30:58,130 --> 00:31:01,060
Compile it and then generate
the cloud artifacts.

482
00:31:06,075 --> 00:31:14,055
do that, I'm using the build command
with the cloud option as Kubernetes.

483
00:31:17,905 --> 00:31:22,255
it will compile the source and it
will generate the cloud artifacts.

484
00:31:26,645 --> 00:31:29,415
can see there's some error
in the readiness probe path.

485
00:31:29,815 --> 00:31:33,885
That means the compiler understands
the resource file, the implementation

486
00:31:33,885 --> 00:31:36,255
as well as the cloud toml details.

487
00:31:36,255 --> 00:31:37,435
Let's see what's the difference.

488
00:31:37,825 --> 00:31:42,855
Here we have the name as readiness
and my function name, resource

489
00:31:42,855 --> 00:31:43,925
function name is different.

490
00:31:44,025 --> 00:31:47,855
So let me fix it and quickly
do the belpair command again.

491
00:31:56,755 --> 00:31:58,955
Now you can see the
artifacts are generating.

492
00:31:59,705 --> 00:32:02,425
And finally you can see
the commands to execute.

493
00:32:03,315 --> 00:32:06,685
Before that, let's explore what
happened in our target directory.

494
00:32:06,985 --> 00:32:08,495
You can see under docker.

495
00:32:09,065 --> 00:32:16,125
Now we have the docker file generated with
all the dependencies required to run this.

496
00:32:16,615 --> 00:32:22,235
And also under kubernetes, you
can see the yaml file with all the

497
00:32:22,235 --> 00:32:30,200
details like service versions and
other metadata, number of replicas,

498
00:32:30,340 --> 00:32:37,390
the image name to be used with this
and also the readiness probe details

499
00:32:37,440 --> 00:32:40,760
with the initial delay of 30 seconds.

500
00:32:42,140 --> 00:32:43,930
So now everything is ready.

501
00:32:43,990 --> 00:32:46,020
We didn't write any ml file manually.

502
00:32:46,110 --> 00:32:49,320
All these things were generated
by the command itself.

503
00:32:49,460 --> 00:32:50,510
And we can use the cloud.

504
00:32:50,570 --> 00:32:53,610
toml to configure some
these values if you need.

505
00:32:54,210 --> 00:32:55,570
Now let's try to run this.

506
00:32:56,020 --> 00:33:01,970
I'm using Rancho desktop in my
local machine and before running

507
00:33:01,970 --> 00:33:04,710
this, let's see the docker images.

508
00:33:07,120 --> 00:33:08,460
You can see the hotel API.

509
00:33:09,715 --> 00:33:14,905
With the tag of 1 0 0 is generated
about a minute ago now the Docker file

510
00:33:14,965 --> 00:33:17,725
is available and let's use this command

511
00:33:20,295 --> 00:33:28,405
to deploy the Kubernetes artifacts and
You can see the service created deployment

512
00:33:28,405 --> 00:33:36,175
created and Then let's use this command to
export Or access the service via node port

513
00:33:40,125 --> 00:33:45,945
hotel's this log service is now exposed
as a node port Now, let's see our

514
00:33:45,945 --> 00:33:48,245
kubernetes services and deployments

515
00:33:53,285 --> 00:33:59,395
can see the deployment is created
Let's see the services And the

516
00:33:59,395 --> 00:34:06,785
services are created and you can see
it's mapped to the This port 30517.

517
00:34:07,315 --> 00:34:11,245
Now instead of localhost 9090 port
that I used earlier, which is not

518
00:34:11,295 --> 00:34:13,955
working now, we can use that port

519
00:34:16,425 --> 00:34:19,175
which is deployed in
our Kubernetes cluster

520
00:34:21,355 --> 00:34:22,685
to invoke this application.

521
00:34:22,685 --> 00:34:24,605
Now you can see the same response.

522
00:34:24,905 --> 00:34:29,325
So we have deployed the application
in the cloud without writing any

523
00:34:29,405 --> 00:34:32,065
ml file or without generating
the docker files manually.

524
00:34:32,785 --> 00:34:34,935
So this is basically the end of my demo.

525
00:34:35,495 --> 00:34:39,985
And this will give, I hope this
gave an understanding about how we

526
00:34:39,985 --> 00:34:44,045
can write the application and use
the existing or built in commands

527
00:34:44,045 --> 00:34:45,945
to generate the required artifacts.

528
00:34:47,115 --> 00:34:51,155
With this demo, I hope you got a very
good understanding about how Balerna looks

529
00:34:51,155 --> 00:34:56,395
like and how we can use the various built
in commands to handle the deployments.

530
00:34:56,905 --> 00:35:00,425
I would like to wrap up my
session by introducing you into

531
00:35:00,425 --> 00:35:02,135
the Balerna community as well.

532
00:35:03,155 --> 00:35:07,783
We have a very vibrant community and
active, so you can visit balerna.

533
00:35:07,843 --> 00:35:09,693
io community page.

534
00:35:09,903 --> 00:35:14,773
And get to know various efforts
and community activities, including

535
00:35:14,773 --> 00:35:19,413
tech talks, training, university
programs, and almost all of these

536
00:35:19,503 --> 00:35:25,823
are very much, freely available for
various audience groups and feel free

537
00:35:25,823 --> 00:35:27,713
to join with us in the community.

538
00:35:28,003 --> 00:35:31,993
And these are some images from various
conferences, activities, meet hubs

539
00:35:32,043 --> 00:35:33,973
that we have done in the recent past.

540
00:35:34,453 --> 00:35:36,483
And you can subscribe to our events.

541
00:35:37,213 --> 00:35:40,873
and get, be active on those as well.

542
00:35:40,873 --> 00:35:44,073
And also if you are interested
about learning ballerina,

543
00:35:44,073 --> 00:35:46,413
visit ballerina website.

544
00:35:46,483 --> 00:35:51,823
We have learn examples, learn pages,
and we have a youtube video training

545
00:35:52,083 --> 00:35:56,573
where you can get more in depth or
hands on experience about ballerina.

546
00:35:57,093 --> 00:36:01,413
And also we have ballerina certification
if you are interested in gaining

547
00:36:01,423 --> 00:36:03,113
more knowledge about ballerina.

548
00:36:03,113 --> 00:36:08,818
And If you are using Balena feel
free to raise your questions or any

549
00:36:08,818 --> 00:36:13,088
clarifications in Balena discord
channel as well as tech core flow.

550
00:36:13,788 --> 00:36:16,228
Our community is very active
in those channels and you

551
00:36:16,228 --> 00:36:18,308
will get responses rapidly.

552
00:36:18,798 --> 00:36:23,218
And also if you're open source
contributor, feel free to join with us in

553
00:36:23,218 --> 00:36:29,348
the Balena language hub repository and all
our repositories are open source and you

554
00:36:29,348 --> 00:36:31,788
can be part of the contributors as well.

555
00:36:32,828 --> 00:36:35,148
So with that, I'm wrapping up my session.

556
00:36:35,158 --> 00:36:40,278
Thank you very much for joining with
this session and hope you have enjoyed.

557
00:36:40,568 --> 00:36:41,118
Thank you.

