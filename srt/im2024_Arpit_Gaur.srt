1
00:00:00,060 --> 00:00:02,980
Hi, my name is Arpit Kaur, and
today we'll be talking about

2
00:00:03,000 --> 00:00:05,920
implementing solid principles
for effective code architecture.

3
00:00:06,580 --> 00:00:09,440
before we dive into solid, let's,
let me give you my introduction.

4
00:00:09,759 --> 00:00:13,970
I have about more than 16 years
of experience leading the large

5
00:00:13,970 --> 00:00:17,389
scale organizations such as Amazon,
Microsoft, and a couple of other places.

6
00:00:17,970 --> 00:00:21,759
And what I've done in these places is
delivered at scale, working software

7
00:00:21,810 --> 00:00:25,549
solutions below budget, which are still
working in production without any bug

8
00:00:25,549 --> 00:00:26,749
and serving our customers worldwide.

9
00:00:27,529 --> 00:00:30,089
At Amazon, I let some of the contributed.

10
00:00:30,199 --> 00:00:34,160
I let some of the successful projects
like video games, books, Kindle,

11
00:00:34,199 --> 00:00:39,059
Alexa, and I also heard a few patents
specifically, which I'm proud of is on

12
00:00:39,570 --> 00:00:42,519
one click sell at Amazon and at Microsoft.

13
00:00:42,519 --> 00:00:47,040
I focus on Azure and open app projects
where I leverage my expertise in building

14
00:00:47,040 --> 00:00:50,350
the disability system, which I learned
at Amazon, where I spent about a decade

15
00:00:50,980 --> 00:00:55,049
here at Microsoft for solving a customer's
problem using especially in this, And my

16
00:00:55,049 --> 00:00:58,969
questions include API first architectural
patterns specifically on Azure and AWS

17
00:00:58,969 --> 00:01:01,699
cloud solutions and no SQL data modeling.

18
00:01:01,699 --> 00:01:06,459
So moving away from classical SQL
based data modeling, which has been a

19
00:01:06,459 --> 00:01:08,299
standard in the industry from 1960s.

20
00:01:08,329 --> 00:01:13,649
But since in this modern age of big data,
no SQL is a little bit lagging behind.

21
00:01:13,690 --> 00:01:15,199
Again, depends on the use case.

22
00:01:15,769 --> 00:01:17,340
And this is my LinkedIn.

23
00:01:17,570 --> 00:01:22,320
Please feel free to take a screenshot
of this and connect me on LinkedIn.

24
00:01:24,020 --> 00:01:26,619
so let's quickly jump into
the solid principles now.

25
00:01:26,699 --> 00:01:30,060
So the introduction about solid is
it's an acronym It stands for five

26
00:01:30,060 --> 00:01:34,189
principles which are used in software
design their design principles, but

27
00:01:34,189 --> 00:01:38,359
they are marketed as design personal
design patterns for object oriented

28
00:01:38,359 --> 00:01:39,740
programming But that's not true.

29
00:01:39,760 --> 00:01:44,469
It's applicable in everything that we
build in software world specifically

30
00:01:44,469 --> 00:01:49,656
from functions modules classes
services and These solid principles

31
00:01:49,656 --> 00:01:51,126
can be used almost everywhere.

32
00:01:51,556 --> 00:01:53,066
They were introduced by Robert C.

33
00:01:53,066 --> 00:01:55,136
Martin, also known as Uncle Bob.

34
00:01:55,796 --> 00:01:59,746
And when he created these five principles,
he did not have them in these orders.

35
00:02:00,146 --> 00:02:01,606
They were randomly juggled.

36
00:02:01,656 --> 00:02:05,156
And then, Michael Feathers, who is
a friend of his, created this solid

37
00:02:05,156 --> 00:02:08,446
acronym and just got popularized
because it's easy and catchy.

38
00:02:09,276 --> 00:02:12,146
now let's jump into what
these are specifically.

39
00:02:13,031 --> 00:02:14,891
So as the name says, it's an acronym.

40
00:02:14,891 --> 00:02:17,011
So S stands for single responsibility.

41
00:02:17,191 --> 00:02:19,551
And again, we're going to dive
deep into each one of these.

42
00:02:20,141 --> 00:02:21,871
O is for open close principle.

43
00:02:22,201 --> 00:02:24,191
L is for Liskov substitution principle.

44
00:02:24,661 --> 00:02:26,271
I is for interface segregation.

45
00:02:26,391 --> 00:02:28,311
And D is for dependence
inversion principle.

46
00:02:29,891 --> 00:02:33,991
Each of these bring up some
spotted aspect of software design.

47
00:02:34,271 --> 00:02:37,231
again, as I said earlier,
ranging from modules, functions,

48
00:02:37,691 --> 00:02:39,791
classes, services, and whatnot.

49
00:02:41,311 --> 00:02:45,351
And they help in ensuring that
our code quality over time remains

50
00:02:45,651 --> 00:02:50,831
flexible, changeable and also evolvable
because at the end of the day, we are

51
00:02:50,831 --> 00:02:52,261
not writing the code for machines.

52
00:02:52,781 --> 00:02:56,831
In the last 20, 30 years, the machines
have gotten really smart, efficient.

53
00:02:56,831 --> 00:02:58,811
We are writing code for our teammates.

54
00:02:59,586 --> 00:03:03,746
And our future self two months to six
months in the future who would then go

55
00:03:03,746 --> 00:03:08,226
and either debug some of the code We are
developing or add to the features which

56
00:03:08,226 --> 00:03:11,746
have been developed today So keeping
that in mind, we have to ensure that

57
00:03:11,746 --> 00:03:15,846
our software that we develop is loosely
coupled So we what do you mean by that

58
00:03:15,846 --> 00:03:20,506
is if you make a change here in one small
component It doesn't change or break

59
00:03:20,506 --> 00:03:27,401
something which is five chains down the
control flow And that is what these,

60
00:03:27,461 --> 00:03:29,571
principles solidify and bring to home.

61
00:03:29,671 --> 00:03:34,461
So let's start with the first one, which
is SRP single responsibility principle.

62
00:03:35,221 --> 00:03:38,941
as it says, single responsibility,
it's quite simple in terms of

63
00:03:39,231 --> 00:03:43,271
understanding single response, you
mean one component, whatever it is,

64
00:03:43,511 --> 00:03:47,661
it's module class function, they
should have only one responsibility.

65
00:03:48,011 --> 00:03:50,991
They should do one thing and they
should do that one thing quite well.

66
00:03:51,761 --> 00:03:54,691
Try to understand it in a way, if you
are working in a company as an employee.

67
00:03:55,616 --> 00:04:02,596
You should not be, you should be able
to be fired by one CXO, so either a

68
00:04:02,596 --> 00:04:11,006
COO, CEOO, CEO, or somebody else, which
is again CXO, because if we take COO

69
00:04:11,786 --> 00:04:17,366
and CEO as an example, if your employee
class implements, let's say accounting,

70
00:04:17,376 --> 00:04:22,481
which comes under COO and payroll
related to that, you And let's say it

71
00:04:22,481 --> 00:04:25,111
also implements the actual function of
the employee, whatever it is, let's say

72
00:04:25,111 --> 00:04:27,051
writing code, so code could be a function.

73
00:04:27,561 --> 00:04:30,751
Do not implement both of them in the
same class, because if you mess up that

74
00:04:30,751 --> 00:04:34,091
class, then you are fireable by 2 CXO.

75
00:04:34,091 --> 00:04:36,271
And that is how you can
bring home this principle.

76
00:04:36,801 --> 00:04:40,451
Just take one responsibility in a
class, in this example of employee, you

77
00:04:40,451 --> 00:04:41,761
can break it down to different class.

78
00:04:42,271 --> 00:04:46,786
And the benefits of this is, It's easy
to understand and obviously it makes our

79
00:04:46,786 --> 00:04:49,156
code easily testable, easily modifiable.

80
00:04:49,676 --> 00:04:53,686
And the challenge is, how do
you identify the granularity?

81
00:04:53,876 --> 00:04:56,146
Where do you define the
boundary of being single?

82
00:04:56,756 --> 00:05:00,416
And what I use is, that
being fireable by one CXO.

83
00:05:00,426 --> 00:05:02,816
So let's use an example.

84
00:05:04,326 --> 00:05:07,026
So the example that I was talking
about earlier, an employee is

85
00:05:07,026 --> 00:05:08,126
trying to do three things here.

86
00:05:08,576 --> 00:05:11,516
Calculate pay, save to
database, and generate report.

87
00:05:11,776 --> 00:05:14,696
Now calculate pay is something
related to finances, right?

88
00:05:15,151 --> 00:05:17,871
So CFO is eventually responsible for it.

89
00:05:18,481 --> 00:05:22,921
Safety database is A technical aspect
how your database is structured.

90
00:05:22,931 --> 00:05:28,491
So eventually Our database is going
to roll up into a cto and generate

91
00:05:28,631 --> 00:05:32,181
report is somebody who's going
to deal with the finances and the

92
00:05:32,191 --> 00:05:35,501
eventual reports of the business
and how the business is performing.

93
00:05:35,501 --> 00:05:41,181
So a ceo or probably a coo is
gonna Deal with these aspects.

94
00:05:41,191 --> 00:05:47,441
So there are three cx o level employees
who are Directly getting impacted if you

95
00:05:47,471 --> 00:05:49,091
mess up this class, how can we break out?

96
00:05:49,101 --> 00:05:52,416
So this is a bad example How
can we break it into smaller,

97
00:05:52,436 --> 00:05:55,306
singly responsible components?

98
00:05:56,606 --> 00:05:57,506
Let's try to do this.

99
00:05:58,066 --> 00:06:01,006
Take an employee and just
implement CalculatePay.

100
00:06:01,646 --> 00:06:04,586
Take an employee repository, which
is a different class altogether,

101
00:06:04,586 --> 00:06:07,676
completely different component,
which saves to database and

102
00:06:07,706 --> 00:06:09,116
takes an instance of employee.

103
00:06:09,436 --> 00:06:12,635
So the functionality of saving
to database resides inside this,

104
00:06:12,635 --> 00:06:15,456
but how the CalculatePay is
happening is completely outside.

105
00:06:15,811 --> 00:06:17,831
And then report generator
could be in the class.

106
00:06:17,861 --> 00:06:19,021
And again, this is just an example.

107
00:06:19,021 --> 00:06:21,921
You can structure it accordingly
based on your use cases.

108
00:06:22,431 --> 00:06:25,021
Our generator board, this also
takes an instance of employee,

109
00:06:25,091 --> 00:06:29,531
but how the base calculator, how
the database is being updated by

110
00:06:29,531 --> 00:06:33,291
saving the entities is completely
different out of the report generator.

111
00:06:33,551 --> 00:06:36,501
So here you see we have broken down
the three function into three classes.

112
00:06:36,771 --> 00:06:39,351
And this is an example
of single responsible.

113
00:06:39,951 --> 00:06:43,461
We have three classes, each of them
doing the one of the three functions,

114
00:06:43,501 --> 00:06:44,491
and we're doing them really well.

115
00:06:46,071 --> 00:06:48,971
And jumping on to the next one,
which is the second principle,

116
00:06:48,991 --> 00:06:51,031
which is open close principle here.

117
00:06:51,121 --> 00:06:53,981
It means open for extension,
close for modification.

118
00:06:54,361 --> 00:06:55,261
What do we mean by that?

119
00:06:55,271 --> 00:06:57,891
That any component classes,
modules function, they

120
00:06:57,891 --> 00:06:59,301
should be open for extension.

121
00:06:59,661 --> 00:07:03,081
That means we should be able to add
more functionality or extend the

122
00:07:03,591 --> 00:07:06,881
existing functionality, but they
should be closed for modification

123
00:07:07,121 --> 00:07:09,121
to add that extended functionality.

124
00:07:09,421 --> 00:07:12,481
We shouldn't be going back and
modifying the already implemented code.

125
00:07:12,991 --> 00:07:18,066
So let's look at this example, which is,
an area calculator and here we have, two,

126
00:07:18,396 --> 00:07:23,606
two functions which are overloaded and
they take an instance of rectangle are

127
00:07:23,636 --> 00:07:31,046
and a circle C and in both the cases, we
see that the implementation of the area

128
00:07:31,046 --> 00:07:35,596
is implemented on the calculation of areas
implemented, but they're quite different.

129
00:07:35,946 --> 00:07:40,156
But now remember, what if we
have to add a triangle, we

130
00:07:40,156 --> 00:07:41,376
will have to modify the class.

131
00:07:41,376 --> 00:07:41,426
Okay.

132
00:07:41,796 --> 00:07:46,646
Why because height radius and
width and by these things are

133
00:07:46,646 --> 00:07:49,626
not related to a triangle, right?

134
00:07:49,626 --> 00:07:55,216
It's basically a base and height
so we cannot extend this class to

135
00:07:55,216 --> 00:08:01,156
calculate the area of a rectangle
And a better example would be this.

136
00:08:01,626 --> 00:08:07,016
So here what we're doing is we are saying
break down the rectangle and circle into

137
00:08:07,016 --> 00:08:11,666
different classes and then inherit them
from An interface has an implementation

138
00:08:11,666 --> 00:08:16,216
of calculate area or rather the definition
and then each of these classes can

139
00:08:16,216 --> 00:08:18,396
implement their own implementation.

140
00:08:18,786 --> 00:08:24,206
So when we go into area of calculator,
it takes an interface and the interface

141
00:08:24,206 --> 00:08:26,696
has the implementation of calculate area.

142
00:08:26,696 --> 00:08:31,936
So when we create the class like a
triangle, it extends from I shape, but it

143
00:08:31,956 --> 00:08:34,216
implements the calculate area in itself.

144
00:08:34,436 --> 00:08:37,036
So when you're in area calculator,
you don't really have to care about.

145
00:08:38,351 --> 00:08:42,641
by or height or width because they
are meaningless in area calculating.

146
00:08:42,651 --> 00:08:47,531
Those details are abstracted out inside
the specific classes of rectangle, circle

147
00:08:47,581 --> 00:08:54,171
and triangle, and the implementation is
forced by inheriting from the interface.

148
00:08:55,331 --> 00:09:00,341
The benefits is that it ensures
that or rather it encourages that

149
00:09:00,341 --> 00:09:03,781
the risk of introducing bugs in
the already existing features.

150
00:09:04,211 --> 00:09:08,381
Is close to zero when you're trying to
add new features or extend the existing

151
00:09:08,381 --> 00:09:13,731
functionality the challenge is that it's
very difficult to think the future cases

152
00:09:13,751 --> 00:09:14,881
and how do you need to break it up?

153
00:09:15,341 --> 00:09:21,441
So that's where the experience and
Good level of testing a testable

154
00:09:22,001 --> 00:09:25,261
smaller component come into picture
which can help you in thinking with

155
00:09:25,261 --> 00:09:31,576
this process moving on to the next
one, which is Liskov substitution So

156
00:09:31,576 --> 00:09:35,356
here, it's, it was created by Liskov
and henceforth it's named like this.

157
00:09:35,726 --> 00:09:39,266
it doesn't give you any hint about it,
but the details are that you should

158
00:09:39,276 --> 00:09:46,596
be able to, substitute the lower
level implementation of any interface

159
00:09:47,266 --> 00:09:50,826
or an abstract class details without
breaking the upper level function.

160
00:09:52,056 --> 00:09:55,576
Now, again, let's look at
this, an example in C sharp.

161
00:09:56,366 --> 00:10:00,031
So we have a class rectangle,
which has Over 10 in height,

162
00:10:00,221 --> 00:10:01,251
which is quite standard.

163
00:10:01,781 --> 00:10:04,941
Now, all of us know that
a square is a rectangle.

164
00:10:04,981 --> 00:10:07,501
It's a type of rectangle
with width equal to hide.

165
00:10:08,151 --> 00:10:11,601
So here, what we are saying is we
are implementing in a cheeky way

166
00:10:12,151 --> 00:10:17,061
that we are saying overwrite the
width to be equal, sorry, to make,

167
00:10:17,261 --> 00:10:21,721
to be able to the height and do the
same thing for the height as well.

168
00:10:22,161 --> 00:10:24,331
So what happens when we try to.

169
00:10:24,331 --> 00:10:26,341
calculate an area.

170
00:10:26,341 --> 00:10:33,421
Now if we change the Height
or the width of the rectangle.

171
00:10:33,641 --> 00:10:38,731
It only changes what dimension but
Because we have forced this cheeky way

172
00:10:38,731 --> 00:10:44,521
of calculating the height and the width
the square also gets updated and that

173
00:10:44,521 --> 00:10:49,691
is a forced mechanism because we are
trying to Use this real world concept of

174
00:10:49,951 --> 00:10:51,651
square is an rectangle from a real world.

175
00:10:52,081 --> 00:10:56,541
And this is also a good point to Recollect
the thought that even though in real world

176
00:10:56,571 --> 00:11:01,611
we think a square is a rectangle, but this
is computer programming This Idea that

177
00:11:01,631 --> 00:11:05,451
object oriented represents objects from
real life is just a marketing gimmick.

178
00:11:05,681 --> 00:11:10,581
It's not true And one example would
be let's say there's a couple and

179
00:11:10,581 --> 00:11:14,091
there are two people who are getting
divorced Now the each of them would

180
00:11:14,101 --> 00:11:18,671
have a lawyer representing them Now
the lawyers who are representing the

181
00:11:18,881 --> 00:11:23,281
individuals are not getting divorced
themselves Let's use that idea over

182
00:11:23,281 --> 00:11:28,986
here the class rectangle and the class
square as lawyers of the actual rectangle

183
00:11:28,986 --> 00:11:30,546
or actual square in the real world.

184
00:11:31,076 --> 00:11:33,906
So even though a square is a rectangle,
they share a relationship, but that

185
00:11:33,906 --> 00:11:37,606
does not mean that their representatives
also share the same relationship.

186
00:11:38,066 --> 00:11:42,066
Henceforth, forcing the class square
to extend from rectangle is that

187
00:11:42,066 --> 00:11:45,556
forcefulness, which is pushing
us into this buggy situation.

188
00:11:46,136 --> 00:11:50,226
A better idea would be to not force a
square to be rectangle, but other than

189
00:11:50,226 --> 00:11:54,916
keep under both of them are shapes
essentially and calculation of area

190
00:11:54,946 --> 00:11:59,431
and Internal dimension should belong
within those classes themselves.

191
00:11:59,801 --> 00:12:01,831
So let's look at how we
can correct this example.

192
00:12:03,281 --> 00:12:07,541
Let's take an interface shape, which
has a function of area calculation.

193
00:12:07,941 --> 00:12:11,981
And then when class Rectangle and
Square implement the IShape interface,

194
00:12:12,381 --> 00:12:15,491
they can implement the details
of the area within themselves.

195
00:12:15,581 --> 00:12:18,861
Here the class Rectangle would have
its own integer width and height.

196
00:12:19,586 --> 00:12:21,296
But class square will only have side.

197
00:12:21,696 --> 00:12:26,396
It doesn't have to force two attributes
and the area respectively would be inside.

198
00:12:26,396 --> 00:12:29,816
The rectangle would be
height into width and square.

199
00:12:29,816 --> 00:12:31,396
It would be simply a square of the side.

200
00:12:32,276 --> 00:12:36,726
So it ensures that this principle
of the scope substitution, ensures

201
00:12:36,726 --> 00:12:40,596
that we are not changing one
implementation of interface and

202
00:12:40,596 --> 00:12:41,876
just getting surprised altogether.

203
00:12:42,126 --> 00:12:48,801
Because if we go back, to this home
example, if we change this detail of

204
00:12:49,031 --> 00:12:52,631
because square is in a child class
of rectangle here, if you change the

205
00:12:52,641 --> 00:12:57,821
implementation in the usage of rectangle
to a square, the code completely breaks.

206
00:12:58,291 --> 00:13:02,701
Whereas here, it does not break because
even if you change the eye shape to

207
00:13:02,801 --> 00:13:06,681
represent rectangle or square, it
returns the right or the correct area.

208
00:13:07,961 --> 00:13:12,871
And here an analogy is child class should
be able to fill it parentials without

209
00:13:12,871 --> 00:13:16,881
causing chaos because earlier we saw
with example of forced relationship that

210
00:13:16,881 --> 00:13:19,726
they're causing chaos or Code breakage.

211
00:13:20,826 --> 00:13:23,676
the next one would be interface
segregation principle.

212
00:13:25,231 --> 00:13:29,121
Here, the idea is that we should not
force our clients to depend on interfaces

213
00:13:29,151 --> 00:13:34,021
that they do not use, and it comes
from, 1980s and 90s forcefulness of

214
00:13:34,021 --> 00:13:37,601
code when we're trying to add more and
more functionalities into interfaces

215
00:13:37,651 --> 00:13:40,131
and then just forcing the, child
implementations to implement them.

216
00:13:40,991 --> 00:13:43,711
An example would be, this
thing that is on our screen.

217
00:13:43,751 --> 00:13:47,291
here we see a worker, and
a worker is a human worker.

218
00:13:47,541 --> 00:13:50,181
So a human worker works, eats, and sleeps.

219
00:13:50,831 --> 00:13:52,991
whereas a robot worker is also worker.

220
00:13:53,501 --> 00:13:58,831
Now, if we put it inside the, as a
child glass of an eye worker, it'll

221
00:13:58,831 --> 00:14:02,971
have to implement forcefully the
functions of work, eat, and sleep.

222
00:14:03,091 --> 00:14:06,901
But it doesn't really do these
things, these latter things.

223
00:14:07,261 --> 00:14:08,701
It doesn't sleep, it doesn't eat.

224
00:14:09,271 --> 00:14:10,231
It only does the work.

225
00:14:11,231 --> 00:14:16,691
So forcing the robot to implement these
two functions is, or rather these two

226
00:14:16,691 --> 00:14:18,191
implementations from the interface.

227
00:14:18,801 --> 00:14:24,521
Is a forcefulness that will cause us
to write dirty code difficult to extend

228
00:14:24,521 --> 00:14:28,221
code and This just looks ugly over time.

229
00:14:28,631 --> 00:14:31,751
This is a very simple example But we go
into production quality code which has

230
00:14:31,841 --> 00:14:36,481
many functionalities spread over multiple
modules this immediately goes into an

231
00:14:36,481 --> 00:14:41,831
exponential explosion of having such Not
implemented function or not implemented

232
00:14:41,891 --> 00:14:46,531
exception or such cases where you
struggle to write basic unit test as well

233
00:14:47,081 --> 00:14:49,061
So an idea would be just break it out.

234
00:14:49,961 --> 00:14:54,121
Do not force a human worker and
robot worker to be extended from

235
00:14:54,121 --> 00:14:59,581
the same interface of worker rather
break it into a workable, eatable

236
00:14:59,641 --> 00:15:00,991
or sleepable kind of interface.

237
00:15:02,026 --> 00:15:06,596
A corrected example would look
like interface workable, interface

238
00:15:06,776 --> 00:15:10,256
eatable, interfaceable, where they
do respective work of work and sleep.

239
00:15:10,876 --> 00:15:14,476
And when we have a human workup, they
implement these three keys, which is

240
00:15:14,476 --> 00:15:16,006
workable, eatable, and slippable as well.

241
00:15:16,606 --> 00:15:21,426
But robot only does the work so it only
does the extension of workable interface

242
00:15:21,456 --> 00:15:22,866
and doesn't even test the other two.

243
00:15:24,136 --> 00:15:28,536
It ensures that we do not have unnecessary
dependency in our code as it goes up.

244
00:15:29,471 --> 00:15:33,661
And the problem is, or rather the
challenge is to figure out how to

245
00:15:33,661 --> 00:15:35,621
break down these functionalities.

246
00:15:36,201 --> 00:15:39,641
even though these examples are in C
sharp, because I work at Microsoft,

247
00:15:40,191 --> 00:15:46,121
Java in itself has done a commendable
job in breaking down these interfaces

248
00:15:46,151 --> 00:15:48,771
over the last approximately 10 years.

249
00:15:49,321 --> 00:15:54,241
Because earlier, if you see Java used
to have these forced interfaces, but

250
00:15:54,271 --> 00:15:58,351
now smaller functionalities are being
broken into individual interfaces.

251
00:15:58,781 --> 00:16:02,681
And if you can implement a serializability
of cloud, for example, it's an interface,

252
00:16:03,231 --> 00:16:05,841
I force to a lot more, but not anymore.

253
00:16:05,841 --> 00:16:09,621
So they're doing a really good job
in breaking down the interface.

254
00:16:09,621 --> 00:16:10,191
Segregation.

255
00:16:11,411 --> 00:16:15,801
moving on to the last one, which
is dependency in version principle.

256
00:16:16,771 --> 00:16:20,701
And here the idea is quite simple,
that you should depend on ab section

257
00:16:20,761 --> 00:16:23,301
and not con concrete implementations.

258
00:16:24,071 --> 00:16:26,621
And an example would
be, let's say you have.

259
00:16:27,066 --> 00:16:28,306
An IDE.

260
00:16:28,306 --> 00:16:29,536
I don't know which one you use.

261
00:16:29,566 --> 00:16:35,006
Let's say one from JetBrains or Eclipse
or Visual Studio Code or any of those.

262
00:16:35,366 --> 00:16:37,086
You install a bunch of plugins.

263
00:16:37,896 --> 00:16:41,326
Now, let's say there's a small
company, which has created a

264
00:16:41,326 --> 00:16:43,556
plugin for each of these IDEs.

265
00:16:44,366 --> 00:16:50,456
If tomorrow that company decides to
make changes to their implementation,

266
00:16:51,436 --> 00:16:53,236
would these, should the IDs break?

267
00:16:54,071 --> 00:16:55,031
Ideally not right.

268
00:16:55,261 --> 00:16:59,891
These big standard IDs should not be
breaking down because one small company

269
00:17:00,041 --> 00:17:05,381
decided to change their functionality
So if these IDEs depend on concrete

270
00:17:05,411 --> 00:17:10,191
implementation of that small companies
plug in dependencies Or implementation

271
00:17:10,771 --> 00:17:14,741
it would break down if they have a code
bug then all of these IDs break down

272
00:17:14,741 --> 00:17:16,981
which is Obviously not a good idea.

273
00:17:17,781 --> 00:17:24,081
Henceforth if these IDEs depend on the
abstractions or interfaces of those low

274
00:17:24,081 --> 00:17:28,931
level plugins in this example, a low
level module, small company plugins.

275
00:17:29,451 --> 00:17:33,371
In that case, if even if that
small company plugin has a bug,

276
00:17:33,891 --> 00:17:37,741
it itself would fail, but it would
not break down the entire IDE.

277
00:17:38,321 --> 00:17:39,731
And let's take an example over here.

278
00:17:40,691 --> 00:17:45,451
Here we have a customer service
which has an implementation or a

279
00:17:45,451 --> 00:17:47,831
usage of SQL customer repository.

280
00:17:48,431 --> 00:17:50,801
Now, today we are using customer service.

281
00:17:50,861 --> 00:17:53,961
which depends on SQL database,
let's say Oracle Postgres or

282
00:17:53,991 --> 00:17:55,891
any of those standard SQL one.

283
00:17:56,191 --> 00:18:01,941
But tomorrow your database grows super
big, your rate of scale goes crazy high

284
00:18:02,331 --> 00:18:07,581
and you decide SQL is not serving my use
case and you want to go to into NoSQL

285
00:18:08,621 --> 00:18:13,721
databases like DynamoDB, Mongo, Cassandra
or any of those many options available.

286
00:18:14,311 --> 00:18:18,691
You will have to come and change inside
the customer serve and if you do that.

287
00:18:19,491 --> 00:18:23,761
The chance of a bug getting introduced
because there was a bug in the

288
00:18:23,761 --> 00:18:27,371
new implementation, which breaks
down the customer service is high.

289
00:18:28,071 --> 00:18:31,541
How can we ensure that we do not
depend on the concrete implementation

290
00:18:31,541 --> 00:18:35,531
of SQL customer repository
inside the customer service?

291
00:18:36,411 --> 00:18:39,331
Let's look at the example and I'll
come back to the slide in a second.

292
00:18:40,841 --> 00:18:44,941
we have iCustomerRepository, which
deals with the database stuff.

293
00:18:45,631 --> 00:18:47,251
Today, it is using SQLCustomerRepository.

294
00:18:48,521 --> 00:18:53,501
Tomorrow we can create a DynamoDB
customer repository or a MongoDB or a

295
00:18:53,501 --> 00:18:57,761
Cassandra customer repository, which
extends from iCustomerRepository.

296
00:18:57,761 --> 00:19:01,501
So it deals with all the functions
of save, get, fetch, and whatever

297
00:19:01,511 --> 00:19:02,661
the databases have to do.

298
00:19:03,381 --> 00:19:06,651
The customer service class
only depends on the interface.

299
00:19:07,231 --> 00:19:10,391
It does not know about the low level
implementation of the iCustomerRepository

300
00:19:12,091 --> 00:19:13,351
if it is coming from iCustomerRepository.

301
00:19:13,711 --> 00:19:18,401
SQL repository, or it is coming
from Dynamo repository or any

302
00:19:18,401 --> 00:19:22,381
other database repository, it
is completely independent of it.

303
00:19:22,521 --> 00:19:25,571
So the chances of a low level
implementation breaking a high

304
00:19:25,571 --> 00:19:28,131
level implementation is super low.

305
00:19:28,131 --> 00:19:34,241
An analogy which we have on the screen
over here, a car engine shouldn't

306
00:19:34,241 --> 00:19:35,471
be directly related to chassis.

307
00:19:35,471 --> 00:19:40,345
They should be connected via standardized
interfaces like wires and electric cables.

308
00:19:40,345 --> 00:19:45,376
Because if you want to change the Engine,
you should not break down the entire car.

309
00:19:45,376 --> 00:19:49,046
You shouldn't be cutting into the
car and breaking down the chassis But

310
00:19:49,056 --> 00:19:55,036
simply take out the cables get the new
engine in and while it works, let me

311
00:19:55,036 --> 00:20:00,846
go back to the previous slide because
the This line is quite important

312
00:20:01,276 --> 00:20:04,166
abstraction should not depend on
details should depend on abstractions.

313
00:20:05,096 --> 00:20:09,356
What we mean by that is The dependency
of customer service shouldn't care

314
00:20:09,356 --> 00:20:13,896
about or depend on the lower level
Implementation details of the sql customer

315
00:20:13,896 --> 00:20:19,146
repository, which in this bad example,
we see it is Whereas if you go to the

316
00:20:19,556 --> 00:20:23,226
good example of the bad example, we
see that it depends only on interface

317
00:20:23,466 --> 00:20:27,806
customer repository Service depending
on the customer repository interface

318
00:20:27,966 --> 00:20:32,056
and it doesn't care about the low level
implemented Which is a better way of

319
00:20:32,486 --> 00:20:37,661
doing this or You more modular, slightly
flexible way off implementing this.

320
00:20:38,231 --> 00:20:41,321
So this is all about the
solid design principles.

321
00:20:42,201 --> 00:20:45,741
Now we're going to talk about a couple of
case studies and then some so even though

322
00:20:45,751 --> 00:20:50,101
we have written e commerce platform who
overhaul, I've used example of Amazon,

323
00:20:50,551 --> 00:20:54,911
which is, which I have anonymized and
completely removed all the details.

324
00:20:55,311 --> 00:20:57,131
So we know Amazon started in 1994 as us.

325
00:20:57,811 --> 00:21:00,411
Small company, which are selling
books on the internet back.

326
00:21:00,411 --> 00:21:03,781
Then obviously it was a small company
the software code base and even the

327
00:21:03,781 --> 00:21:05,161
technology stack was super small.

328
00:21:05,461 --> 00:21:12,951
It was a monolithic platform, but as it
caught up as internet got more accessible

329
00:21:12,951 --> 00:21:18,801
to the folks worldwide The demand and
the usage of that platform grew in size

330
00:21:19,321 --> 00:21:23,941
And back then the tight company between
different components made it risky and

331
00:21:23,961 --> 00:21:29,616
time consuming, of course To grow and
add more features which Obviously led

332
00:21:29,636 --> 00:21:33,756
to many bugs over time and there are
many internet available or publicly

333
00:21:33,756 --> 00:21:38,046
available case studies about amazon
went down During the late 90s and

334
00:21:38,076 --> 00:21:43,996
early 2000 And they were a result of
this tight coupling and not following

335
00:21:43,996 --> 00:21:47,686
solid per se so What did they do?

336
00:21:48,246 --> 00:21:51,696
They adopted solid principles, even though
they were not necessarily known as solid

337
00:21:51,706 --> 00:21:56,796
back in the day we broke down The bigger
components to smaller codebases, for

338
00:21:56,796 --> 00:22:00,106
example, product catalog, auto management,
payment processing, so on and so forth

339
00:22:00,646 --> 00:22:06,256
even offer because it's a marketplace many
merchants come and place their bids to

340
00:22:06,276 --> 00:22:11,706
sell their items on the amazon home page
we also followed the open close principle

341
00:22:11,876 --> 00:22:15,466
where we ensure that pluggable payment
gateways could be added Now if today

342
00:22:15,466 --> 00:22:20,166
you go to amazon earlier, it was only a
credit card But today you can add credit

343
00:22:20,166 --> 00:22:24,911
card different bank online mechanisms,
and if you go to different countries

344
00:22:24,911 --> 00:22:27,061
have different mechanisms to pay.

345
00:22:27,611 --> 00:22:32,421
some also offer the feature of, throw
away cards, also one time use cards.

346
00:22:32,781 --> 00:22:35,561
And also cash on delivery, for
example, a card on delivery.

347
00:22:36,371 --> 00:22:41,091
Now imagine if the team had to implement
all of these new payment mechanism

348
00:22:41,221 --> 00:22:44,051
each time A new feature was added.

349
00:22:44,241 --> 00:22:48,111
They would be just spending all the
time in dealing with bugs But since

350
00:22:48,111 --> 00:22:51,581
they use the open close principle, they
were simply adding new implementations

351
00:22:52,031 --> 00:22:57,061
without touching the older ones so open
to extension but close for modification

352
00:22:58,301 --> 00:23:02,031
and the lsp the list of substitution
is because You We also ensure that

353
00:23:02,101 --> 00:23:06,101
most of the components which are at
higher level could be replaced without

354
00:23:06,101 --> 00:23:09,841
breaking down the system So we create
a bunch of interfaces instead of

355
00:23:09,841 --> 00:23:11,571
directly depending on the payments.

356
00:23:11,671 --> 00:23:15,351
We depend on the payment interface
And the lower level implementation of

357
00:23:15,361 --> 00:23:19,801
payment would just change according
to the marketplace or the country isp,

358
00:23:20,281 --> 00:23:25,496
interface segregation, obviously we It
was the dependency flow of the control

359
00:23:25,506 --> 00:23:29,676
flow of a lot of low level components
than the high level components.

360
00:23:29,676 --> 00:23:33,616
And we saw in some of the examples
earlier, the last one, which is

361
00:23:33,616 --> 00:23:36,026
decoupling high level business
logic from low level interest.

362
00:23:37,196 --> 00:23:41,296
infrastructure concern, we just saw
an example of database access and the

363
00:23:41,296 --> 00:23:45,666
example I use is a real one because
amazon When it started was dependent on

364
00:23:46,016 --> 00:23:50,956
sql databases specifically from oracle,
but as the company grew they Created

365
00:23:50,956 --> 00:23:56,906
their own no sql and sql databases
which were which offers, today, postgres

366
00:23:57,136 --> 00:24:03,196
based apis and also dynamo db, which is
world famous on AWS So different APIs

367
00:24:03,456 --> 00:24:09,636
could be used from these two type of
different databases, SQL and non SQL.

368
00:24:09,636 --> 00:24:13,396
But the high level logic doesn't really
care about it and shouldn't care about it.

369
00:24:14,036 --> 00:24:14,786
And it works.

370
00:24:14,976 --> 00:24:17,366
We have seen the results.

371
00:24:18,926 --> 00:24:23,036
We obviously reduced bugs
count by a significant number.

372
00:24:23,606 --> 00:24:27,336
The development increased, the
development time and the speed and

373
00:24:27,336 --> 00:24:31,476
efficiency increased by a factor
of what we have on the screen.

374
00:24:31,476 --> 00:24:31,726
Thanks.

375
00:24:32,166 --> 00:24:36,826
And also it makes the developer's life
slightly easy and happier to not deal

376
00:24:36,856 --> 00:24:41,096
with the bugs and be able to work on
the new features at a reasonable speed.

377
00:24:42,816 --> 00:24:47,426
now with this modern software development
with the everything being on the cloud and

378
00:24:47,626 --> 00:24:52,206
with this new AI way of catching up around
the world, the same concept still applies.

379
00:24:52,256 --> 00:24:58,566
As I said earlier, they're not bound to
object oriented or couple of technology.

380
00:24:58,866 --> 00:25:02,626
It's just a basic logic or basic
framework for developing software pieces.

381
00:25:03,346 --> 00:25:07,226
So today we have microservices a
lot and we're going into serverless

382
00:25:07,226 --> 00:25:11,796
where we're putting our microservice
components on to a serverless component

383
00:25:11,836 --> 00:25:15,586
like lambda and function app on azure.

384
00:25:15,596 --> 00:25:21,096
So lambda on AWS and function app
on azure, keeping those services

385
00:25:21,126 --> 00:25:26,396
and components or functions or
lambdas separate and just making them

386
00:25:26,756 --> 00:25:28,766
making sure that they do one work.

387
00:25:29,466 --> 00:25:33,426
Effectively is how we can use
single responsibility and some

388
00:25:33,426 --> 00:25:37,056
of these principles that we have
learned along the way, on the cloud.

389
00:25:37,096 --> 00:25:42,206
And in this new age, Microsoft's
architecture, we Also, now held

390
00:25:42,236 --> 00:25:47,326
by AI, OpenAI specifically, how it
helps with our Agile, because since

391
00:25:47,326 --> 00:25:50,376
we are building smaller components,
we are keeping things small.

392
00:25:50,866 --> 00:25:53,746
We are keeping the dependency
between different components small.

393
00:25:53,796 --> 00:25:55,266
It also helps with agility.

394
00:25:55,516 --> 00:25:59,656
It helps us in moving
faster in a better way.

395
00:25:59,656 --> 00:26:01,286
And we are able to get our.

396
00:26:01,696 --> 00:26:05,796
Entire dependency cycle of code
development, testing, deploying into

397
00:26:05,796 --> 00:26:10,486
production, testing that feature, coming
back, adding more in a reasonable way

398
00:26:10,566 --> 00:26:14,596
rather than a older way of being less
agile in a waterfall that we had to

399
00:26:14,676 --> 00:26:20,786
develop a lot before we could even test
and it could easily be iterated upon

400
00:26:20,806 --> 00:26:23,646
and automated using CI and CD pipelines.

401
00:26:24,476 --> 00:26:28,496
I said, since we are developing
components in a smaller fashion,

402
00:26:28,906 --> 00:26:31,436
the testability gets better.

403
00:26:31,566 --> 00:26:33,266
The results of the tests gets better.

404
00:26:33,656 --> 00:26:37,716
Writing unit has become super easy
because, instead of writing a unit

405
00:26:37,716 --> 00:26:40,396
as which takes five functions or
five functionalities inside one

406
00:26:40,396 --> 00:26:42,136
module, we just have to test one.

407
00:26:42,706 --> 00:26:48,706
It also helps in other modern technology
frameworks like TDD or methodologies,

408
00:26:48,706 --> 00:26:50,316
rather TDD test driven framework.

409
00:26:50,316 --> 00:26:50,376
Thank you.

410
00:26:51,106 --> 00:26:55,676
Test driven development because if you are
developing and testing a smaller function

411
00:26:56,746 --> 00:27:00,806
You're getting a result right away instead
of writing big functions and then big unit

412
00:27:00,816 --> 00:27:05,956
tests Which makes the tdd adaptability
a bit more difficult and since we're

413
00:27:05,956 --> 00:27:12,533
able to test and iterate better just
that Feature enables or the flexibility

414
00:27:12,533 --> 00:27:16,066
enables us to make our deployment
more elaborate and less error prone.

415
00:27:17,886 --> 00:27:21,796
Now, let's talk about Common field of
pitfalls and miscomption what generally

416
00:27:21,806 --> 00:27:25,421
happens is with soft engineering like
us We learn something and then we

417
00:27:25,491 --> 00:27:27,471
immediately get tempted to go and use it.

418
00:27:27,851 --> 00:27:32,021
So don't force it Don't try
to put solid into everything.

419
00:27:32,751 --> 00:27:36,491
it should come naturally Or try to
question yourself every time you're

420
00:27:36,511 --> 00:27:40,581
developing or designing a new feature
or even refactoring an older one Is

421
00:27:40,581 --> 00:27:47,321
there a way to make it simpler and if
your code base is really easy and simple

422
00:27:47,531 --> 00:27:48,821
And it doesn't give you any problem.

423
00:27:48,991 --> 00:27:51,911
Let it be don't fix what isn't broken.

424
00:27:53,741 --> 00:27:55,921
Sometimes we try to do
premature optimization.

425
00:27:56,621 --> 00:28:02,891
don't don't create unnecessary abstraction
interfaces don't have 10 classes

426
00:28:03,441 --> 00:28:07,621
Doing one function each and having 10
interfaces on top of it and that can

427
00:28:07,621 --> 00:28:11,811
just have a simple class It doesn't make
any sense to create One interface and

428
00:28:11,811 --> 00:28:16,626
one class just for one functionality,
which will never ever change and As

429
00:28:16,626 --> 00:28:20,316
I have said multiple times, SOLID is
not for object oriented programming.

430
00:28:20,636 --> 00:28:23,056
It's basically fundamental
software designing.

431
00:28:23,416 --> 00:28:24,506
It has nothing to do with object.

432
00:28:24,516 --> 00:28:27,216
It's just a badly marketed sales gimmick.

433
00:28:27,556 --> 00:28:30,426
Just use the concepts of loose
coupling, high cohesion, and

434
00:28:30,426 --> 00:28:34,626
flexibility everywhere in software
design and development as well.

435
00:28:35,716 --> 00:28:39,826
in conclusion, the key takeaways for us
are that SOLID principles are not just

436
00:28:39,826 --> 00:28:44,216
theoretical concepts, but practical
tools in ensuring our software is easily

437
00:28:44,216 --> 00:28:45,946
extensible, adaptable, and scalable.

438
00:28:46,441 --> 00:28:51,171
Continues to stay robust and by using
solid net data software development.

439
00:28:51,181 --> 00:28:55,511
We can create code bases which
are Doubling I believe every

440
00:28:55,521 --> 00:28:56,821
year one point less than 1.

441
00:28:56,861 --> 00:28:58,951
5 years it's easier.

442
00:28:58,971 --> 00:29:04,481
They are easy to understand and modify
and extend by our Fellow soft engineers

443
00:29:04,511 --> 00:29:09,151
and ourselves in the future And as we
use this since we are able to write

444
00:29:09,171 --> 00:29:14,711
better code And better test along with
the code and cicd pipeline It is ensuring

445
00:29:14,711 --> 00:29:19,711
that we are keeping our tech debt To
a lower number avoiding it is again

446
00:29:19,711 --> 00:29:23,841
a myth cannot avoid all the tech debt
All we can do is strive to keep it low

447
00:29:23,841 --> 00:29:28,821
as possible And so in summary whether
you're building cloud native app working

448
00:29:28,821 --> 00:29:35,731
in agile environment or in devops or
in Non cloud on prem device situation.

449
00:29:36,041 --> 00:29:39,501
It doesn't matter you can use solid
to build a solid foundation for

450
00:29:39,501 --> 00:29:43,761
success for your software And empower
your customers to use your software

451
00:29:43,801 --> 00:29:47,121
without worrying about day to day
debugging and getting stuck up into

452
00:29:47,871 --> 00:29:50,601
unnecessary Tight couple software.

453
00:29:51,061 --> 00:29:53,451
So with that, thank you very much.

454
00:29:53,751 --> 00:29:57,761
These are my details and happy
to see you guys Thank you

