1
00:00:15,110 --> 00:00:15,790
Hello everyone.

2
00:00:15,960 --> 00:00:16,950
My name is Arvind Kumar.

3
00:00:17,390 --> 00:00:20,600
I work as a staff software
engineer in Guaranteed Write.

4
00:00:21,150 --> 00:00:23,550
I work mainly on Java
and cloud technologies.

5
00:00:24,180 --> 00:00:27,540
My talk today is on empowering
digital transformations using

6
00:00:27,540 --> 00:00:28,860
cloud and java technologies.

7
00:00:29,340 --> 00:00:29,900
Let's start

8
00:00:30,410 --> 00:00:34,100
So this is my agenda today where
we talk about synergy between

9
00:00:34,100 --> 00:00:38,760
cloud and java features Overview
of both the technologies.

10
00:00:38,920 --> 00:00:43,170
We see what is serverless
and CI CD pipelines.

11
00:00:43,219 --> 00:00:49,850
We'll have a demo and we have the summary
introduction The cloud services, so

12
00:00:49,880 --> 00:00:53,510
the cloud technologies, this represents
a transformation approach where

13
00:00:53,680 --> 00:00:55,770
we manage and deliver IT services.

14
00:00:56,169 --> 00:00:58,410
So this is by providing
the on demand access.

15
00:00:59,030 --> 00:01:03,780
To all the IT resources such
as servers the storage like S3

16
00:01:04,270 --> 00:01:08,310
or the storage storage and the
databases over the internet, right?

17
00:01:08,750 --> 00:01:13,070
So traditional approach was we
earlier read before cloud computing,

18
00:01:13,300 --> 00:01:17,450
the IT infrastructure it requires
a lot of upfront investment.

19
00:01:17,725 --> 00:01:21,595
We need to first decide what, how many
servers we need and everything, right?

20
00:01:21,865 --> 00:01:24,655
And then we need to, we used to
build the applications, right?

21
00:01:25,055 --> 00:01:27,165
So in cloud computing,
we can decrease that.

22
00:01:27,700 --> 00:01:31,190
So we can start small and over
time we can increase, right?

23
00:01:31,450 --> 00:01:35,310
So this advantage this is giving a
big benefit to the organizations which

24
00:01:35,310 --> 00:01:39,210
are leveraging this flexibility and
efficiency of using the cloud computing.

25
00:01:41,160 --> 00:01:43,290
So Java role in modern
software development.

26
00:01:43,645 --> 00:01:45,965
We have the java's philosophy, right?

27
00:01:46,015 --> 00:01:49,085
One of the main pillar is
portability where you write one

28
00:01:49,095 --> 00:01:53,095
java application and you can run it
anywhere where we have a jvm, right?

29
00:01:53,105 --> 00:01:55,945
You can run the application in
java, you can write an application

30
00:01:55,945 --> 00:02:01,265
in windows take the class file or
bytecode and you can run in any of

31
00:02:01,265 --> 00:02:04,045
the jvms like in linux or mac os.

32
00:02:04,740 --> 00:02:06,110
You can get the same output.

33
00:02:06,320 --> 00:02:10,349
So this portability is one of the main
features and there are very robust

34
00:02:10,349 --> 00:02:15,539
frameworks for java applications like
where we have a Spring Boot, Micronaut.

35
00:02:16,099 --> 00:02:19,139
Here we can simply develop
scalable applications which are

36
00:02:19,309 --> 00:02:20,849
having high performance, right?

37
00:02:21,309 --> 00:02:25,959
So the TIOB index this is the indicator
where we can gauge a programming language.

38
00:02:26,289 --> 00:02:31,429
So the java is consistently high in this
and the, Java has been the preferred

39
00:02:31,429 --> 00:02:33,059
choice by enterprise applications.

40
00:02:33,069 --> 00:02:37,069
The reasons is behind the extensive
library support and the community support.

41
00:02:39,019 --> 00:02:44,859
So if you see the cloud and Java growth we
talked about it just now the reasons why

42
00:02:44,909 --> 00:02:49,069
cloud computing are being very adaptive
for the business and organizations.

43
00:02:49,769 --> 00:02:52,889
This has become the backbone
of the digital transformation.

44
00:02:53,844 --> 00:02:56,514
And enabling the business to
scale they can innovate more

45
00:02:56,944 --> 00:03:01,014
because they can optimize the
cost like never before, right?

46
00:03:01,414 --> 00:03:06,654
So based on this, there are staggering
numbers of the future prediction,

47
00:03:07,034 --> 00:03:09,674
like we are reaching about 832.

48
00:03:09,675 --> 00:03:10,094
1 billion.

49
00:03:11,044 --> 00:03:14,664
The global cloud computing
market is going to reach 832.

50
00:03:14,665 --> 00:03:18,174
1 billion and the growth
rate is around 17.

51
00:03:18,175 --> 00:03:18,984
5 percent annually.

52
00:03:19,949 --> 00:03:23,649
This reflects that business how the
business are relying on cloud computing

53
00:03:24,059 --> 00:03:25,949
for their operational and strategic needs.

54
00:03:27,719 --> 00:03:30,849
So here we'll talk about
Java's endurance relevance.

55
00:03:31,349 --> 00:03:32,459
Enduring relevance.

56
00:03:32,789 --> 00:03:36,269
So simultaneously, Java is going
to be the cornerstone of the

57
00:03:36,269 --> 00:03:37,669
software development ecosystem.

58
00:03:38,089 --> 00:03:41,769
Even though this is very old
programming language, we still see

59
00:03:41,769 --> 00:03:45,549
that enterprise environments are
being using Java because of the robust

60
00:03:45,549 --> 00:03:50,789
ecosystem, the platform independence
philosophy, and it can be seamlessly

61
00:03:50,799 --> 00:03:52,709
integrated with multiple other systems.

62
00:03:52,999 --> 00:03:55,849
They have a lot of support
for Java based libraries.

63
00:03:55,869 --> 00:03:58,299
So the synergy between
both Java and cloud.

64
00:03:58,694 --> 00:04:02,914
We'll see we have a lot of other things
we just now talked about scalability

65
00:04:02,934 --> 00:04:06,764
and portability, so we'll see how
how it actually works here, right?

66
00:04:07,224 --> 00:04:11,804
So when we say scalability cloud have
something called as auto scaling option.

67
00:04:12,164 --> 00:04:16,794
Where the ability to automatically
scale based on demand, we can

68
00:04:16,794 --> 00:04:19,264
do easily in cloud, right?

69
00:04:19,664 --> 00:04:24,724
And similarly in Java, we have multi
threading concept, which is a very high

70
00:04:24,724 --> 00:04:30,644
performance where Java can handle many
users at same point of time, right?

71
00:04:30,914 --> 00:04:31,714
How it handles?

72
00:04:31,714 --> 00:04:36,024
It has something magical called garbage
collection mechanism where any Java

73
00:04:36,034 --> 00:04:38,154
application, if there are unused objects.

74
00:04:38,574 --> 00:04:43,284
Or unused items it automatically
deallocates the memory for other requests.

75
00:04:43,704 --> 00:04:49,294
To happen right whereas in c and c plus
you need to do it manually in java jvm It

76
00:04:49,304 --> 00:04:55,994
does automatically so the cloud elasticity
is nothing but how the All the cloud

77
00:04:56,664 --> 00:05:01,344
providers said how they do auto scaling
It will be explained in a few minutes.

78
00:05:03,154 --> 00:05:08,324
So here we take an example of e commerce
application, how it handles huge traffic

79
00:05:08,324 --> 00:05:10,084
surges during holiday seasons, right?

80
00:05:10,594 --> 00:05:14,084
Automatically they can increase the
number of then the number of replicas they

81
00:05:14,084 --> 00:05:19,294
need for the application to handle the
request for that increased traffic, right?

82
00:05:19,664 --> 00:05:23,284
So once the traffic is down, then
we can automatically decrease the

83
00:05:23,304 --> 00:05:27,074
config parameters so that you don't
have, you can decrease the cost.

84
00:05:27,674 --> 00:05:29,154
without even manual intervention.

85
00:05:31,064 --> 00:05:37,204
So here we, in this depiction, we
show how autoscaling is handled using,

86
00:05:37,214 --> 00:05:42,104
we have a load balancer, we have two
nodes and Route 53 and we have the

87
00:05:42,104 --> 00:05:45,704
load balancer which handles the traffic
request, it goes to the applications.

88
00:05:46,194 --> 00:05:48,104
We have three Java
instances in the right side.

89
00:05:49,534 --> 00:05:52,894
We'll see the features and the
overview of both cloud and Java here.

90
00:05:54,019 --> 00:05:58,029
So we briefly talked about the
philosophy, write once, run anywhere.

91
00:05:58,499 --> 00:06:03,309
Similarly, this kind of philosophy is
going to complement when we use cloud.

92
00:06:03,889 --> 00:06:08,399
Because we write a Java application,
has the right ones, run anywhere

93
00:06:08,399 --> 00:06:12,239
philosophy is there, you can run in
any of the cloud platforms, right?

94
00:06:12,629 --> 00:06:16,599
You like this increase the
redundancy and cost optimization.

95
00:06:16,609 --> 00:06:21,099
You can deploy the same Java
application in AWS and GCP as well.

96
00:06:21,649 --> 00:06:25,239
So there is one example which we
are talking here about a financial

97
00:06:25,239 --> 00:06:29,309
institution which uses both AWS
and cloud platform for redundancy.

98
00:06:29,819 --> 00:06:33,419
And the core principle of Java is
write once run anywhere, right?

99
00:06:33,439 --> 00:06:34,749
So this is going to complement it.

100
00:06:36,659 --> 00:06:40,039
Here we are seeing the portability
in both Java and cloud.

101
00:06:40,539 --> 00:06:44,229
We have one AWS cloud where we
have a Java application deployed.

102
00:06:44,659 --> 00:06:47,139
We have Google cloud and also the Azure.

103
00:06:47,139 --> 00:06:47,159
Okay.

104
00:06:47,569 --> 00:06:49,589
All of them are having
the same java application

105
00:06:50,139 --> 00:06:54,679
Going next we have the next feature
which is resilient this ensures

106
00:06:54,679 --> 00:06:58,139
the highly availability and fault
allowance of the cloud services, right?

107
00:06:58,419 --> 00:07:03,019
So in cloud platforms This is
inherently built how it build we'll see.

108
00:07:03,119 --> 00:07:07,349
We'll see some examples so java
platforms when they combine with

109
00:07:07,349 --> 00:07:11,629
cloud native architecture, we
can get the Design features like

110
00:07:11,629 --> 00:07:15,964
automatical recovery from failures
handle unexpected surges in demand.

111
00:07:16,534 --> 00:07:19,354
It automatically increases the
number of lift costs we need based

112
00:07:19,354 --> 00:07:21,404
on the incoming traffic, right?

113
00:07:21,854 --> 00:07:23,444
And cloud enabled resilience.

114
00:07:23,534 --> 00:07:30,994
This is using the regional failover and
auto restarts and backing up the systems.

115
00:07:31,324 --> 00:07:36,364
Whenever there is a Java based
application is deployed in AWS or

116
00:07:36,364 --> 00:07:39,714
Kubernetes, it can take the advantage
of all these features and self heal.

117
00:07:41,084 --> 00:07:45,474
Similarly, in Java, we have a strongest,
robust application programming language

118
00:07:45,854 --> 00:07:50,334
where we can do exception handling in a
very great manner and we have a lot of

119
00:07:50,334 --> 00:07:52,894
support for logging frameworks like log4j.

120
00:07:53,354 --> 00:07:56,374
In Spring Boot also we can have we
can integrate with a lot of other

121
00:07:56,384 --> 00:08:00,154
tools like Kibana and Elasticsearch
where we can debug the issues.

122
00:08:01,564 --> 00:08:06,184
We can also also use Grafana for
alerting whenever we have a, let's

123
00:08:06,184 --> 00:08:09,754
say there are 500 when we are
getting 500 exceptions, right?

124
00:08:09,784 --> 00:08:14,364
We can handle it if there are three,
500 errors in a particular timeframe.

125
00:08:14,529 --> 00:08:17,659
In we can raise our alert to
the servicing team, right?

126
00:08:18,109 --> 00:08:20,689
So those kind of things we
can do here in the logging.

127
00:08:21,139 --> 00:08:26,129
Similarly, in AWS side, we have
in cloud side, we have AWS,

128
00:08:26,249 --> 00:08:28,239
Azure, and Google Cloud logging.

129
00:08:28,889 --> 00:08:31,549
We can have, we can monitor
this and combine it.

130
00:08:31,619 --> 00:08:35,639
It makes a very resilient application,
the combination of both cloud

131
00:08:35,639 --> 00:08:36,769
and Java applications, right?

132
00:08:37,129 --> 00:08:39,139
So here we have a healthcare application.

133
00:08:39,494 --> 00:08:41,234
which is running 24 by 7.

134
00:08:41,304 --> 00:08:45,084
So here we have this has been deployed
in multiple geographic locations.

135
00:08:45,444 --> 00:08:49,494
So this is going to be resilient
application by default.

136
00:08:49,754 --> 00:08:53,844
If you're using cloud you don't have
to do anything manually because it

137
00:08:53,844 --> 00:08:57,104
will take care automatically where you
have, you can see here in the example.

138
00:08:58,634 --> 00:09:01,944
US East, it has been deployed
to services and invest.

139
00:09:02,174 --> 00:09:05,434
If there is any problem, the,
with the failover will happen

140
00:09:05,804 --> 00:09:06,824
without manual intervention.

141
00:09:08,404 --> 00:09:12,514
Similarly, we are seeing the diagram
here on the exception handling, how we

142
00:09:12,514 --> 00:09:17,804
are going to handle the AWS CloudWatch
and we can watch the CloudTrail to

143
00:09:17,804 --> 00:09:19,694
see what are the exceptions happening.

144
00:09:20,244 --> 00:09:22,124
So we talked about this, right?

145
00:09:22,144 --> 00:09:24,854
This is nothing but cloud
cross cloud deployment scenario

146
00:09:25,224 --> 00:09:28,134
where we can deploy the java
application multiple clouds, right?

147
00:09:28,364 --> 00:09:33,514
So If you see that in real world
scenario, we can adapt this multi cloud

148
00:09:33,564 --> 00:09:35,254
strategy for below reasons, right?

149
00:09:35,684 --> 00:09:38,454
So one thing is we can avoid vendor lock.

150
00:09:38,494 --> 00:09:41,674
We don't have to stick for one
particular vendor for a long time, right?

151
00:09:42,104 --> 00:09:46,119
And also This will enhance the
resilience to geo redundancy.

152
00:09:46,329 --> 00:09:51,509
How it happens is let's say we have outage
on one particular vendor on one particular

153
00:09:51,509 --> 00:09:54,219
Google let's say, cloud platform.

154
00:09:54,704 --> 00:09:58,344
We don't have to stick to that so that
impact will be completely impacted.

155
00:09:58,704 --> 00:10:02,774
If you deploy the same application
in cross cloud deployment scenario,

156
00:10:03,124 --> 00:10:07,804
we'll have that advantage of having
the redundancy for this, so we'll

157
00:10:07,804 --> 00:10:11,954
having a backup on other cloud platform
or application will be available

158
00:10:12,714 --> 00:10:16,084
through even though there is an
outage on the current platform, right?

159
00:10:16,524 --> 00:10:21,374
And the Java's role in cross cloud,
the same philosophy, Vora philosophy

160
00:10:21,374 --> 00:10:25,134
makes it like very advantageous
where we have the same application

161
00:10:25,144 --> 00:10:29,784
being deployed in different clusters
using Docker and Kubernetes.

162
00:10:30,024 --> 00:10:34,604
We will see that example in few
minutes on how we can containerize

163
00:10:34,604 --> 00:10:36,624
an application and deploy it in K8.

164
00:10:39,164 --> 00:10:44,784
And below the steps how we will develop
it in Spring Boot we will deploy we'll

165
00:10:44,814 --> 00:10:49,204
containerize, package this complete
application using Docker and we'll

166
00:10:49,204 --> 00:10:53,414
ensure it runs consistently with
other, with across the environments

167
00:10:53,714 --> 00:10:55,374
and we deploy this in Kubernetes.

168
00:10:58,219 --> 00:11:01,849
So the here we talk about
this in an with an example.

169
00:11:02,199 --> 00:11:06,769
So let's say we have a big retail company
which is running in North America and

170
00:11:06,769 --> 00:11:08,689
also in European operations, right?

171
00:11:09,129 --> 00:11:13,499
So here we wanted, we are choosing two
different platforms, AWS and Google Cloud.

172
00:11:14,039 --> 00:11:17,949
So by using this we can deploy it in
both different cloud platforms, which

173
00:11:17,989 --> 00:11:20,369
enables the cloud, cross cloud deployment.

174
00:11:21,339 --> 00:11:22,859
So there is no vendor lock here.

175
00:11:22,899 --> 00:11:24,829
We don't need to be tied
to a particular vendor.

176
00:11:25,109 --> 00:11:28,039
Resilience and redundancy
is happening here.

177
00:11:28,449 --> 00:11:30,849
Even though there is an
outage, we don't have to worry.

178
00:11:31,339 --> 00:11:34,679
And cost is optimized based on
whenever there is, let's say there

179
00:11:34,679 --> 00:11:36,219
is an offer on European side.

180
00:11:36,709 --> 00:11:38,859
So the customer can take that advantage.

181
00:11:41,169 --> 00:11:43,509
Here this depiction shows how it happens.

182
00:11:43,569 --> 00:11:48,169
Docker Hub and we have two different
regions with two different cloud platforms

183
00:11:48,169 --> 00:11:50,209
deployed in same Java application.

184
00:11:50,219 --> 00:11:52,969
Let's see the overview.

185
00:11:53,089 --> 00:11:57,089
So we have AWS, Microsoft, and GCP.

186
00:11:57,089 --> 00:12:01,429
Each of them are master
in their own features.

187
00:12:02,139 --> 00:12:07,389
Most of them are common but Google
is specialized in big data, machine

188
00:12:07,389 --> 00:12:08,769
learning, and data analytics.

189
00:12:09,099 --> 00:12:13,599
Same goes with Microsoft and Amazon
has been a leading cloud provider

190
00:12:13,799 --> 00:12:17,729
with a lot of extensive global
support and advanced features.

191
00:12:19,299 --> 00:12:22,699
In coming to microservice architecture,
this is an architecture style where

192
00:12:23,159 --> 00:12:27,609
one big application can be composed
to several independent tasks, right?

193
00:12:28,459 --> 00:12:29,829
Which can be accessed over network.

194
00:12:30,139 --> 00:12:35,159
So if we do comparing to monolithic
architecture and microservices, we

195
00:12:35,159 --> 00:12:36,409
have the following advantages, right?

196
00:12:36,469 --> 00:12:37,789
We have scalability.

197
00:12:38,074 --> 00:12:42,794
flexibility and fault tolerance fault
solution, where we can take one example

198
00:12:42,804 --> 00:12:47,614
where like if one of the active, one
of these small activities failing

199
00:12:47,614 --> 00:12:51,744
in monolithic architecture, entire
application is going to be down whereas

200
00:12:52,104 --> 00:12:55,164
let's say we are running a report
and it is in monolithic architecture,

201
00:12:55,174 --> 00:12:59,944
because of that there might be Lock on
the db and it might impact the entire

202
00:12:59,944 --> 00:13:02,334
application whereas in microservice.

203
00:13:02,364 --> 00:13:04,384
We don't have to worry about it, right?

204
00:13:04,384 --> 00:13:08,704
The reporting or any wire transfer or
any kind of banking activity, right?

205
00:13:08,734 --> 00:13:13,424
Everything can be divided into
small independent service And one

206
00:13:13,424 --> 00:13:16,664
service if there is a failure, it
won't impact the other services.

207
00:13:16,774 --> 00:13:21,454
So that's where we get this fault
isolation And we have a flexibility,

208
00:13:21,454 --> 00:13:26,274
let's say, there are more number of
users using a particular service.

209
00:13:26,574 --> 00:13:30,874
We can scale up that particular
service, so we achieve flexibility

210
00:13:30,894 --> 00:13:32,234
and scalability using that.

211
00:13:35,164 --> 00:13:39,064
And using Spring Boot, we can
create these kind of applications

212
00:13:39,064 --> 00:13:40,934
very easily, within no time.

213
00:13:43,764 --> 00:13:46,664
Yeah, we talk about we're going to
talk about serverless computing.

214
00:13:47,049 --> 00:13:54,159
Here serverless computing is we run the
code and based on the two events without

215
00:13:54,159 --> 00:13:56,919
even managing Or provisioning the servers.

216
00:13:56,919 --> 00:14:01,369
We don't we'll not have any server, but
we can run the code using so that's the

217
00:14:01,369 --> 00:14:02,949
reason it's called serverless computing.

218
00:14:03,339 --> 00:14:05,679
One good example is aws lambda, right?

219
00:14:05,959 --> 00:14:10,919
We can execute a java code or python code
Based on the events or a hdb request.

220
00:14:11,149 --> 00:14:14,499
So I can take an example here, right?

221
00:14:14,509 --> 00:14:19,429
So let's say if you're using aws dynamo
db lambda as your database server So

222
00:14:19,459 --> 00:14:24,859
let's say for every new user login you
want to do some reporting stuff you want

223
00:14:24,869 --> 00:14:30,419
to update something on when did this
user log in or any other extra reporting

224
00:14:30,479 --> 00:14:32,349
kind of activities from the backend.

225
00:14:32,809 --> 00:14:36,669
So you can enable a database
stream and we can create a Lambda.

226
00:14:36,699 --> 00:14:41,139
You can do the business logic there
and we can store that in an RDS.

227
00:14:42,974 --> 00:14:46,994
So that's one of the example where
you can use this without no need

228
00:14:46,994 --> 00:14:48,774
to worry about the infrastructure.

229
00:14:48,864 --> 00:14:51,654
We just focus on the
business logic, right?

230
00:14:52,024 --> 00:14:55,864
And it is very cost effective because
we don't need to worry about it because

231
00:14:55,924 --> 00:14:57,959
cloud provider is going Take care of this

232
00:15:00,119 --> 00:15:01,519
C and CD integration.

233
00:15:01,519 --> 00:15:04,939
So this is one of the primary thing
which is going which is happening

234
00:15:04,939 --> 00:15:08,169
in all the organizations where
we have cloud and Java services.

235
00:15:08,399 --> 00:15:12,539
So the, this benefits faster
development and quality.

236
00:15:12,949 --> 00:15:14,299
We'll see how it happens, right?

237
00:15:14,379 --> 00:15:16,359
So there are many tools like Jenkins.

238
00:15:16,639 --> 00:15:20,359
So they can let's see the definition
C and CD stands for continuous

239
00:15:20,379 --> 00:15:22,039
integration and continuous deployment.

240
00:15:22,389 --> 00:15:25,639
So this practice enabled frequent
code changes and deployments for your.

241
00:15:26,139 --> 00:15:26,989
Git repos, right?

242
00:15:27,569 --> 00:15:29,259
Let's go to the old example.

243
00:15:29,269 --> 00:15:34,419
We have whenever there is a new change In
our traditional approach we used to create

244
00:15:34,419 --> 00:15:39,709
a bill and we used to manually deploy it
In a server on a particular day and let's

245
00:15:39,709 --> 00:15:43,699
say if you want to do it on Production,
let's say you have eight nodes.

246
00:15:43,939 --> 00:15:46,099
You need to do everything manually, right?

247
00:15:46,409 --> 00:15:51,559
So after cloud computing and integrating
with ca and cd whenever the developer

248
00:15:51,559 --> 00:15:56,064
changes the code You An automatical
build can be triggered using Jenkins,

249
00:15:56,824 --> 00:16:01,984
and it can be zilli integrated to gida,
GitLab which automatically builds the

250
00:16:01,984 --> 00:16:07,464
application and deploys it in a particular
environment, let's say dev or qa, right?

251
00:16:08,014 --> 00:16:09,934
This will improve the
faster development cycle.

252
00:16:10,084 --> 00:16:13,174
This automatics automates the
testing and deployment process.

253
00:16:13,669 --> 00:16:18,639
Which will reduce the development time and
so it would be easy for the team to find

254
00:16:18,719 --> 00:16:21,209
a Early bugs before even going to product.

255
00:16:23,979 --> 00:16:28,459
So there are two real world scenarios
here both are different, examples

256
00:16:28,459 --> 00:16:33,184
where financial institution is using
a cloud And e commerce application is

257
00:16:33,184 --> 00:16:35,694
using microservice architecture, right?

258
00:16:36,114 --> 00:16:37,624
The outcomes are simple, right?

259
00:16:37,694 --> 00:16:39,814
We saw the examples before.

260
00:16:40,184 --> 00:16:42,514
We have an improved
scalability and performance.

261
00:16:42,924 --> 00:16:47,684
Using cloud technologies and faster
development and deploy reduced

262
00:16:47,904 --> 00:16:51,334
reduction in the operation cost
when we use the cloud services.

263
00:16:51,634 --> 00:16:55,904
Similarly, in micro services,
there is a system readability and

264
00:16:55,904 --> 00:16:57,314
reduce the time to the market.

265
00:16:57,779 --> 00:17:01,449
Using the new features because if
you come, if you like integrate

266
00:17:01,929 --> 00:17:05,559
microservices with CNCD, so the
deployment lifecycle will be decreased.

267
00:17:07,669 --> 00:17:10,999
So these are the key takeaways
for the for the key concepts and

268
00:17:10,999 --> 00:17:13,339
takeaways in the entire talk.

269
00:17:13,669 --> 00:17:17,499
So we will, so this is
virtualization, contamination

270
00:17:17,499 --> 00:17:18,759
and serverless computing, right?

271
00:17:19,119 --> 00:17:22,549
So virtualization abstracts the
physical hardware and creates virtual

272
00:17:22,739 --> 00:17:24,899
machines optimize the resource usage.

273
00:17:25,224 --> 00:17:28,394
This will, this is happening using
virtualization and containerization.

274
00:17:28,854 --> 00:17:33,294
Dockers will have the applications for
consistent developments and K eight will

275
00:17:33,294 --> 00:17:38,154
have the container and ate deployment
and management here using K eight.

276
00:17:39,024 --> 00:17:41,634
So this server is computing.

277
00:17:41,684 --> 00:17:44,984
We focus main on the business
logic without even worrying about.

278
00:17:45,419 --> 00:17:46,649
How to manage the server.

279
00:17:46,709 --> 00:17:50,809
And so this is using, leveraging
the cloud platform infrastructures.

280
00:17:52,589 --> 00:17:57,329
So we'll see a demo on how we are
going to achieve this in a simple demo,

281
00:17:59,619 --> 00:17:59,889
right?

282
00:18:00,279 --> 00:18:03,503
So here we are seeing a
spring boot application where

283
00:18:03,573 --> 00:18:04,683
we have a rest controller.

284
00:18:04,743 --> 00:18:06,663
So this is nothing but a Spring Boot app.

285
00:18:07,093 --> 00:18:08,763
We have a get mapping.

286
00:18:09,108 --> 00:18:10,218
Which is slash hello.

287
00:18:10,548 --> 00:18:16,428
So whenever a SDP request is
coming, so this will be called and

288
00:18:16,428 --> 00:18:18,258
the request has been processed.

289
00:18:18,808 --> 00:18:20,308
We see a docker file here.

290
00:18:21,808 --> 00:18:25,528
So this docker file is nothing but
the containerization, A Docker file.

291
00:18:25,528 --> 00:18:27,898
This is used to containerize,
this Spring Boot app.

292
00:18:28,388 --> 00:18:32,353
It's used to package the enter application
and it dependency into a container.

293
00:18:32,863 --> 00:18:35,673
The first line says from OpenJDK.

294
00:18:35,673 --> 00:18:40,153
This line specifies the base image
of the container and it, it's

295
00:18:40,153 --> 00:18:43,283
making sure that it is available
to run the application, right?

296
00:18:43,843 --> 00:18:47,363
And we are setting the working
directory to slash app and copying

297
00:18:47,363 --> 00:18:50,673
the jar file, which is created on
the above, the Spring Boot jar.

298
00:18:51,123 --> 00:18:53,033
And we expose 808.

299
00:18:53,508 --> 00:18:56,258
8080, this is the port number
where we are running it.

300
00:18:56,578 --> 00:19:00,248
And the enter point just specifies
the command to run the container.

301
00:19:01,948 --> 00:19:04,918
Going next, the Kubernetes
deployment yaml.

302
00:19:05,168 --> 00:19:09,118
This deployment YAML file here
we are talking about we are just

303
00:19:09,118 --> 00:19:11,548
defining the type of deployment.

304
00:19:11,908 --> 00:19:15,138
If you see, and we.

305
00:19:15,503 --> 00:19:20,073
We have the the most important
confirmation is in this specification

306
00:19:20,073 --> 00:19:21,183
we have replicas, right?

307
00:19:21,693 --> 00:19:26,673
So this replicas will tell the
Kubernetes application how many

308
00:19:26,703 --> 00:19:30,033
instances of the Java application
is going to be deployed, right?

309
00:19:30,273 --> 00:19:33,978
So in this example, we set two
where there are two appli two.

310
00:19:34,008 --> 00:19:38,028
This signifies that there are two
replicas of the J same Java application.

311
00:19:39,128 --> 00:19:41,148
So this is the application which
is running and this ensures

312
00:19:41,148 --> 00:19:44,728
the highly availability of
the of the application, right?

313
00:19:45,378 --> 00:19:49,538
And also, if you see the spec and
container, so here we are taking what

314
00:19:49,838 --> 00:19:52,268
is the application name and the image.

315
00:19:52,438 --> 00:19:56,698
So here, when we talked about
cross cross platform deployment

316
00:19:57,188 --> 00:20:01,008
cross cloud deployments, so we
talked about we can deploy multiple

317
00:20:01,008 --> 00:20:02,608
application application in multiple.

318
00:20:03,108 --> 00:20:08,048
So here in the image, we mentioned the
docker image used for this container.

319
00:20:08,478 --> 00:20:12,188
This is now pulled from AWS,
but you can change it to Google

320
00:20:12,208 --> 00:20:13,848
cloud or whatever we need, right?

321
00:20:14,188 --> 00:20:17,658
So this signifies which which
particular provider we need to use.

322
00:20:18,818 --> 00:20:22,528
So this relevance of this Kubernetes
deployment like this automates

323
00:20:22,708 --> 00:20:27,038
the management of containerized
application, which so here we will

324
00:20:27,088 --> 00:20:31,068
tell where to be deployed and how
many replicas are should be installed.

325
00:20:31,069 --> 00:20:36,948
And this can be automatically scaling
automatically scaling is being added here.

326
00:20:37,018 --> 00:20:38,508
So this can be used for that.

327
00:20:40,538 --> 00:20:47,038
And this YAML file here, this
Kubernetes service YAML file, here we

328
00:20:47,038 --> 00:20:49,298
define the application API version.

329
00:20:49,298 --> 00:20:49,368
And that's it.

330
00:20:49,838 --> 00:20:55,678
The name of the application and the load
balancer here the kubernetes service

331
00:20:55,678 --> 00:20:59,218
file takes the responsibility of exposing
our service to the public, right?

332
00:20:59,938 --> 00:21:03,838
Where whenever a HTTP request
comes kubernetes load balancer

333
00:21:03,868 --> 00:21:07,358
will take that and it will decide
which replica to be called, right?

334
00:21:07,608 --> 00:21:11,448
If there is any issue with one of
the application, it automatically

335
00:21:11,468 --> 00:21:12,408
goes to the second one.

336
00:21:13,038 --> 00:21:15,308
Kubernetes like load balancer
will take care of that.

337
00:21:15,843 --> 00:21:17,653
And the target port
number, we define it here.

338
00:21:18,673 --> 00:21:22,923
And the Terraform script here
this is making that complete

339
00:21:22,923 --> 00:21:24,013
infrastructure has code.

340
00:21:24,593 --> 00:21:27,283
We define, instead of doing
the configuration every time,

341
00:21:27,283 --> 00:21:31,243
DevOps engineers use this and the
developers write Terraform scripts

342
00:21:31,633 --> 00:21:33,663
using Terraform command in it.

343
00:21:33,903 --> 00:21:36,423
And once everything is
verified, they'll do apply.

344
00:21:38,368 --> 00:21:41,098
Here we are defining
the source AWS module.

345
00:21:41,468 --> 00:21:45,038
We have the cluster name, the
cluster version, and we define

346
00:21:45,058 --> 00:21:46,238
the node groups here, right?

347
00:21:46,638 --> 00:21:49,978
So what is the desired capacity,
max capacity, and min capacity?

348
00:21:49,988 --> 00:21:54,648
At least one node, maximum three nodes,
and the like desired capacity is two.

349
00:21:54,998 --> 00:21:58,528
So this here we are defined
whatever we wrote there we can

350
00:21:58,538 --> 00:21:59,898
have the infrastructure as code.

351
00:22:00,208 --> 00:22:03,368
Whenever is needed, we can run the
script and it will create all the infra.

352
00:22:03,868 --> 00:22:05,118
This is nothing but infrastructure.

353
00:22:07,178 --> 00:22:11,888
The final output of this demo is
like we are running a K8 cluster

354
00:22:11,968 --> 00:22:15,349
with a load balancer and the final
output will have a response from

355
00:22:15,349 --> 00:22:16,679
the Spring Boot microservice.

356
00:22:18,049 --> 00:22:18,649
Has already.

357
00:22:19,169 --> 00:22:19,499
Yeah.

358
00:22:19,919 --> 00:22:24,209
So a spring, a simple springboard
microservice using docker.

359
00:22:24,419 --> 00:22:29,409
We ize that and it is deployed in
a E Ks Cooper Andes cluster, and we

360
00:22:29,409 --> 00:22:31,539
are exposing using the load balancer.

361
00:22:32,209 --> 00:22:35,339
The final output is a very highly
scalable, and scalable very

362
00:22:35,389 --> 00:22:36,829
available and scalable application.

363
00:22:36,914 --> 00:22:40,454
Which is applicable, which is
accessed via public URL, right?

364
00:22:40,884 --> 00:22:46,214
So here this architecture if you see the
Spring Boot microservice along with along

365
00:22:46,224 --> 00:22:52,364
with the Docker K8 and cloud service,
this makes this architecture ensure

366
00:22:52,364 --> 00:22:56,444
that application is resilient, scalable,
and portable access around the world.

367
00:22:56,814 --> 00:22:58,024
All the cloud platforms.

368
00:22:59,604 --> 00:23:02,824
So the conclusion is Java represents
a powerful synergy, right?

369
00:23:03,094 --> 00:23:07,584
The application is made, the microservices
developed using Java, which is a

370
00:23:08,034 --> 00:23:11,644
which is a powerful programming
language, which we discussed, and

371
00:23:11,644 --> 00:23:15,214
this drives the digital transformation
across multiple industries, right?

372
00:23:15,564 --> 00:23:19,424
You take Netflix, e commerce
applications like Amazon, eBay.

373
00:23:19,964 --> 00:23:23,874
And many financial banking
organizations use this combination.

374
00:23:24,334 --> 00:23:29,074
So this cloud computing offers significant
advantages, including the scalability,

375
00:23:29,444 --> 00:23:32,864
cost efficiency, and operation agility.

376
00:23:33,244 --> 00:23:36,934
This will enable most of the applications,
most of the organizations, right?

377
00:23:37,304 --> 00:23:40,664
By leveraging AWS, Microsoft,
and Google Cloud, right?

378
00:23:41,244 --> 00:23:43,814
So that's all I have.

379
00:23:44,294 --> 00:23:45,124
Thank you guys.

380
00:23:46,594 --> 00:23:47,284
All the best.

381
00:23:47,344 --> 00:23:47,774
Bye bye.

